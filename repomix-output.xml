This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/workflows/deploy.yml
.gitignore
.trae/documents/README 검증 및 불일치 해결 계획.md
App.tsx
components/AddAssetForm.tsx
components/AddNewAssetModal.tsx
components/AllocationChart.tsx
components/AssetTrendChart.tsx
components/BulkUploadModal.tsx
components/CategorySummaryTable.tsx
components/common/Toggle.tsx
components/DataConflictModal.tsx
components/EditAssetModal.tsx
components/ExchangeRateInput.tsx
components/Header.tsx
components/PortfolioAssistant.tsx
components/PortfolioModal.tsx
components/PortfolioTable.tsx
components/ProfitLossChart.tsx
components/RegionAllocationChart.tsx
components/SellAlertControl.tsx
components/SellAnalyticsPage.tsx
components/SellAssetModal.tsx
components/StatCard.tsx
components/TopBottomAssets.tsx
components/WatchlistPage.tsx
hooks/useGoogleDriveSync.ts
hooks/useOnClickOutside.ts
index.css
index.html
index.tsx
initialData.ts
package.json
postcss.config.js
public/metadata.json
README.md
services/geminiService.ts
services/googleDriveService.ts
services/priceService.ts
services/upbitService.ts
tailwind.config.ts
tsconfig.json
types.ts
utils/migrateData.ts
vite-env.d.ts
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?


.env
.env.local
</file>

<file path=".trae/documents/README 검증 및 불일치 해결 계획.md">
## 검증 요약
- 가격 소스: 주식은 Cloud Run, 암호화폐는 Upbit 사용 — 구현과 일치
- Google Drive 동기화 훅: `hooks/useGoogleDriveSync.ts` — 구현과 일치
- 환율 입력: `ExchangeRateInput.tsx` 존재 및 사용 — 일치
- 분배 차트: `AllocationChart`가 `exchangeRates`를 받아 원화 환산 — 일치
- 포트폴리오 정렬: 수익률 헤더 클릭 순환(수익률↓→수익률↑→평가손익↓→평가손익↑→해제) — 구현과 일치
- 손익 차트: ‘투자 원금’/‘총 평가액’ 라인, 툴팁에 원금/평가/수익률 — 일치
- 타입: `ExchangeRates { USD, JPY }` — 일치
- 환경변수: `VITE_GEMINI_API_KEY`(선택) — 환율 조회에서 사용, 일치

## 발견된 불일치
1. CategorySummaryTable props
- README: `CategorySummaryTable assets totalPortfolioValue exchangeRates`
- 실제: 컴포넌트가 `exchangeRates` prop을 선언/사용하지 않고, 내부에서 환율 없이 원화 환산(임시 1450) 로직을 사용
- App.tsx는 `exchangeRates`를 넘기고 있으나, 컴포넌트는 활용하지 않음(문서와 상이)

2. 수익률 헤더 아이콘 문구(경미)
- README: 아이콘/텍스트로 현재 정렬 상태 표시
- 실제: 텍스트 라벨(▲/▼)로 표시, 별도의 SortIcon은 수익률 헤더엔 미사용 — 기능상 문제 없음(문서 표현만 경미하게 차이)

## 제안 수정(코드/문서 정합화)
1. CategorySummaryTable 정합화
- 컴포넌트에 `exchangeRates: ExchangeRates` prop 추가
- 총 매수금액/평가금액 계산 시 `exchangeRates`를 사용(통화별 환산)
- App.tsx의 전달(`exchangeRates={exchangeRates}`)과 문서 내용이 일치하도록 반영

2. README 경미 수정(선택)
- 수익률 헤더의 “아이콘/텍스트” 표기를 “텍스트 라벨(▲/▼)”로 표현 통일

## 확인 요청
- 위 2개 정합화 작업을 진행해 코드와 README를 100% 일치시키겠습니다. 승인해 주시면 바로 적용하겠습니다.
</file>

<file path="components/AddAssetForm.tsx">

</file>

<file path="components/DataConflictModal.tsx">
import React from 'react';
import { Asset } from '../types';

interface ConflictAsset {
  ticker: string;
  exchange: string;
  name: string;
  localAsset: Asset;
  driveAsset: Asset;
}

interface DataConflictModalProps {
  isOpen: boolean;
  conflicts: ConflictAsset[];
  onSelectLocal: () => void;
  onSelectDrive: () => void;
}

const DataConflictModal: React.FC<DataConflictModalProps> = ({
  isOpen,
  conflicts,
  onSelectLocal,
  onSelectDrive,
}) => {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-gray-800 rounded-lg shadow-xl max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col">
        <div className="p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white mb-2">
            {conflicts.length > 0 ? '데이터 충돌 감지' : '데이터 선택'}
          </h2>
          <p className="text-gray-400 text-sm">
            {conflicts.length > 0 
              ? '로컬 데이터와 Google Drive 데이터에 동일한 종목이 서로 다른 정보로 존재합니다. 사용할 데이터를 선택해주세요.'
              : '로컬 데이터와 Google Drive 데이터가 모두 존재합니다. 사용할 데이터를 선택해주세요.'}
          </p>
        </div>

        <div className="flex-1 overflow-y-auto p-6">
          {conflicts.length > 0 ? (
            <div className="space-y-4">
              {conflicts.map((conflict, index) => (
              <div
                key={index}
                className="bg-gray-700 rounded-lg p-4 border border-gray-600"
              >
                <div className="flex items-center justify-between mb-3">
                  <div>
                    <h3 className="text-lg font-semibold text-white">
                      {conflict.name}
                    </h3>
                    <p className="text-sm text-gray-400">
                      {conflict.ticker} ({conflict.exchange})
                    </p>
                  </div>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {/* 로컬 데이터 */}
                  <div className="bg-gray-900 rounded p-3 border border-blue-500">
                    <div className="text-xs font-semibold text-blue-400 mb-2 uppercase">
                      로컬 데이터
                    </div>
                    <div className="space-y-1 text-sm">
                      <div className="flex justify-between">
                        <span className="text-gray-400">수량:</span>
                        <span className="text-white">{conflict.localAsset.quantity}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">매수가:</span>
                        <span className="text-white">
                          {conflict.localAsset.purchasePrice.toLocaleString()}
                        </span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">매수일:</span>
                        <span className="text-white">{conflict.localAsset.purchaseDate}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">현재가:</span>
                        <span className="text-white">
                          {conflict.localAsset.currentPrice.toLocaleString()}원
                        </span>
                      </div>
                    </div>
                  </div>

                  {/* Google Drive 데이터 */}
                  <div className="bg-gray-900 rounded p-3 border border-green-500">
                    <div className="text-xs font-semibold text-green-400 mb-2 uppercase">
                      Google Drive 데이터
                    </div>
                    <div className="space-y-1 text-sm">
                      <div className="flex justify-between">
                        <span className="text-gray-400">수량:</span>
                        <span className="text-white">{conflict.driveAsset.quantity}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">매수가:</span>
                        <span className="text-white">
                          {conflict.driveAsset.purchasePrice.toLocaleString()}
                        </span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">매수일:</span>
                        <span className="text-white">{conflict.driveAsset.purchaseDate}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">현재가:</span>
                        <span className="text-white">
                          {conflict.driveAsset.currentPrice.toLocaleString()}원
                        </span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            ))}
          </div>
          ) : (
            <div className="text-center py-8">
              <p className="text-gray-400 text-lg">
                로컬 데이터와 Google Drive 데이터가 모두 존재합니다.
              </p>
              <p className="text-gray-500 text-sm mt-2">
                사용할 데이터 소스를 선택해주세요.
              </p>
            </div>
          )}
        </div>

        <div className="p-6 border-t border-gray-700 bg-gray-750">
          <div className="flex flex-col sm:flex-row gap-3 justify-end">
            <button
              onClick={onSelectLocal}
              className="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-md transition duration-300 flex items-center justify-center gap-2"
            >
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" />
              </svg>
              로컬 데이터 사용
            </button>
            <button
              onClick={onSelectDrive}
              className="px-6 py-3 bg-green-600 hover:bg-green-700 text-white font-medium rounded-md transition duration-300 flex items-center justify-center gap-2"
            >
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 15a4 4 0 004 4h9a5 5 0 10-.1-9.999 5.002 5.002 0 10-9.78 2.096A4.001 4.001 0 003 15z" />
              </svg>
              Google Drive 데이터 사용
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default DataConflictModal;
</file>

<file path="components/PortfolioModal.tsx">

</file>

<file path="components/RegionAllocationChart.tsx">

</file>

<file path="components/SellAlertControl.tsx">
import React from 'react';

interface SellAlertControlProps {
  value: number;
  onChange: (newValue: number) => void;
}

const SellAlertControl: React.FC<SellAlertControlProps> = ({ value, onChange }) => {
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value === '' ? 0 : parseInt(e.target.value, 10);
    if (!isNaN(newValue) && newValue >= 0) {
      onChange(newValue);
    }
  };

  return (
    <div className="bg-gray-800 p-4 rounded-lg shadow-lg mb-6 flex items-center justify-between" title="포트폴리오 전체에 적용될 기본 매도 알림 기준입니다. 개별 자산 수정 화면에서 자산별로 다른 기준을 설정할 수 있습니다.">
      <div className="flex items-center">
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-yellow-400 mr-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
          <path strokeLinecap="round" strokeLinejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
        </svg>
        <label htmlFor="sell-alert-rate" className="text-sm font-medium text-gray-300">
          매도 알림 하락률 설정 (%)
        </label>
      </div>
      <div className="flex items-center">
        <span className="text-gray-400 mr-2">최고가 대비</span>
        <input
          id="sell-alert-rate"
          type="number"
          value={value}
          onChange={handleInputChange}
          min="0"
          className="w-20 bg-gray-700 border border-gray-600 rounded-md py-1 px-2 text-white text-center font-bold focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition"
        />
        <span className="text-gray-400 ml-2">% 이하 하락 시 알림</span>
      </div>
    </div>
  );
};

export default SellAlertControl;
</file>

<file path="components/StatCard.tsx">
import React from 'react';

interface StatCardProps {
  title: string;
  value: string;
  isProfit?: boolean;
  tooltip?: string;
  onClick?: () => void;
  isAlert?: boolean;
  size?: 'normal' | 'small';
}

const StatCard: React.FC<StatCardProps> = ({ title, value, isProfit, tooltip, onClick, isAlert, size = 'normal' }) => {
  const valueColor = isAlert
    ? 'text-yellow-400'
    : isProfit === undefined 
    ? 'text-white' 
    : isProfit 
    ? 'text-success' 
    : 'text-danger';

  const containerClasses = `bg-gray-800 ${size === 'small' ? 'p-3' : 'p-6'} rounded-lg shadow-lg ${onClick ? 'cursor-pointer hover:bg-gray-700 transition-colors' : ''}`;
  const titleClasses = `font-medium uppercase tracking-wider ${size === 'small' ? 'text-xs' : 'text-sm'} ${isAlert ? 'text-yellow-400' : 'text-gray-400'}`;
  const valueClasses = `font-bold ${size === 'small' ? 'text-2xl mt-1' : 'text-3xl mt-2'} ${valueColor}`;


  return (
    <div className={containerClasses} title={tooltip} onClick={onClick}>
      <h3 className={titleClasses}>{title}</h3>
      <p className={valueClasses}>{value}</p>
    </div>
  );
};

export default StatCard;
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "types": [
      "node"
    ],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true
  }
}
</file>

<file path="vite-env.d.ts">
/// <reference types="vite/client" />

interface ImportMetaEnv {
    readonly VITE_GEMINI_API_KEY: string
    readonly VITE_GOOGLE_CLIENT_ID: string
  }
  
  interface ImportMeta {
    readonly env: ImportMetaEnv
  }
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  base: '/asset-manager/', // GitHub Pages 저장소 이름에 맞게 변경하세요
      server: {
    port: 3000 // 원하는 포트로 변경 가능
      }
})
</file>

<file path="components/AllocationChart.tsx">
import React, { useMemo } from 'react';
import { Asset, AssetCategory, ExchangeRates, Currency } from '../types';
import { PieChart, Pie, Cell, Tooltip, ResponsiveContainer } from 'recharts';

interface AllocationChartProps {
  assets: Asset[];
  exchangeRates: ExchangeRates;
}

const COLORS = ['#6366F1', '#10B981', '#F59E0B', '#EF4444', '#3B82F6', '#8B5CF6', '#EC4899', '#F97316', '#84CC16'];

interface ChartData {
  name: AssetCategory;
  value: number;
}

const CustomTooltip: React.FC<any> = ({ active, payload, totalValue }) => {
  if (active && payload && payload.length) {
    const { name, value } = payload[0].payload;
    const percent = totalValue > 0 ? (value / totalValue) * 100 : 0;
    return (
      <div className="bg-gray-700 p-3 rounded-md border border-gray-600 shadow-lg">
        <p className="font-bold text-white">{name}</p>
        <p className="text-sm text-gray-300">
          금액: {value.toLocaleString('ko-KR', { style: 'currency', currency: 'KRW', maximumFractionDigits: 0 })}
        </p>
         <p className="text-sm text-gray-300">
          비중: {percent.toFixed(2)}%
        </p>
      </div>
    );
  }
  return null;
};

const AllocationChart: React.FC<AllocationChartProps> = ({ assets, exchangeRates }) => {
  const chartData = useMemo(() => {
    const categoryTotals = new Map<AssetCategory, number>();
    assets.forEach(asset => {
      // [수정] 환율 적용하여 원화 가치로 변환
      const rate = asset.currency === Currency.KRW ? 1 : (exchangeRates[asset.currency] || 0);
      const value = asset.currentPrice * asset.quantity * rate;
      
      categoryTotals.set(asset.category, (categoryTotals.get(asset.category) || 0) + value);
    });
    return Array.from(categoryTotals.entries()).map(([name, value]) => ({ name, value }));
  }, [assets, exchangeRates]);

  const totalValue = useMemo(() => chartData.reduce((sum, entry) => sum + entry.value, 0), [chartData]);

  return (
    <div className="bg-gray-800 p-6 rounded-lg shadow-lg h-96" title="자산 종류별 비중을 원형 차트로 보여줍니다.">
      <h2 className="text-xl font-bold text-white mb-4">자산 종류별 배분</h2>
      {assets.length > 0 ? (
        <ResponsiveContainer width="100%" height="100%">
          <PieChart margin={{ top: 20, right: 30, bottom: 20, left: 30 }}>
            <Pie
              data={chartData}
              cx="50%"
              cy="50%"
              labelLine={true}
              label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
              outerRadius={80}
              fill="#8884d8"
              dataKey="value"
              nameKey="name"
            >
              {chartData.map((entry, index) => (
                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
              ))}
            </Pie>
            <Tooltip content={<CustomTooltip totalValue={totalValue} />} />
          </PieChart>
        </ResponsiveContainer>
      ) : (
        <div className="flex items-center justify-center h-full">
            <p className="text-gray-500">표시할 데이터가 없습니다.</p>
        </div>
      )}
    </div>
  );
};

export default AllocationChart;
</file>

<file path="components/AssetTrendChart.tsx">
import React, { useMemo } from 'react';
import { PortfolioSnapshot } from '../types';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';

interface AssetTrendChartProps {
  history: PortfolioSnapshot[];
  assetId: string;
  assetName: string;
  currentQuantity: number; // [추가] 역산용 현재 수량
}

const AssetTrendChart: React.FC<AssetTrendChartProps> = ({ history, assetId, assetName, currentQuantity }) => {
  const chartData = useMemo(() => {
    if (!history || history.length === 0) {
      return [];
    }

    const data = history.map(snapshot => {
      const assetSnapshot = snapshot.assets.find(a => a.id === assetId);
      
      let price = 0;
      if (assetSnapshot) {
        // 1순위: 기록된 단가 사용
        if (assetSnapshot.unitPrice !== undefined && assetSnapshot.unitPrice > 0) {
            price = assetSnapshot.unitPrice;
        } 
        // 2순위: 단가가 없으면(과거 데이터) 현재가치 / 수량으로 역산 (수량 불변 가정)
        else if (currentQuantity > 0) {
            price = assetSnapshot.currentValue / currentQuantity;
        }
      }
      
      return {
        date: new Date(snapshot.date).toLocaleDateString('ko-KR', { month: '2-digit', day: '2-digit' }),
        '현재가': Math.round(price), // 소수점 제거
      };
    }).filter(d => d['현재가'] > 0);

    return data;
  }, [history, assetId, assetName, currentQuantity]);

  const formatCurrency = (value: number) => {
    return value.toLocaleString('ko-KR', { maximumFractionDigits: 0 });
  };

  return (
    <div className="bg-gray-800 p-4 rounded-lg h-64">
      <h3 className="text-md font-bold text-white mb-4 text-center">{`"${assetName}" 현재가 추이`}</h3>
      {chartData.length > 1 ? (
        <ResponsiveContainer width="100%" height="85%">
          <LineChart data={chartData} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
            <CartesianGrid strokeDasharray="3 3" stroke="#4A5568" />
            <XAxis dataKey="date" stroke="#A0AEC0" fontSize={12} />
            <YAxis stroke="#A0AEC0" fontSize={12} tickFormatter={formatCurrency} width={80} domain={['auto', 'auto']} />
            <Tooltip
              formatter={(value: number) => [`${formatCurrency(value)} 원`, '현재가']}
              contentStyle={{ backgroundColor: '#2D3748', border: '1px solid #4A5568', borderRadius: '0.5rem' }}
              labelStyle={{ color: '#E2E8F0' }}
              itemStyle={{ fontWeight: 'bold', color: '#818CF8' }}
            />
            <Legend wrapperStyle={{fontSize: "12px", bottom: -10}} />
            <Line type="monotone" dataKey="현재가" stroke="#818CF8" strokeWidth={2} dot={{ r: 3 }} activeDot={{ r: 6 }} />
          </LineChart>
        </ResponsiveContainer>
      ) : (
        <div className="flex items-center justify-center h-full">
          <p className="text-gray-500 text-sm">추이 데이터가 부족합니다.</p>
        </div>
      )}
    </div>
  );
};

export default AssetTrendChart;
</file>

<file path="components/BulkUploadModal.tsx">
import React, { useState, useRef, useCallback } from 'react';
import { AssetCategory, Currency, EXCHANGE_MAP, BulkUploadResult, ALLOWED_CATEGORIES } from '../types';

interface BulkUploadModalProps {
  isOpen: boolean;
  onClose: () => void;
  onFileUpload: (file: File) => Promise<BulkUploadResult>;
}

const BulkUploadModal: React.FC<BulkUploadModalProps> = ({ isOpen, onClose, onFileUpload }) => {
  const [view, setView] = useState<'instructions' | 'loading' | 'results'>('instructions');
  const [result, setResult] = useState<BulkUploadResult | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const resetModal = useCallback(() => {
    setView('instructions');
    setResult(null);
    onClose();
  }, [onClose]);

  const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    setView('loading');
    try {
      const uploadResult = await onFileUpload(file);
      setResult(uploadResult);
      setView('results');
    } catch (e: any) {
       setResult({ successCount: 0, failedCount: 0, errors: [{ ticker: '파일 처리 오류', reason: e.message }] });
       setView('results');
    }
    
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const handleUploadClick = () => {
    fileInputRef.current?.click();
  };

  const handleDownloadTemplate = () => {
    const csvHeader = "ticker,exchange,quantity,purchasePrice,purchaseDate,category,currency\n";
    const csvExample = `AAPL,NASDAQ,10,150,2023-01-15,${AssetCategory.US_STOCK},${Currency.USD}\n005930,"KRX (코스피/코스닥)",20,70000,2023-03-22,${AssetCategory.KOREAN_STOCK},${Currency.KRW}\n`;
    const csvContent = csvHeader + csvExample;
    const blob = new Blob([`\uFEFF${csvContent}`], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'portfolio_template.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };
  
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-50" onClick={resetModal} role="dialog" aria-modal="true">
      <div className="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-3xl" onClick={(e) => e.stopPropagation()}>
        {view === 'instructions' && (
          <div>
            <h2 className="text-2xl font-bold text-white mb-4">CSV 일괄 등록</h2>
            <p className="text-gray-400 mb-4">CSV 파일을 사용하여 여러 자산을 한 번에 등록할 수 있습니다. 아래 형식을 준수해주세요.</p>
            <div className="bg-gray-900 p-4 rounded-md mb-4">
              <p className="text-sm text-gray-300 font-mono">ticker,exchange,quantity,purchasePrice,purchaseDate,category,currency</p>
              <p className="text-sm text-gray-500 font-mono mt-2">AAPL,NASDAQ,10,150.00,2023-01-15,미국주식,USD</p>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <div className="text-sm text-gray-400 space-y-2">
                    <p><strong className="text-gray-200">필수 헤더:</strong> <code>ticker, exchange, quantity, purchasePrice, purchaseDate, category, currency</code> 순서로 작성해야 합니다.</p>
                    <p><strong className="text-gray-200">category 값:</strong> <code>{ALLOWED_CATEGORIES.join(', ')}</code> 중 하나여야 합니다.</p>
                    <p><strong className="text-gray-200">currency 값:</strong> <code>{Object.values(Currency).join(', ')}</code> 중 하나여야 합니다.</p>
                </div>
                <div className="text-sm">
                    <strong className="text-gray-200">사용 가능한 Exchange 값:</strong>
                    <div className="max-h-32 overflow-y-auto bg-gray-900 p-2 mt-1 rounded-md text-gray-400 text-xs">
                        {Object.entries(EXCHANGE_MAP).map(([category, exchanges]) => (
                            <div key={category} className="mb-1">
                                <span className="font-semibold text-gray-300">{category}:</span>
                                <span className="font-mono ml-2">{exchanges.join(', ')}</span>
                            </div>
                        ))}
                    </div>
                </div>
            </div>

            <input type="file" ref={fileInputRef} onChange={handleFileSelect} accept=".csv,text/csv" className="hidden" />
            <div className="flex justify-between items-center mt-8">
              <button onClick={handleDownloadTemplate} className="text-primary hover:text-primary-light transition font-medium">양식 다운로드</button>
              <div className="flex gap-4">
                 <button onClick={resetModal} className="bg-gray-600 hover:bg-gray-500 text-white font-medium py-2 px-4 rounded-md transition duration-300">취소</button>
                 <button onClick={handleUploadClick} className="bg-primary hover:bg-primary-dark text-white font-bold py-2 px-4 rounded-md transition duration-300">파일 선택하여 업로드</button>
              </div>
            </div>
          </div>
        )}
        {view === 'loading' && (
          <div className="flex flex-col items-center justify-center p-8 h-64">
            <svg className="animate-spin h-10 w-10 text-white mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p className="text-xl text-white">자산 정보를 처리 중입니다...</p>
            <p className="text-gray-400 mt-2">등록할 자산 수에 따라 몇 분 정도 소요될 수 있습니다.</p>
          </div>
        )}
        {view === 'results' && result && (
          <div>
            <h2 className="text-2xl font-bold text-white mb-4">일괄 등록 결과</h2>
            <div className="flex gap-4 mb-4 text-center">
               <div className="bg-success/20 text-success p-4 rounded-lg flex-1">
                    <p className="text-sm">성공</p>
                    <p className="text-3xl font-bold">{result.successCount}</p>
               </div>
               <div className="bg-danger/20 text-danger p-4 rounded-lg flex-1">
                    <p className="text-sm">실패</p>
                    <p className="text-3xl font-bold">{result.failedCount}</p>
               </div>
            </div>
            {result.errors.length > 0 && (
                <div className="mt-4">
                    <h3 className="text-lg font-semibold text-white mb-2">실패 내역</h3>
                    <div className="max-h-48 overflow-y-auto bg-gray-900 p-3 rounded-md">
                        <ul className="space-y-2 text-sm">
                            {result.errors.map((err, index) => (
                                <li key={index} className="flex justify-between items-center p-2 rounded bg-gray-700">
                                    <span className="font-mono text-red-400 font-semibold">{err.ticker}</span>
                                    <span className="text-gray-300 text-right">{err.reason}</span>
                                </li>
                            ))}
                        </ul>
                    </div>
                </div>
            )}
            <div className="mt-8 flex justify-end">
                 <button onClick={resetModal} className="bg-primary hover:bg-primary-dark text-white font-bold py-2 px-4 rounded-md transition duration-300">확인</button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default BulkUploadModal;
</file>

<file path="components/CategorySummaryTable.tsx">
import React, { useMemo } from 'react';
import { Asset, AssetCategory, Currency, ExchangeRates } from '../types';

interface CategorySummaryTableProps {
    assets: Asset[];
    totalPortfolioValue: number;
    exchangeRates: ExchangeRates;
}

interface SummaryData {
    category: AssetCategory;
    totalValue: number;
    totalProfitLoss: number;
    totalReturn: number;
    allocation: number;
}

const CategorySummaryTable: React.FC<CategorySummaryTableProps> = ({ assets, totalPortfolioValue, exchangeRates }) => {
    const summaryData = useMemo((): SummaryData[] => {
        const categoryMap = new Map<AssetCategory, { totalValue: number; totalPurchaseValue: number }>();

        assets.forEach(asset => {
            if (!categoryMap.has(asset.category)) {
                categoryMap.set(asset.category, { totalValue: 0, totalPurchaseValue: 0 });
            }
            const data = categoryMap.get(asset.category)!;

            // [수정] 현재가 환율 적용
            const rate = asset.currency === Currency.KRW ? 1 : (exchangeRates[asset.currency] || 0);
            const currentValueKRW = asset.currentPrice * asset.quantity * rate;
            
            data.totalValue += currentValueKRW;

            // [수정] 매수가 계산 로직 (기존 로직 유지하되 안전장치 추가)
            let purchaseValueKRW;
            if (asset.currency === Currency.KRW) {
                purchaseValueKRW = asset.purchasePrice * asset.quantity;
            } else if (asset.purchaseExchangeRate) {
                purchaseValueKRW = asset.purchasePrice * asset.purchaseExchangeRate * asset.quantity;
            } else if (asset.priceOriginal > 0) {
                const impliedRate = asset.currentPrice / asset.priceOriginal;
                purchaseValueKRW = asset.purchasePrice * impliedRate * asset.quantity;
            } else {
                purchaseValueKRW = asset.purchasePrice * asset.quantity * rate;
            }
            data.totalPurchaseValue += purchaseValueKRW;
        });

        const result: SummaryData[] = [];
        for (const [category, data] of categoryMap.entries()) {
            const totalProfitLoss = data.totalValue - data.totalPurchaseValue;
            const totalReturn = data.totalPurchaseValue === 0 ? 0 : (totalProfitLoss / data.totalPurchaseValue) * 100;
            const allocation = totalPortfolioValue > 0 ? (data.totalValue / totalPortfolioValue) * 100 : 0;
            result.push({
                category,
                totalValue: data.totalValue,
                totalProfitLoss,
                totalReturn,
                allocation,
            });
        }
        
        return result.sort((a, b) => b.totalValue - a.totalValue);

    }, [assets, totalPortfolioValue, exchangeRates]);

    const formatKRW = (num: number) => {
        return new Intl.NumberFormat('ko-KR', { style: 'currency', currency: 'KRW', maximumFractionDigits: 0 }).format(num);
    };

    const getChangeColor = (value: number) => {
        if (value > 0) return 'text-success';
        if (value < 0) return 'text-danger';
        return 'text-gray-400';
    };

    if (summaryData.length === 0) return null;

    return (
        <div className="bg-gray-800 p-6 rounded-lg shadow-lg" title="자산 종류별 요약 정보입니다.">
            <h2 className="text-xl font-bold text-white mb-4">자산군별 요약</h2>
            <div className="w-full overflow-x-auto">
                <table className="w-full text-sm text-left text-gray-400">
                    <thead className="text-xs text-gray-300 uppercase bg-gray-700">
                        <tr>
                            <th scope="col" className="px-4 py-2">자산 구분</th>
                            <th scope="col" className="px-4 py-2 text-right">평가금액</th>
                            <th scope="col" className="px-4 py-2 text-right">손익</th>
                            <th scope="col" className="px-4 py-2 text-right">수익률</th>
                            <th scope="col" className="px-4 py-2 text-right">비중</th>
                        </tr>
                    </thead>
                    <tbody>
                        {summaryData.map(item => (
                            <tr key={item.category} className="border-b border-gray-700">
                                <td className="px-4 py-3 font-medium text-white">{item.category}</td>
                                <td className="px-4 py-3 text-right">{formatKRW(item.totalValue)}</td>
                                <td className={`px-4 py-3 text-right font-medium ${getChangeColor(item.totalProfitLoss)}`}>{formatKRW(item.totalProfitLoss)}</td>
                                <td className={`px-4 py-3 text-right font-medium ${getChangeColor(item.totalReturn)}`}>{item.totalReturn.toFixed(2)}%</td>
                                <td className="px-4 py-3 text-right">{item.allocation.toFixed(2)}%</td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </div>
    );
};

export default CategorySummaryTable;
</file>

<file path="components/common/Toggle.tsx">
import React from 'react';

interface ToggleProps {
  label?: string;
  checked: boolean;
  onChange: (checked: boolean) => void;
  className?: string;
  title?: string;
}

const Toggle: React.FC<ToggleProps> = ({ label, checked, onChange, className = '', title }) => {
  return (
    <label className={`flex items-center cursor-pointer ${className}`} title={title}>
      <div className="relative">
        <input
          type="checkbox"
          className="sr-only"
          checked={checked}
          onChange={(e) => onChange(e.target.checked)}
        />
        <div className={`block ${checked ? 'bg-primary' : 'bg-gray-600'} w-10 h-6 rounded-full transition-colors duration-300 ease-in-out`}></div>
        <div className={`absolute left-1 top-1 w-4 h-4 rounded-full bg-white transition-transform duration-300 ease-in-out ${checked ? 'transform translate-x-full' : ''}`}></div>
      </div>
      {label && (
        <div className="ml-3 text-sm font-medium text-gray-300">{label}</div>
      )}
    </label>
  );
};

export default Toggle;
</file>

<file path="components/ExchangeRateInput.tsx">
import React from 'react';
import { ExchangeRates } from '../types';

interface Props {
  rates: ExchangeRates;
  onRatesChange: (rates: ExchangeRates) => void;
  showWarning?: boolean;
}

const ExchangeRateInput: React.FC<Props> = ({ rates, onRatesChange, showWarning }) => {
  return (
    <div className="bg-gray-800 p-4 rounded-lg shadow-lg">
      <div className="flex items-center gap-6 flex-wrap">
        <div className="flex items-center gap-2">
          <label className="text-sm text-gray-300">USD→KRW</label>
          <input
            type="number"
            step="0.01"
            value={rates.USD || 0}
            onChange={(e) => onRatesChange({ ...rates, USD: parseFloat(e.target.value) || 0 })}
            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm w-28"
            placeholder="예: 1400"
          />
        </div>
        <div className="flex items-center gap-2">
          <label className="text-sm text-gray-300">JPY→KRW</label>
          <input
            type="number"
            step="0.01"
            value={rates.JPY || 0}
            onChange={(e) => onRatesChange({ ...rates, JPY: parseFloat(e.target.value) || 0 })}
            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm w-28"
            placeholder="예: 9.5"
          />
        </div>
        {showWarning && (
          <div className="text-yellow-400 text-sm">
            환율을 입력하세요. 미입력 시 원화 환산 값이 0으로 표시됩니다.
          </div>
        )}
      </div>
    </div>
  );
};

export default ExchangeRateInput;
</file>

<file path="components/TopBottomAssets.tsx">
import React, { useMemo } from 'react';
import { Asset, Currency } from '../types';

interface TopBottomAssetsProps {
    assets: Asset[];
}

interface EnrichedAsset extends Asset {
    metrics: {
        returnPercentage: number;
        profitLoss: number;
    }
}

const TopBottomAssets: React.FC<TopBottomAssetsProps> = ({ assets }) => {
    const enrichedAssets = useMemo((): EnrichedAsset[] => {
        return assets.map(asset => {
            const currentValue = asset.currentPrice * asset.quantity;
            
            let purchaseValueKRW;
            if (asset.currency === Currency.KRW) {
                purchaseValueKRW = asset.purchasePrice * asset.quantity;
            } else if (asset.purchaseExchangeRate) {
                purchaseValueKRW = asset.purchasePrice * asset.purchaseExchangeRate * asset.quantity;
            } else if (asset.priceOriginal > 0) {
                const exchangeRate = asset.currentPrice / asset.priceOriginal;
                purchaseValueKRW = asset.purchasePrice * exchangeRate * asset.quantity;
            } else {
                purchaseValueKRW = asset.purchasePrice * asset.quantity;
            }

            const profitLoss = currentValue - purchaseValueKRW;
            const returnPercentage = purchaseValueKRW === 0 ? 0 : (profitLoss / purchaseValueKRW) * 100;
            
            return {
                ...asset,
                metrics: {
                    returnPercentage,
                    profitLoss,
                }
            };
        });
    }, [assets]);

    const sortedAssets = useMemo(() => {
        return [...enrichedAssets].sort((a, b) => a.metrics.returnPercentage - b.metrics.returnPercentage);
    }, [enrichedAssets]);

    const bottomAssets = sortedAssets.slice(0, 5);
    const topAssets = sortedAssets.slice(-5).reverse();

    const formatKRW = (num: number) => {
        return new Intl.NumberFormat('ko-KR', { style: 'currency', currency: 'KRW', maximumFractionDigits: 0 }).format(num);
    };

    const getChangeColor = (value: number) => {
        if (value > 0) return 'text-success';
        if (value < 0) return 'text-danger';
        return 'text-gray-400';
    };

    const AssetListItem: React.FC<{asset: EnrichedAsset}> = ({ asset }) => (
        <li className="flex justify-between items-center py-2 border-b border-gray-700/50 last:border-b-0">
            <div className="flex-1 overflow-hidden">
                <p className="text-white font-medium truncate" title={(asset.customName?.trim() || asset.name)}>{(asset.customName?.trim() || asset.name)}</p>
                <p className="text-xs text-gray-500">{formatKRW(asset.metrics.profitLoss)}</p>
            </div>
            <div className={`text-right font-bold ml-4 ${getChangeColor(asset.metrics.returnPercentage)}`}>
                {asset.metrics.returnPercentage.toFixed(2)}%
            </div>
        </li>
    );

    if (assets.length === 0) {
        return null;
    }

    return (
        <div className="bg-gray-800 p-6 rounded-lg shadow-lg" title="수익률 기준 상위 및 하위 5개 자산 현황입니다.">
            <h2 className="text-xl font-bold text-white mb-4">자산별 성과 요약</h2>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-x-16 gap-y-6">
                <div>
                    <h3 className="text-lg font-semibold text-success mb-2">수익률 TOP 5</h3>
                    {topAssets.length > 0 ? (
                        <ul className="space-y-1">
                            {topAssets.map(asset => <AssetListItem key={asset.id} asset={asset} />)}
                        </ul>
                    ) : <p className="text-gray-500 text-sm">데이터가 없습니다.</p>}
                </div>
                <div>
                    <h3 className="text-lg font-semibold text-danger mb-2">수익률 BOTTOM 5</h3>
                    {bottomAssets.length > 0 ? (
                        <ul className="space-y-1">
                            {bottomAssets.map(asset => <AssetListItem key={asset.id} asset={asset} />)}
                        </ul>
                    ) : <p className="text-gray-500 text-sm">데이터가 없습니다.</p>}
                </div>
            </div>
        </div>
    );
};

export default TopBottomAssets;
</file>

<file path="hooks/useGoogleDriveSync.ts">
import { useCallback, useEffect, useRef, useState } from 'react';
import { googleDriveService, GoogleUser } from '../services/googleDriveService';
import { Asset, PortfolioSnapshot, SellRecord, WatchlistItem, ExchangeRates } from '../types';

interface UseGoogleDriveSyncOptions {
  onError?: (msg: string) => void;
  onSuccessMessage?: (msg: string) => void;
}

interface LoadedData {
  assets: Asset[];
  portfolioHistory: PortfolioSnapshot[];
  sellHistory: SellRecord[];
  watchlist: WatchlistItem[];
  exchangeRates?: ExchangeRates;
}

export function useGoogleDriveSync(options: UseGoogleDriveSyncOptions = {}) {
  const [isSignedIn, setIsSignedIn] = useState<boolean>(false);
  const [googleUser, setGoogleUser] = useState<GoogleUser | null>(null);
  const [isInitializing, setIsInitializing] = useState<boolean>(true);
  const timeoutIdRef = useRef<NodeJS.Timeout | null>(null);
  const isSavingRef = useRef<boolean>(false);
  const lastSavedDataRef = useRef<string | null>(null);

  useEffect(() => {
    const init = async () => {
      try {
        const clientId = import.meta.env.VITE_GOOGLE_CLIENT_ID;
        if (clientId) {
          await googleDriveService.initialize(clientId);
          if (googleDriveService.isSignedIn()) {
            setIsSignedIn(true);
            setGoogleUser(googleDriveService.getCurrentUser());
          }
        }
      } catch (e) {
      } finally {
        setIsInitializing(false);
      }
    };
    init();
  }, []);

  const handleSignIn = useCallback(async (): Promise<GoogleUser> => {
    const clientId = import.meta.env.VITE_GOOGLE_CLIENT_ID;
    if (!clientId) {
      options.onError?.('Google Client ID가 설정되지 않았습니다. .env 파일에 VITE_GOOGLE_CLIENT_ID를 추가해주세요.');
      throw new Error('Missing Google Client ID');
    }
    await googleDriveService.initialize(clientId);
    const user = await googleDriveService.signIn();
    setIsSignedIn(true);
    setGoogleUser(user);
    options.onSuccessMessage?.(`${user.email} 계정으로 로그인되었습니다.`);
    return user;
  }, [options]);

  const handleSignOut = useCallback(() => {
    googleDriveService.signOut();
    setIsSignedIn(false);
    setGoogleUser(null);
    options.onSuccessMessage?.('로그아웃되었습니다. Google Drive 로그인 후 다시 이용해주세요.');
  }, [options]);

  const loadFromGoogleDrive = useCallback(async (): Promise<LoadedData | null> => {
    const fileContent = await googleDriveService.loadFile();
    if (!fileContent) {
      options.onSuccessMessage?.('Google Drive에 저장된 포트폴리오가 없습니다. 자산을 추가해주세요.');
      return {
        assets: [],
        portfolioHistory: [],
        sellHistory: [],
        watchlist: [],
      };
    }
    const data = JSON.parse(fileContent);
    const assets = Array.isArray(data.assets) ? data.assets as Asset[] : [];
    const portfolioHistory = Array.isArray(data.portfolioHistory) ? data.portfolioHistory as PortfolioSnapshot[] : [];
    const sellHistory = Array.isArray(data.sellHistory) ? data.sellHistory as SellRecord[] : [];
    const watchlist = Array.isArray(data.watchlist) ? data.watchlist as WatchlistItem[] : [];
    const exchangeRates = data.exchangeRates as ExchangeRates | undefined;
    options.onSuccessMessage?.('Google Drive에서 포트폴리오를 불러왔습니다.');
    return { assets, portfolioHistory, sellHistory, watchlist, exchangeRates };
  }, [options]);

  const autoSave = useCallback(async (assetsToSave: Asset[], history: PortfolioSnapshot[], sells: SellRecord[], watchlist: WatchlistItem[], exchangeRates?: ExchangeRates) => {
    if (!isSignedIn) {
      options.onError?.('Google Drive 로그인 후 저장할 수 있습니다.');
      return;
    }
    if (timeoutIdRef.current) {
      clearTimeout(timeoutIdRef.current);
    }
    timeoutIdRef.current = setTimeout(async () => {
      if (isSavingRef.current) return;
      const exportData = {
        assets: assetsToSave,
        portfolioHistory: history,
        sellHistory: sells,
        watchlist,
        exchangeRates,
        lastUpdateDate: new Date().toISOString().slice(0, 10),
      };
      const portfolioJSON = JSON.stringify(exportData, null, 2);
      if (lastSavedDataRef.current === portfolioJSON) {
        return;
      }
      isSavingRef.current = true;
      try {
        options.onSuccessMessage?.('저장 중...');
        await googleDriveService.saveFile(portfolioJSON);
        lastSavedDataRef.current = portfolioJSON;
        options.onSuccessMessage?.('Google Drive에 자동 저장되었습니다.');
      } catch (error) {
        options.onError?.('자동 저장에 실패했습니다.');
      } finally {
        isSavingRef.current = false;
      }
    }, 2000);
  }, [isSignedIn, options]);

  return {
    isSignedIn,
    googleUser,
    isInitializing,
    handleSignIn,
    handleSignOut,
    loadFromGoogleDrive,
    autoSave,
  };
}
</file>

<file path="hooks/useOnClickOutside.ts">
import { useEffect } from 'react';

export function useOnClickOutside<T extends HTMLElement>(
  ref: React.RefObject<T>,
  handler: () => void,
  active: boolean = true
) {
  useEffect(() => {
    if (!active) return;
    const listener = (event: MouseEvent | TouchEvent) => {
      const el = ref.current;
      if (!el) return;
      const target = event.target as Node | null;
      if (target && el.contains(target)) return;
      handler();
    };
    document.addEventListener('mousedown', listener, true);
    document.addEventListener('touchstart', listener, true);
    return () => {
      document.removeEventListener('mousedown', listener, true);
      document.removeEventListener('touchstart', listener, true);
    };
  }, [ref, handler, active]);
}
</file>

<file path="index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    font-family: 'Noto Sans KR', sans-serif;
    color-scheme: dark;
  }

  body {
    @apply bg-gray-900 text-gray-200 min-h-screen;
    margin: 0;
  }

  #root {
    min-height: 100vh;
  }
}
</file>

<file path="index.tsx">
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="initialData.ts">
import { Asset, AssetCategory, Currency } from './types';

export const initialAssets: Asset[] = [
  {
    id: '1',
    category: AssetCategory.US_STOCK,
    ticker: 'AAPL',
    exchange: 'NASDAQ',
    name: 'Apple Inc.',
    quantity: 10,
    purchasePrice: 150,
    purchaseDate: '2023-01-15',
    currency: Currency.USD,
    purchaseExchangeRate: 1240.0,
    currentPrice: 295000,
    priceOriginal: 215.50,
    highestPrice: 300000,
  },
  {
    id: '2',
    category: AssetCategory.KOREAN_STOCK,
    ticker: '005930',
    exchange: 'KRX (코스피/코스닥)',
    name: '삼성전자',
    quantity: 20,
    purchasePrice: 70000,
    purchaseDate: '2023-03-22',
    currency: Currency.KRW,
    purchaseExchangeRate: 1,
    currentPrice: 78000,
    priceOriginal: 78000,
    highestPrice: 81000,
  },
  {
    id: '3',
    category: AssetCategory.CRYPTOCURRENCY,
    ticker: 'BTC',
    exchange: '주요 거래소 (종합)',
    name: '비트코인',
    quantity: 0.5,
    purchasePrice: 30000,
    purchaseDate: '2023-11-01',
    currency: Currency.USD,
    purchaseExchangeRate: 1350.0,
    currentPrice: 95000000,
    priceOriginal: 68000,
    highestPrice: 100000000,
  },
   {
    id: '4',
    category: AssetCategory.PHYSICAL_ASSET,
    ticker: 'KR7079120004',
    exchange: 'KRX 금시장',
    name: 'KRX 금현물',
    quantity: 10,
    purchasePrice: 85000,
    purchaseDate: '2024-01-10',
    currency: Currency.KRW,
    purchaseExchangeRate: 1,
    currentPrice: 110000,
    priceOriginal: 110000,
    highestPrice: 115000,
  },
];
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="tailwind.config.ts">
import type { Config } from 'tailwindcss';

const config: Config = {
  content: [
    './index.html',
    './index.tsx',
    './App.tsx',
    './components/**/*.{ts,tsx}',
    './pages/**/*.{ts,tsx}',
    './sections/**/*.{ts,tsx}',
  ],
  theme: {
    extend: {
      fontFamily: {
        sans: ['"Noto Sans KR"', 'sans-serif'],
      },
      colors: {
        'gray-900': '#121212',
        'gray-800': '#1E1E1E',
        'gray-700': '#2C2C2C',
        'gray-600': '#3A3A3A',
        'gray-400': '#9CA3AF',
        primary: {
          DEFAULT: '#6366F1',
          light: '#818CF8',
          dark: '#4F46E5',
        },
        success: '#10B981',
        danger: '#EF4444',
      },
    },
  },
  plugins: [],
};

export default config;
</file>

<file path=".github/workflows/deploy.yml">
name: Deploy to GitHub Pages

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      # [핵심 수정] 환경 변수를 파일(.env)로 직접 생성하여 빌드에 주입 (가장 확실한 방법)
      - name: Create .env file
        run: |
          echo "VITE_GEMINI_API_KEY=${{ secrets.VITE_GEMINI_API_KEY }}" >> .env
          echo "VITE_GOOGLE_CLIENT_ID=${{ secrets.VITE_GOOGLE_CLIENT_ID }}" >> .env

      - name: Build
        run: npm run build

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: './dist'

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
</file>

<file path="components/Header.tsx">
import React, { useEffect, useState } from 'react';

interface HeaderProps {
  onSave: () => void;
  onImport: () => void;
  onExport: () => void;
  onExportToCsv: () => void;
  onOpenBulkUploadModal: () => void;
  onOpenAddAssetModal: () => void;
  onSignIn?: () => void;
  onSignOut?: () => void;
  isSignedIn?: boolean;
  userEmail?: string | null;
}

const Header: React.FC<HeaderProps> = ({ 
  onSave, 
  onImport, 
  onExport, 
  onExportToCsv, 
  onOpenBulkUploadModal, 
  onOpenAddAssetModal,
  onSignIn,
  onSignOut,
  isSignedIn = false,
  userEmail,
}) => {
  const [showAdvancedMenu, setShowAdvancedMenu] = useState(false);

  useEffect(() => {
    if (!isSignedIn) {
      setShowAdvancedMenu(false);
    }
  }, [isSignedIn]);

  return (
    <header className="mb-8">
      <div className="flex justify-between items-start sm:items-center flex-col sm:flex-row">
        <div>
          <h1 className="text-4xl font-bold text-white tracking-tight" title="나의 자산 포트폴리오를 관리하는 대시보드입니다.">
            KIM'S 퀸트자산관리
          </h1>
          <p className="text-gray-400 mt-2" title="계량적 투자 전략을 기반으로 자산을 분석하고 추적합니다.">
            퀀트 투자를 위한 포트폴리오 대시보드
          </p>
        </div>
        <div className="flex items-center justify-end flex-wrap gap-2 mt-4 sm:mt-0">
          {isSignedIn ? (
            <div className="flex items-center gap-2">
              <span className="text-sm text-gray-400" title={`Google 계정으로 로그인됨: ${userEmail}`}>
                {userEmail}
              </span>
              <button
                onClick={onSignOut}
                className="bg-gray-700 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-md transition duration-300"
                title="Google 계정에서 로그아웃합니다."
              >
                로그아웃
              </button>
            </div>
          ) : (
            <button
              onClick={onSignIn}
              className="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition duration-300 flex items-center gap-2"
              title="Google 계정으로 로그인하여 Google Drive에 저장합니다."
            >
              <svg className="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/>
                <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/>
                <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/>
                <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/>
              </svg>
              로그인
            </button>
          )}
          {isSignedIn && (
            <>
              <button
                onClick={onOpenAddAssetModal}
                className="bg-primary hover:bg-primary-dark text-white font-bold py-2 px-4 rounded-md transition duration-300"
                title="새로운 자산을 포트폴리오에 추가합니다."
              >
                신규 자산 추가
              </button>
              <button
                onClick={onSave}
                className="bg-emerald-600 hover:bg-emerald-500 text-white font-semibold py-2 px-4 rounded-md transition duration-300"
                title="현재 포트폴리오를 Google Drive에 즉시 저장합니다."
              >
                즉시 저장
              </button>
              
              {/* 고급 기능 드롭다운 메뉴 */}
              <div className="relative">
                <button
                  onClick={() => setShowAdvancedMenu(!showAdvancedMenu)}
                  className="bg-gray-700 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-md transition duration-300 flex items-center gap-1"
                  title="백업 및 일괄 등록 기능 메뉴"
                >
                  고급 기능
                  <svg className={`w-4 h-4 transition-transform ${showAdvancedMenu ? 'rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                  </svg>
                </button>
                
                {showAdvancedMenu && (
                  <div className="absolute right-0 mt-2 w-64 bg-gray-800 border border-gray-600 rounded-md shadow-lg z-50">
                    <div className="p-2">
                      <p className="text-xs text-gray-400 mb-2 px-2">
                        Google Drive에 저장된 데이터를 손쉽게 백업하거나 일괄 등록할 수 있습니다.
                      </p>
                      <div className="space-y-1">
                        <button
                          onClick={() => {
                            onOpenBulkUploadModal();
                            setShowAdvancedMenu(false);
                          }}
                          className="w-full text-left px-3 py-2 text-sm text-gray-300 hover:bg-gray-700 rounded transition"
                          title="CSV 파일로 여러 자산을 한 번에 등록합니다."
                        >
                          <div className="font-medium">일괄 등록</div>
                          <div className="text-xs text-gray-500">CSV 파일로 여러 자산을 한 번에 등록</div>
                        </button>
                        <button
                          onClick={() => {
                            onImport();
                            setShowAdvancedMenu(false);
                          }}
                          className="w-full text-left px-3 py-2 text-sm text-gray-300 hover:bg-gray-700 rounded transition"
                          title="JSON 파일에서 포트폴리오를 불러옵니다. (현재 데이터 덮어쓰기)"
                        >
                          <div className="font-medium">가져오기</div>
                          <div className="text-xs text-gray-500">JSON 파일에서 포트폴리오 불러오기</div>
                        </button>
                        <button
                          onClick={() => {
                            onExport();
                            setShowAdvancedMenu(false);
                          }}
                          className="w-full text-left px-3 py-2 text-sm text-gray-300 hover:bg-gray-700 rounded transition"
                          title="현재 포트폴리오를 JSON 파일로 백업합니다."
                        >
                          <div className="font-medium">내보내기</div>
                          <div className="text-xs text-gray-500">현재 포트폴리오를 JSON 파일로 백업</div>
                        </button>
                    <button
                      onClick={() => {
                        onSave();
                        setShowAdvancedMenu(false);
                      }}
                      className="w-full text-left px-3 py-2 text-sm text-gray-300 hover:bg-gray-700 rounded transition"
                      title="현재 데이터를 Google Drive에 즉시 저장합니다."
                    >
                      <div className="font-medium">Google Drive 저장</div>
                      <div className="text-xs text-gray-500">자동 저장 대기 없이 즉시 저장</div>
                    </button>
                        <button
                          onClick={() => {
                            onExportToCsv();
                            setShowAdvancedMenu(false);
                          }}
                          className="w-full text-left px-3 py-2 text-sm text-gray-300 hover:bg-gray-700 rounded transition"
                          title="현재 포트폴리오를 CSV 파일로 내보냅니다."
                        >
                          <div className="font-medium">CSV로 내보내기</div>
                          <div className="text-xs text-gray-500">현재 포트폴리오를 CSV 파일로 내보내기</div>
                        </button>
                      </div>
                    </div>
                  </div>
                )}
              </div>
              
              {/* 메뉴 외부 클릭 시 닫기 */}
              {showAdvancedMenu && (
                <div 
                  className="fixed inset-0 z-40" 
                  onClick={() => setShowAdvancedMenu(false)}
                />
              )}
            </>
          )}
        </div>
      </div>
    </header>
  );
};

export default Header;
</file>

<file path="components/PortfolioAssistant.tsx">
import React, { useState, useRef, useEffect, useMemo } from 'react';
import { Asset } from '../types';
import { askPortfolioQuestion } from '../services/geminiService';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import rehypeRaw from 'rehype-raw';


interface PortfolioAssistantProps {
  isOpen: boolean;
  onClose: () => void;
  assets: Asset[];
}

interface Message {
    role: 'user' | 'model';
    content: string;
}

const ASSISTANT_HISTORY_KEY = 'quant-assistant-history';

const PortfolioAssistant: React.FC<PortfolioAssistantProps> = ({ isOpen, onClose, assets }) => {
    const [messages, setMessages] = useState<Message[]>(() => {
        try {
            const savedHistory = localStorage.getItem(ASSISTANT_HISTORY_KEY);
            return savedHistory ? JSON.parse(savedHistory) : [];
        } catch (error) {
            console.error("Failed to load assistant history:", error);
            return [];
        }
    });

    const [input, setInput] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const messagesEndRef = useRef<HTMLDivElement>(null);
    const inputRef = useRef<HTMLInputElement>(null);

    const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    };

    useEffect(scrollToBottom, [messages, isLoading]);
    
    useEffect(() => {
      if (isOpen) {
        setTimeout(() => inputRef.current?.focus(), 100);
      }
    }, [isOpen]);

    useEffect(() => {
        try {
            localStorage.setItem(ASSISTANT_HISTORY_KEY, JSON.stringify(messages));
        } catch (error) {
            console.error("Failed to save assistant history:", error);
        }
    }, [messages]);


    const handleSend = async () => {
        if (!input.trim() || isLoading) return;

        const userMessage: Message = { role: 'user', content: input };
        setMessages(prev => [...prev, userMessage]);
        setInput('');
        setIsLoading(true);

        try {
            const modelResponse = await askPortfolioQuestion(assets, input);
            const assistantMessage: Message = { role: 'model', content: modelResponse };
            setMessages(prev => [...prev, assistantMessage]);
        } catch (error) {
            console.error("Error asking portfolio question:", error);
            const errorMessage: Message = { role: 'model', content: "죄송합니다, 답변을 생성하는 중에 오류가 발생했습니다. 잠시 후 다시 시도해주세요." };
            setMessages(prev => [...prev, errorMessage]);
        } finally {
            setIsLoading(false);
        }
    };
    
    const examplePrompts = [
        "레이달리오의 사계절 포트폴리오 전략에 따라 내 자산 분배를 분석해줘.",
        "보유 종목 중 원자재 관련 주식이 있어?",
        "가장 수익률이 높은 자산은 뭐야?",
        "내 포트폴리오의 전반적인 위험도를 평가해줘."
    ];
    
    const handleExampleClick = (prompt: string) => {
        setInput(prompt);
        inputRef.current?.focus();
    };

    const handleClearHistory = () => {
        if (window.confirm('대화 기록을 정말 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) {
            setMessages([]);
            localStorage.removeItem(ASSISTANT_HISTORY_KEY);
        }
    };

    // 자산 데이터 캐싱 (속도 개선)
    const assetsSnapshot = useMemo(() => {
        return JSON.stringify(assets.map(asset => ({
            name: asset.customName ?? asset.name,
            category: asset.category,
            quantity: asset.quantity,
            purchase_price_original: asset.purchasePrice,
            current_price_krw: asset.currentPrice,
            currency: asset.currency,
            current_value_krw: asset.currentPrice * asset.quantity,
        })));
    }, [assets]);

    const markdownComponents = {
        table: ({node, ...props}: any) => <table className="table-auto w-full my-4 text-sm border-collapse border border-gray-600" {...props} />,
        thead: ({node, ...props}: any) => <thead className="bg-gray-700/50" {...props} />,
        th: ({node, ...props}: any) => <th className="border border-gray-600 px-3 py-2 text-left font-semibold text-gray-200" {...props} />,
        td: ({node, ...props}: any) => <td className="border border-gray-600 px-3 py-2" {...props} />,
        p: ({node, ...props}: any) => <p className="mb-2 last:mb-0" {...props} />,
        ul: ({node, ...props}: any) => <ul className="list-disc list-inside mb-2 pl-4" {...props} />,
        ol: ({node, ...props}: any) => <ol className="list-decimal list-inside mb-2 pl-4" {...props} />,
        li: ({node, ...props}: any) => <li className="mb-1" {...props} />,
        h3: ({node, ...props}: any) => <h3 className="text-lg font-bold mt-4 mb-2 text-primary-light" {...props} />,
        strong: ({node, ...props}: any) => <strong className="font-bold text-white" {...props} />,
        code: ({node, inline, ...props}: any) => inline
          ? <code className="bg-gray-900 text-yellow-300 px-1.5 py-1 rounded text-sm font-mono" {...props} />
          : <pre className="bg-gray-900 p-3 rounded-md overflow-x-auto my-2 text-sm"><code className="font-mono" {...props} /></pre>,
        img: ({node, ...props}: any) => (
            <img 
                {...props} 
                className="max-w-full rounded my-2" 
                loading="lazy"
                alt={props.alt || '이미지'}
                onError={(e: any) => {
                    e.target.style.display = 'none';
                }}
            />
        )
    };

    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-50" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl w-full max-w-2xl h-[80vh] flex flex-col" onClick={(e) => e.stopPropagation()}>
                <header className="flex justify-between items-center p-4 border-b border-gray-700">
                    <div className="flex items-center gap-3">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-primary" viewBox="0 0 24 24" fill="currentColor">
                           <path d="M14 12c0 .552-.448 1-1 1s-1-.448-1-1 .448-1 1-1 1 .448 1 1zm-1-3.5c-2.481 0-4.5 2.019-4.5 4.5s2.019 4.5 4.5 4.5 4.5-2.019 4.5-4.5-2.019-4.5-4.5-4.5zm0-3.5c-4.411 0-8 3.589-8 8s3.589 8 8 8 8-3.589 8-8-3.589-8-8-8zm-5.5 8c0-3.033 2.468-5.5 5.5-5.5s5.5 2.467 5.5 5.5-2.468 5.5-5.5 5.5-5.5-2.467-5.5-5.5zm11.5 0c0 .828-.672 1.5-1.5 1.5s-1.5-.672-1.5-1.5.672-1.5 1.5-1.5 1.5.672 1.5 1.5z"/>
                        </svg>
                        <h2 className="text-xl font-bold text-white">포트폴리오 어시스턴트</h2>
                    </div>
                    <div className="flex items-center gap-2">
                        <button onClick={handleClearHistory} title="대화 기록 초기화" className="text-gray-400 hover:text-white transition p-2">
                           <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                              <path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                        </button>
                        <button onClick={onClose} title="닫기" className="text-gray-400 hover:text-white transition p-2">
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                    </div>
                </header>
                <main className="flex-1 p-4 overflow-y-auto space-y-4">
                    {messages.length === 0 && !isLoading ? (
                        <div className="text-center p-8">
                             <h3 className="text-lg font-semibold text-white mb-4">무엇을 도와드릴까요?</h3>
                             <p className="text-gray-400 mb-6">포트폴리오에 대해 궁금한 점을 질문해보세요.</p>
                             <div className="grid grid-cols-1 md:grid-cols-2 gap-3 text-left">
                                {examplePrompts.map(prompt => (
                                    <button 
                                        key={prompt}
                                        onClick={() => handleExampleClick(prompt)}
                                        className="bg-gray-700 hover:bg-gray-600 text-gray-300 p-3 rounded-lg text-sm transition text-left"
                                    >
                                        {prompt}
                                    </button>
                                ))}
                             </div>
                        </div>
                    ) : (
                        messages.map((msg, index) => (
                            <div key={index} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                                <div className={`max-w-xl lg:max-w-2xl px-4 py-3 rounded-lg ${msg.role === 'user' ? 'bg-primary text-white' : 'bg-gray-700 text-gray-200'}`}>
                                     {msg.role === 'model' ? (
                                        <ReactMarkdown 
                                            remarkPlugins={[remarkGfm]} 
                                            rehypePlugins={[rehypeRaw]}
                                            components={markdownComponents}
                                        >
                                            {msg.content}
                                        </ReactMarkdown>
                                    ) : (
                                        <p className="whitespace-pre-wrap">{msg.content}</p>
                                    )}
                                </div>
                            </div>
                        ))
                    )}
                     {isLoading && (
                        <div className="flex justify-start">
                            <div className="bg-gray-700 text-gray-200 px-4 py-3 rounded-lg">
                                <div className="flex items-center space-x-2">
                                    <span className="w-2 h-2 bg-gray-400 rounded-full animate-pulse [animation-delay:-0.3s]"></span>
                                    <span className="w-2 h-2 bg-gray-400 rounded-full animate-pulse [animation-delay:-0.15s]"></span>
                                    <span className="w-2 h-2 bg-gray-400 rounded-full animate-pulse"></span>
                                </div>
                            </div>
                        </div>
                    )}
                    <div ref={messagesEndRef} />
                </main>
                <footer className="p-4 border-t border-gray-700">
                    <div className="flex items-center bg-gray-700 rounded-lg">
                        <input
                            ref={inputRef}
                            type="text"
                            value={input}
                            onChange={(e) => setInput(e.target.value)}
                            onKeyDown={(e) => e.key === 'Enter' && handleSend()}
                            placeholder="포트폴리오에 대해 질문하세요..."
                            className="w-full bg-transparent p-3 text-white placeholder-gray-400 focus:outline-none"
                            disabled={isLoading}
                        />
                        <button onClick={handleSend} disabled={isLoading || !input.trim()} className="p-3 text-gray-400 hover:text-white disabled:text-gray-600 disabled:cursor-not-allowed transition">
                           <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 10l7-7m0 0l7 7m-7-7v18" transform="rotate(90 12 12)" />
                            </svg>
                        </button>
                    </div>
                </footer>
            </div>
        </div>
    );
};

export default PortfolioAssistant;
</file>

<file path="components/ProfitLossChart.tsx">
import React, { useMemo } from 'react';
import { Asset, PortfolioSnapshot } from '../types';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';

interface ProfitLossChartProps {
  history: PortfolioSnapshot[];
  assetsToDisplay: Asset[];
  title: string;
}

const ProfitLossChart: React.FC<ProfitLossChartProps> = ({ history, assetsToDisplay, title }) => {
  const chartData = useMemo(() => {
    if (!history || history.length === 0) {
      return [];
    }
    
    const assetIdsToDisplay = new Set(assetsToDisplay.map(a => a.id));

    const data = history.map(snapshot => {
      const dateEntry: { [key: string]: any } = {
        date: new Date(snapshot.date).toLocaleDateString('ko-KR', { month: '2-digit', day: '2-digit' }),
      };
      
      const relevantAssets = snapshot.assets.filter(asset => assetIdsToDisplay.has(asset.id));

      let totalPurchase = 0;
      let totalCurrent = 0;
      relevantAssets.forEach(asset => {
        totalPurchase += asset.purchaseValue;
        totalCurrent += asset.currentValue;
      });
      const totalProfitLoss = totalCurrent - totalPurchase;
      const totalReturn = totalPurchase === 0 ? 0 : (totalProfitLoss / totalPurchase) * 100;
      dateEntry['투자 원금'] = totalPurchase;
      dateEntry['총 평가액'] = totalCurrent;
      dateEntry['손익'] = totalProfitLoss;
      dateEntry['수익률'] = totalReturn;
      return dateEntry;
    });

    return data;
  }, [history, assetsToDisplay]);

  const formatCurrency = (value: number) => {
    return value.toLocaleString('ko-KR', { maximumFractionDigits: 0 });
  };
  const formatPercent = (value: number) => `${(Number(value) || 0).toFixed(2)}%`;
  
  const CustomTooltip = ({ active, payload, label }: any) => {
    if (!active || !payload || payload.length === 0) return null;
    const datum = payload.reduce((acc: any, p: any) => {
      if (p && p.dataKey) acc[p.dataKey] = p.value;
      return acc;
    }, {});
    const principal = datum['투자 원금'];
    const total = datum['총 평가액'];
    const returnPct = datum['수익률'];
    return (
      <div style={{ backgroundColor: '#2D3748', border: '1px solid #4A5568', borderRadius: '0.5rem', padding: '0.5rem 0.75rem' }}>
        <div style={{ color: '#E2E8F0', marginBottom: 4 }}>{label}</div>
        <div style={{ color: '#A0AEC0' }}>투자 원금: <span style={{ color: '#E2E8F0', fontWeight: 700 }}>{formatCurrency(principal)} 원</span></div>
        <div style={{ color: '#A0AEC0' }}>총 평가액: <span style={{ color: '#E2E8F0', fontWeight: 700 }}>{formatCurrency(total)} 원</span></div>
        <div style={{ color: '#A0AEC0' }}>총 수익률 (합산 평균): <span style={{ color: '#E2E8F0', fontWeight: 700 }}>{formatPercent(returnPct)}</span></div>
      </div>
    );
  };
  
  return (
    <div className="bg-gray-800 p-6 rounded-lg shadow-lg h-96 mb-6" title="포트폴리오의 평가 손익 추이를 보여줍니다.">
      <h2 className="text-xl font-bold text-white mb-4">{title}</h2>
      {chartData.length > 1 ? (
        <ResponsiveContainer width="100%" height="90%">
          <LineChart data={chartData} margin={{ top: 5, right: 20, left: 20, bottom: 5 }}>
            <CartesianGrid strokeDasharray="3 3" stroke="#4A5568" />
            <XAxis dataKey="date" stroke="#A0AEC0" fontSize={12} />
            <YAxis stroke="#A0AEC0" fontSize={12} tickFormatter={formatCurrency} width={80} />
            <Tooltip content={<CustomTooltip />} />
            <Legend wrapperStyle={{fontSize: "12px", bottom: -10}}/>
            <Line type="monotone" dataKey="투자 원금" name="투자 원금" stroke="#63B3ED" strokeWidth={3} dot={false} />
            <Line type="monotone" dataKey="총 평가액" name="총 평가액" stroke="#48BB78" strokeWidth={3} dot={false} />
            <Line type="monotone" dataKey="손익" name="손익" stroke="#FFFFFF" strokeWidth={2} dot={{ r: 3 }} activeDot={{ r: 6 }} />
          </LineChart>
        </ResponsiveContainer>
      ) : (
        <div className="flex items-center justify-center h-full">
          <p className="text-gray-500">손익 추이를 표시하려면 데이터가 2일 이상 필요합니다.</p>
        </div>
      )}
    </div>
  );
};

export default ProfitLossChart;
</file>

<file path="components/SellAnalyticsPage.tsx">
import React, { useEffect, useMemo, useState } from 'react';
import { Asset, Currency, SellRecord, AssetCategory, ALLOWED_CATEGORIES } from '../types';
import StatCard from './StatCard';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, BarChart, Bar } from 'recharts';

interface SellAnalyticsPageProps {
  assets: Asset[];
  sellHistory: SellRecord[];
}

type Grouping = 'daily' | 'weekly' | 'monthly' | 'quarterly';

const SellAnalyticsPage: React.FC<SellAnalyticsPageProps> = ({ assets, sellHistory }) => {
  const [grouping, setGrouping] = useState<Grouping>('monthly');
  const [startDate, setStartDate] = useState<string>('');
  const [endDate, setEndDate] = useState<string>('');
  const [search, setSearch] = useState<string>('');
  const [category, setCategory] = useState<AssetCategory | 'ALL'>('ALL');

  const [pendingStartDate, setPendingStartDate] = useState<string>('');
  const [pendingEndDate, setPendingEndDate] = useState<string>('');
  const [pendingSearch, setPendingSearch] = useState<string>('');
  const [pendingCategory, setPendingCategory] = useState<AssetCategory | 'ALL'>('ALL');

  useEffect(() => {
    const today = new Date();
    const lastYear = new Date();
    lastYear.setFullYear(today.getFullYear() - 1);
    const fmt = (d: Date) => `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
    const s = fmt(lastYear);
    const e = fmt(today);
    setStartDate(s);
    setEndDate(e);
    setPendingStartDate(s);
    setPendingEndDate(e);
  }, []);

  const allSellRecords: SellRecord[] = useMemo(() => {
    const inlineRecords: SellRecord[] = [];
    assets.forEach(a => {
      if (a.sellTransactions && a.sellTransactions.length > 0) {
        a.sellTransactions.forEach(t => {
          inlineRecords.push({
            assetId: a.id,
            ticker: a.ticker,
            name: a.name,
            category: a.category,
            ...t,
          });
        });
      }
    });
    return [...sellHistory, ...inlineRecords];
  }, [assets, sellHistory]);

  const filteredRecords = useMemo(() => {
    return allSellRecords.filter(r => {
      const d = r.sellDate;
      const inStart = !startDate || d >= startDate;
      const inEnd = !endDate || d <= endDate;
      const inSearch = !search || r.name.toLowerCase().includes(search.toLowerCase()) || r.ticker.toLowerCase().includes(search.toLowerCase());
      const inCategory = category === 'ALL' || r.category === category;
      return inStart && inEnd && inSearch && inCategory;
    });
  }, [allSellRecords, startDate, endDate, search, category]);

  const toKRWPurchaseUnit = (a: Asset, quantity: number): number => {
    if (a.currency === Currency.KRW) return a.purchasePrice * quantity;
    if (a.purchaseExchangeRate) return a.purchasePrice * a.purchaseExchangeRate * quantity;
    if (a.priceOriginal > 0) {
      const ex = a.currentPrice / a.priceOriginal;
      return a.purchasePrice * ex * quantity;
    }
    return a.purchasePrice * quantity;
  };

  const recordWithCalc = useMemo(() => {
    const assetMap = new Map(assets.map(a => [a.id, a]));
    return filteredRecords.map(r => {
      const a = assetMap.get(r.assetId);
      const purchaseKRW = a ? toKRWPurchaseUnit(a, r.sellQuantity) : 0;
      const realized = r.sellPrice * r.sellQuantity - purchaseKRW;
      const returnPct = purchaseKRW === 0 ? 0 : (realized / purchaseKRW) * 100;
      return { ...r, purchaseKRW, realized, returnPct };
    });
  }, [filteredRecords, assets]);

  const overview = useMemo(() => {
    const totalSoldAmount = recordWithCalc.reduce((s, r) => s + r.sellPrice * r.sellQuantity, 0);
    const totalPurchase = recordWithCalc.reduce((s, r) => s + r.purchaseKRW, 0);
    const totalProfit = totalSoldAmount - totalPurchase;
    const totalReturn = totalPurchase === 0 ? 0 : (totalProfit / totalPurchase) * 100;
    const soldCount = recordWithCalc.length;
    return { totalSoldAmount, totalPurchase, totalProfit, totalReturn, soldCount };
  }, [recordWithCalc]);

  const groupKey = (dateStr: string): string => {
    const d = new Date(dateStr);
    const y = d.getFullYear();
    const m = d.getMonth() + 1;
    const q = Math.floor((m - 1) / 3) + 1;
    if (grouping === 'daily') return d.toLocaleDateString('ko-KR', { month: '2-digit', day: '2-digit' });
    if (grouping === 'weekly') {
      const first = new Date(d);
      const day = first.getDay();
      const diff = first.getDate() - day + (day === 0 ? -6 : 1);
      const monday = new Date(first.setDate(diff));
      return `${monday.getFullYear()}-${String(monday.getMonth() + 1).padStart(2, '0')}-${String(monday.getDate()).padStart(2, '0')}`;
    }
    if (grouping === 'monthly') return `${y}-${String(m).padStart(2, '0')}`;
    return `${y}-Q${q}`;
  };

  const trendData = useMemo(() => {
    const map = new Map<string, { period: string; realized: number }>();
    recordWithCalc.forEach(r => {
      const k = groupKey(r.sellDate);
      const prev = map.get(k) || { period: k, realized: 0 };
      prev.realized += r.realized;
      map.set(k, prev);
    });
    return Array.from(map.values()).sort((a, b) => a.period.localeCompare(b.period));
  }, [recordWithCalc, grouping]);

  const rankingData = useMemo(() => {
    const map = new Map<string, { name: string; realized: number; returnPct: number; count: number }>();
    recordWithCalc.forEach(r => {
      const prev = map.get(r.ticker) || { name: r.name, realized: 0, returnPct: 0, count: 0 };
      prev.realized += r.realized;
      prev.returnPct += r.returnPct;
      prev.count += 1;
      map.set(r.ticker, prev);
    });
    const arr = Array.from(map.entries()).map(([ticker, v]) => ({ ticker, name: v.name, realized: v.realized, avgReturn: v.count ? v.returnPct / v.count : 0 }));
    arr.sort((a, b) => b.avgReturn - a.avgReturn);
    return arr.slice(0, 10);
  }, [recordWithCalc]);

  const histogramData = useMemo(() => {
    if (recordWithCalc.length === 0) return [];
    const values = recordWithCalc.map(r => r.realized);
    const min = Math.min(...values);
    const max = Math.max(...values);
    const bins = 10;
    const width = (max - min) / bins || 1;
    const buckets = Array.from({ length: bins }, (_, i) => ({ bucket: `${Math.round(min + i * width)}`, count: 0 }));
    values.forEach(v => {
      let idx = Math.floor((v - min) / width);
      if (idx < 0) idx = 0;
      if (idx >= bins) idx = bins - 1;
      buckets[idx].count += 1;
    });
    return buckets;
  }, [recordWithCalc]);

  const formatKRW = (num: number) => new Intl.NumberFormat('ko-KR', { style: 'currency', currency: 'KRW', maximumFractionDigits: 0 }).format(num);

  return (
    <div className="space-y-6">
      <div className="bg-gray-800 p-4 rounded-lg shadow-lg flex items-center justify-between flex-wrap gap-4">
        <div className="flex items-center gap-4 flex-wrap">
          <div className="flex items-center gap-2">
            <label className="text-sm font-medium text-gray-300">기간:</label>
            <input type="date" value={pendingStartDate} onChange={e => setPendingStartDate(e.target.value)} className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary" />
            <span className="text-gray-400">~</span>
            <input type="date" value={pendingEndDate} onChange={e => setPendingEndDate(e.target.value)} className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary" />
          </div>
          <div className="relative">
            <select value={grouping} onChange={e => setGrouping(e.target.value as Grouping)} className="bg-gray-700 border border-gray-600 rounded-md py-2 pl-3 pr-8 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary appearance-none">
              <option value="daily">일별</option>
              <option value="weekly">주별</option>
              <option value="monthly">월별</option>
              <option value="quarterly">분기별</option>
            </select>
            <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-400">
              <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
            </div>
          </div>
          <div className="relative">
            <select value={pendingCategory} onChange={e => setPendingCategory(e.target.value as AssetCategory | 'ALL')} className="bg-gray-700 border border-gray-600 rounded-md py-2 pl-3 pr-8 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary appearance-none">
              <option value="ALL">전체 카테고리</option>
              {ALLOWED_CATEGORIES.map(cat => (
                <option key={cat} value={cat}>{cat}</option>
              ))}
            </select>
            <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-400">
              <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
            </div>
          </div>
          <div className="relative">
            <input type="text" value={pendingSearch} onChange={e => setPendingSearch(e.target.value)} placeholder="종목명/티커 검색" className="bg-gray-700 border border-gray-600 rounded-md py-2 pl-10 pr-10 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary w-64" />
            <svg className="absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
          </div>
        </div>
        <div>
          <button
            onClick={() => {
              setStartDate(pendingStartDate);
              setEndDate(pendingEndDate);
              setSearch(pendingSearch);
              setCategory(pendingCategory);
            }}
            className="bg-primary hover:bg-primary-dark text-white font-medium py-2 px-4 rounded-md transition duration-300 mr-2"
            title="선택된 조건으로 데이터를 조회합니다."
          >
            검색
          </button>
          <button
            onClick={() => {
              const header = ['sellDate','name','ticker','sellQuantity','sellPriceKRW','purchaseKRW','realized','returnPct'];
              const rows = recordWithCalc.map(r => [r.sellDate, r.name, r.ticker, r.sellQuantity, Math.round(r.sellPrice * r.sellQuantity), Math.round(r.purchaseKRW), Math.round(r.realized), r.returnPct.toFixed(2)]);
              const csv = [header.join(','), ...rows.map(row => row.join(','))].join('\n');
              const blob = new Blob([`\uFEFF${csv}`], { type: 'text/csv;charset=utf-8;' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = 'sell_analytics.csv';
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            }}
            className="bg-primary hover:bg-primary-dark text-white font-medium py-2 px-4 rounded-md transition duration-300"
            title="현재 필터 기준의 매도 통계 데이터를 CSV로 내보냅니다."
          >
            CSV 내보내기
          </button>
        </div>
      </div>

      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6 mb-6">
        <StatCard title="총 매도금액" value={formatKRW(overview.totalSoldAmount)} tooltip="선택된 필터에 해당하는 매도 합계" />
        <StatCard title="매도 수익" value={formatKRW(overview.totalProfit)} isProfit={overview.totalProfit >= 0} tooltip="매도금액 - 매수원가" />
        <StatCard title="매도 수익률" value={`${overview.totalReturn.toFixed(2)}%`} isProfit={overview.totalReturn >= 0} tooltip="수익/매수원가" />
        <StatCard title="매도 횟수" value={String(overview.soldCount)} tooltip="거래 수" />
      </div>

      <div className="bg-gray-800 p-6 rounded-lg shadow-lg h-96">
        <h3 className="text-xl font-bold text-white mb-4">기간별 수익 추이</h3>
        {trendData.length > 0 ? (
          <ResponsiveContainer width="100%" height="85%">
            <LineChart data={trendData} margin={{ top: 5, right: 20, left: 20, bottom: 5 }}>
              <CartesianGrid strokeDasharray="3 3" stroke="#4A5568" />
              <XAxis dataKey="period" stroke="#A0AEC0" fontSize={12} />
              <YAxis stroke="#A0AEC0" fontSize={12} tickFormatter={(v: number) => v.toLocaleString('ko-KR')} width={80} />
              <Tooltip formatter={(v: number) => [`${formatKRW(v)}`, '실현손익']} contentStyle={{ backgroundColor: '#2D3748', border: '1px solid #4A5568', borderRadius: '0.5rem' }} labelStyle={{ color: '#E2E8F0' }} />
              <Legend wrapperStyle={{ fontSize: '12px', bottom: -10 }} />
              <Line type="monotone" dataKey="realized" name="실현손익" stroke="#FFFFFF" strokeWidth={3} dot={{ r: 4 }} activeDot={{ r: 8 }} />
            </LineChart>
          </ResponsiveContainer>
        ) : (
          <div className="flex items-center justify-center h-full">
            <p className="text-gray-500">표시할 데이터가 없습니다.</p>
          </div>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <div className="bg-gray-800 p-6 rounded-lg shadow-lg">
          <h3 className="text-xl font-bold text-white mb-4">종목별 수익률 순위(상위 10)</h3>
          {rankingData.length > 0 ? (
            <ResponsiveContainer width="100%" height={300}>
              <BarChart data={rankingData} layout="vertical" margin={{ left: 40, right: 20 }}>
                <CartesianGrid strokeDasharray="3 3" stroke="#4A5568" />
                <XAxis type="number" stroke="#A0AEC0" fontSize={12} tickFormatter={(v: number) => `${v.toFixed(1)}%`} />
                <YAxis type="category" dataKey="name" stroke="#A0AEC0" fontSize={12} width={160} />
                <Tooltip formatter={(v: number) => [`${(v as number).toFixed(2)}%`, '평균 수익률']} contentStyle={{ backgroundColor: '#2D3748', border: '1px solid #4A5568', borderRadius: '0.5rem' }} />
                <Bar dataKey="avgReturn" name="평균 수익률" fill="#60A5FA" />
              </BarChart>
            </ResponsiveContainer>
          ) : (
            <p className="text-gray-500">표시할 데이터가 없습니다.</p>
          )}
        </div>

        <div className="bg-gray-800 p-6 rounded-lg shadow-lg">
          <h3 className="text-xl font-bold text-white mb-4">손익 분포(히스토그램)</h3>
          {histogramData.length > 0 ? (
            <ResponsiveContainer width="100%" height={300}>
              <BarChart data={histogramData}>
                <CartesianGrid strokeDasharray="3 3" stroke="#4A5568" />
                <XAxis dataKey="bucket" stroke="#A0AEC0" fontSize={12} tickFormatter={(v: string) => new Intl.NumberFormat('ko-KR').format(Number(v))} />
                <YAxis stroke="#A0AEC0" fontSize={12} />
                <Tooltip contentStyle={{ backgroundColor: '#2D3748', border: '1px solid #4A5568', borderRadius: '0.5rem' }} labelFormatter={(v) => `${v} KRW`} />
                <Bar dataKey="count" name="거래 수" fill="#34D399" />
              </BarChart>
            </ResponsiveContainer>
          ) : (
            <p className="text-gray-500">표시할 데이터가 없습니다.</p>
          )}
        </div>
      </div>
    </div>
  );
};

export default SellAnalyticsPage;
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KIM'S 퀸트자산관리</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
</head>
  <body class="bg-gray-900 text-gray-200">
    <div id="root"></div>
  <script type="module" src="/index.tsx"></script>
</body>
</html>
</file>

<file path="public/metadata.json">
{
  "commit": "DEV-LOCAL",
  "buildTime": "2025-11-27T00:00:00Z"
}
</file>

<file path="README.md">
<div align="center">

# 자산-관리-시트

React + TypeScript + Vite 기반의 주식/코인 포트폴리오 관리 앱입니다. Google Drive에 데이터를 저장/로드하며, 실제 금융 API를 통해 가격 데이터를 가져옵니다.

</div>

## 개요
- Google Drive 연동으로 포트폴리오를 안전하게 저장/동기화
- 주식 가격은 Google Cloud Run API, 암호화폐 가격은 Upbit API로부터 수집
- 원화 환산과 분류/검색/정렬/차트 등 다양한 UI/UX 기능 제공

## 주요 기능
- Google 로그인 및 자동 저장/불러오기
- 배치 시세 조회(주식/코인), 실패 시 안전한 폴백 처리
- 포트폴리오 테이블 정렬 고도화: 수익률(%) ↓ → 수익률(%) ↑ → 평가손익(₩) ↓ → 평가손익(₩) ↑ → 해제
- 대시보드 차트 개선: 투자 원금/총 평가액/손익/수익률 표시
- 관심종목(Watchlist) 관리 및 일괄 업데이트
- CSV 내보내기/불러오기, 대량 업로드

## 폴더 구조
- `components/` UI 컴포넌트
  - `PortfolioTable.tsx` 포트폴리오 목록/정렬/필터/업데이트
  - `ProfitLossChart.tsx` 투자 원금/총 평가액/손익 라인 차트
  - 기타 대시보드/모달/차트/요약 컴포넌트
- `hooks/`
  - `useGoogleDriveSync.ts` Google Drive 인증/로드/자동 저장을 캡슐화한 커스텀 훅
- `services/`
  - `priceService.ts` 가격/환율 데이터 소스(Cloud Run/Upbit)
  - `geminiService.ts` 검색/챗 등 AI 보조 기능
- `types.ts` 도메인 타입 정의(Asset, Currency, ExchangeRates 등)
- `utils/` 마이그레이션 및 유틸
- `App.tsx` 앱 엔트리/상태 관리/페이지 구성

## 설치
- 요구사항: Node.js 18+, npm
```bash
npm install
npm run dev
```

## 환경 설정
루트에 `.env.local` 파일을 추가하세요.
```ini
# Google 로그인
VITE_GOOGLE_CLIENT_ID=your-google-oauth-client-id

# 선택: 환율 조회(폴백)용 Gemini 키
VITE_GEMINI_API_KEY=your-gemini-api-key
```

## 데이터 소스
- 주식(Stocks): Google Cloud Run
  - 엔드포인트: `https://asset-manager-887842923289.asia-northeast3.run.app`
  - 서버 코드: `main.py` 기반이며, 모든 응답에 CORS 헤더를 포함하도록 수정됨
  - 요청: `POST` JSON 본문 예시
    ```json
    {
      "tickers": [
        { "ticker": "AAPL", "exchange": "NASDAQ" },
        { "ticker": "005930", "exchange": "KRX (코스피/코스닥)" }
      ]
    }
    ```
  - 응답이 없거나, 본문 없이 호출하면 `{"error": "No tickers provided"}`가 반환됩니다. 반드시 `tickers` 배열을 포함해야 합니다.
- 암호화폐(Crypto): Upbit
  - 엔드포인트: `GET https://api.upbit.com/v1/ticker?markets=KRW-<TICKER1>,KRW-<TICKER2>,...`
  - 예: `KRW-BTC`, `KRW-ETH` 등
  - 사용 필드: `trade_price`, `prev_closing_price`
- 조회 분기 로직
  - 사용자의 ‘자산 구분(Category)’ 설정과 무관하게, 입력된 ‘거래소(Exchange)’ 문자열을 파싱하여 API를 자동 분기합니다.
  - `exchange`에 `Upbit/Bithumb/Coin/주요 거래소`가 포함되면 Upbit, 그 외(`NASDAQ/KRX/NYSE/Foreign`)는 Cloud Run(FinanceDataReader)로 전송됩니다.

### 환율(Exchange Rate)
- 정확한 환율은 Cloud Run에서 조회합니다.
  - USD/KRW: `priceService.fetchExchangeRate()` → `ticker: "USD/KRW"`
  - JPY/KRW: `priceService.fetchExchangeRateJPY()` → `ticker: "JPY/KRW"`
- 앱 초기화 및 현금(KRW 외 통화) 자산 계산에 사용됩니다.
- AI(Gemini)는 검색/챗 보조에만 사용하며, 환율 조회에는 사용하지 않습니다.

## 정렬/차트 UX
- 테이블 수익률 헤더 클릭 시 순환 정렬:
  - 수익률(%) 내림차순 → 오름차순 → 평가손익(₩) 내림차순 → 오름차순 → 해제
  - 헤더에 현재 상태 아이콘/텍스트 표시
- 손익 차트(ProfitLossChart):
  - ‘투자 원금’, ‘총 평가액’, ‘손익’ 라인 동시 표시
  - 툴팁에 날짜, 투자 원금, 총 평가액, 총 수익률 (합산 평균) 표시

## Google Drive 동기화 훅
- `useGoogleDriveSync.ts`가 제공하는 기능:
  - `isSignedIn`, `googleUser`, `isInitializing`
  - `handleSignIn()`, `handleSignOut()`
  - `loadFromGoogleDrive()` → `{ assets, portfolioHistory, sellHistory, watchlist, exchangeRates }`
  - `autoSave(assets, history, sells, watchlist, exchangeRates)`
- `App.tsx`에서 훅을 사용하도록 통합되어 유지보수성이 향상되었습니다.

## 빌드/배포
```bash
npm run build
```
- 빌드 산출물은 `dist/`에 생성됩니다
- 정적 호스팅(Cloudflare Pages/Vercel 등) 또는 서버에 배포
- Cloud Run API 접근 권한/네트워크 허용을 확인하세요

## 데이터 모델 요약
- `Asset` 기본 필드:
  - `currency`: `KRW | USD | JPY | CNY`
  - `currentPrice`와 `purchasePrice`: 해당 통화 기준
  - 원화 환산은 `ExchangeRates` 상태를 활용
- `ExchangeRates`:
  - `{ USD: number; JPY: number }` 형태이며 UI에서 수정 가능

## 변경 사항 요약(로드맵)
1. Google Drive 로직 분리: `useGoogleDriveSync` 도입, `App.tsx` 통합
2. 시세 소스/분기 변경: 주식은 Cloud Run, 코인은 Upbit로 사용하며, ‘거래소(Exchange)’ 기준으로 자동 분기 (`services/priceService.ts`)
3. 포트폴리오 정렬 고도화: 수익률 헤더 클릭 시 순환 정렬
4. 대시보드 차트 보강: 투자 원금/총 평가액 라인 & 툴팁 라벨을 ‘총 수익률 (합산 평균)’으로 변경
5. 문서화: 프로젝트 개요/구조/설치/환경/데이터 소스/UX 정리

## 주의 사항
- Cloud Run API는 `tickers`가 비어있으면 오류를 반환합니다. 배치 요청 시 항상 유효한 틱커/거래소 페어를 전달하세요.
- 환율은 Cloud Run을 우선 사용합니다. 검색(`searchSymbols`)과 챗은 `geminiService`를 사용합니다.
</file>

<file path="package.json">
{
  "name": "자산-관리-시트",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "deploy": "npm run build && gh-pages -d dist"
  },
  "dependencies": {
    "@google/genai": "^1.29.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.555.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-markdown": "^9.1.0",
    "recharts": "^3.4.1",
    "remark-gfm": "^4.0.1",
    "tailwind-merge": "^3.4.0"
  },
  "devDependencies": {
    "@types/node": "^22.14.0",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.22",
    "gh-pages": "^6.3.0",
    "postcss": "^8.5.6",
    "rehype-raw": "^7.0.0",
    "tailwindcss": "^3.4.13",
    "typescript": "~5.8.2",
    "vite": "^6.4.1"
  }
}
</file>

<file path="services/googleDriveService.ts">
// Google Drive API 서비스
// Google Identity Services를 사용한 OAuth 인증 및 Drive API 연동

export interface GoogleUser {
  email: string;
  name: string;
  picture?: string;
}

export interface DriveFile {
  id: string;
  name: string;
  mimeType: string;
  createdTime: string;
  modifiedTime: string;
}

const DRIVE_FOLDER_ID = '10O5cGNd9QVoAAxR8NdojqI9AD7wj0Q_g';

class GoogleDriveService {
  private accessToken: string | null = null;
  private user: GoogleUser | null = null;
  private clientId: string | null = null;
  private tokenClient: google.accounts.oauth2.TokenClient | null = null;
  private isInitialized = false;
  private folderId: string | null = DRIVE_FOLDER_ID;

  // Google Identity Services 초기화
  async initialize(clientId: string): Promise<void> {
    if (this.isInitialized) return;
    
    this.clientId = clientId;
    
    // Google API 스크립트 로드
    await this.loadGoogleScripts();
    
    // 저장된 토큰 확인
    const savedToken = localStorage.getItem('google_drive_access_token');
    const savedUser = localStorage.getItem('google_drive_user');
    const savedTokenExpiry = localStorage.getItem('google_drive_token_expiry');
    
    if (savedToken && savedUser) {
      this.accessToken = savedToken;
      this.user = JSON.parse(savedUser);
      
      // 토큰 만료 시간 확인
      const now = Date.now();
      const expiryTime = savedTokenExpiry ? parseInt(savedTokenExpiry, 10) : 0;
      
      // 토큰이 만료되지 않았고 유효한 경우
      if (expiryTime > now && await this.validateToken()) {
        this.isInitialized = true;
        // 만료 5분 전에 자동 갱신 스케줄
        const timeUntilExpiry = expiryTime - now;
        const refreshTime = Math.max(0, timeUntilExpiry - 5 * 60 * 1000); // 5분 전
        setTimeout(() => {
          this.refreshTokenSilently();
        }, refreshTime);
        return;
      } else {
        // 토큰이 만료된 경우 - 자동 갱신 시도
        if (savedTokenExpiry && expiryTime > now - 60 * 60 * 1000) { // 1시간 이내 만료된 경우만
          try {
            await this.refreshTokenSilently();
            if (this.accessToken) {
              this.isInitialized = true;
              return;
            }
          } catch (error) {
            console.log('Silent token refresh failed, user needs to sign in again');
          }
        }
        // 토큰이 만료된 경우
        this.accessToken = null;
        this.user = null;
        localStorage.removeItem('google_drive_access_token');
        localStorage.removeItem('google_drive_user');
        localStorage.removeItem('google_drive_token_expiry');
      }
    }
    
    this.isInitialized = true;
  }

  private loadGoogleScripts(): Promise<void> {
    return new Promise((resolve, reject) => {
      // Google Identity Services 스크립트 로드
      if (window.google?.accounts) {
        resolve();
        return;
      }

      const script = document.createElement('script');
      script.src = 'https://accounts.google.com/gsi/client';
      script.async = true;
      script.defer = true;
      script.onload = () => {
        // Google API 클라이언트 라이브러리 로드
        const apiScript = document.createElement('script');
        apiScript.src = 'https://apis.google.com/js/api.js';
        apiScript.async = true;
        apiScript.defer = true;
        apiScript.onload = () => {
          window.gapi.load('client', () => {
            window.gapi.client.init({
              discoveryDocs: [
                'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest',
                'https://www.googleapis.com/discovery/v1/apis/oauth2/v2/rest'
              ],
            }).then(() => {
              resolve();
            }).catch(reject);
          });
        };
        apiScript.onerror = reject;
        document.head.appendChild(apiScript);
      };
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }

  // Google 로그인
  async signIn(): Promise<GoogleUser> {
    if (!this.clientId) {
      throw new Error('Google Drive service not initialized. Please provide client ID.');
    }
    return new Promise((resolve, reject) => {
      console.log('=== Google Sign In 시작 ===');
      console.log('Client ID:', this.clientId);
      console.log('Requested scope:', 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile openid');
      
      this.tokenClient = window.google.accounts.oauth2.initTokenClient({
        client_id: this.clientId!,
        scope: 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile openid',
        callback: async (response: google.accounts.oauth2.TokenResponse) => {
          console.log('=== OAuth Callback 실행됨 ===');
          console.log('Response:', response);
          
          if (response.error) {
            console.error('OAuth error:', response.error);
            reject(new Error(response.error));
            return;
          }
    
          this.accessToken = response.access_token;
          console.log('Access token received');
          console.log('Received scope:', response.scope);
          console.log('Scope includes userinfo.email:', response.scope?.includes('userinfo.email'));
          console.log('Scope includes userinfo.profile:', response.scope?.includes('userinfo.profile'));
          
          // 토큰 만료 시간 저장 (기본 1시간, expires_in이 있으면 사용)
          const expiresIn = response.expires_in ? response.expires_in * 1000 : 3600 * 1000;
          const expiryTime = Date.now() + expiresIn;
          localStorage.setItem('google_drive_token_expiry', expiryTime.toString());
          
          // 사용자 정보 가져오기
          try {
            const userInfo = await this.getUserInfo();
            this.user = userInfo;
            localStorage.setItem('google_drive_access_token', this.accessToken);
            localStorage.setItem('google_drive_user', JSON.stringify(userInfo));
            
            // 만료 5분 전에 자동 갱신 스케줄
            const refreshTime = Math.max(0, expiresIn - 5 * 60 * 1000); // 5분 전
            setTimeout(() => {
              this.refreshTokenSilently();
            }, refreshTime);
            
            resolve(userInfo);
          } catch (error: any) {
            console.error('Failed to get user info:', error);
            console.error('Error details:', error.message, error.stack);
            // 토큰은 받았지만 사용자 정보를 가져오지 못한 경우, 토큰을 저장하지 않음
            this.accessToken = null;
            reject(error);
          }
        },
      });
    
      console.log('Requesting access token with prompt: consent');
      this.tokenClient.requestAccessToken({ prompt: 'consent' });
    });
  }

  // 사용자 정보 가져오기
  private async getUserInfo(): Promise<GoogleUser> {
    if (!this.accessToken) {
      throw new Error('Not authenticated');
    }

    try {
      // 방법 1: OAuth2 userinfo API 시도
      const response = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
        headers: {
          Authorization: `Bearer ${this.accessToken}`,
        },
      });

      if (response.ok) {
        const data = await response.json();
        
        if (data.email) {
          return {
            email: data.email,
            name: data.name || data.email.split('@')[0],
            picture: data.picture,
          };
        }
      }

      // 방법 2: Google API 클라이언트 사용 (대안)
      if (window.gapi?.client && (window.gapi.client as any).setToken) {
        try {
          // 토큰 설정
          (window.gapi.client as any).setToken({ access_token: this.accessToken });
          await (window.gapi.client as any).load('oauth2', 'v2');
          const userInfo = await (window.gapi.client as any).oauth2.userinfo.get();
          if (userInfo.result && userInfo.result.email) {
            return {
              email: userInfo.result.email,
              name: userInfo.result.name || userInfo.result.email.split('@')[0],
              picture: userInfo.result.picture,
            };
          }
        } catch (gapiError) {
          console.error('GAPI userinfo error:', gapiError);
        }
      }

      // 두 방법 모두 실패한 경우
      const errorText = await response.text().catch(() => 'Unknown error');
      console.error('User info API error:', response.status, errorText);
      
      // 더 자세한 에러 메시지
      if (response.status === 401) {
        throw new Error('인증 실패: Google Cloud Console의 OAuth 동의 화면에서 userinfo.email과 userinfo.profile scope를 추가했는지 확인하세요.');
      } else if (response.status === 403) {
        throw new Error('권한 없음: 사용자 정보에 접근할 권한이 없습니다. scope 설정을 확인하세요.');
      } else {
        throw new Error(`사용자 정보를 가져올 수 없습니다 (${response.status}): ${errorText}`);
      }
    } catch (error: any) {
      console.error('getUserInfo error:', error);
      throw error;
    }
  }

  // 토큰 자동 갱신 (조용히)
  private async refreshTokenSilently(): Promise<void> {
    if (!this.clientId || !this.user) return;
    
    try {
      this.tokenClient = window.google.accounts.oauth2.initTokenClient({
        client_id: this.clientId!,
        scope: 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile openid',
        callback: async (response: google.accounts.oauth2.TokenResponse) => {
          if (response.error) {
            console.log('Token refresh failed:', response.error);
            return;
          }
          
          this.accessToken = response.access_token;
          const expiresIn = response.expires_in ? response.expires_in * 1000 : 3600 * 1000;
          const expiryTime = Date.now() + expiresIn;
          localStorage.setItem('google_drive_access_token', this.accessToken);
          localStorage.setItem('google_drive_token_expiry', expiryTime.toString());
          
          // 다음 갱신 스케줄
          const refreshTime = Math.max(0, expiresIn - 5 * 60 * 1000);
          setTimeout(() => {
            this.refreshTokenSilently();
          }, refreshTime);
        },
      });
      
      // prompt: 'none'으로 조용히 갱신 시도
      this.tokenClient.requestAccessToken({ prompt: 'none' });
    } catch (error) {
      console.log('Silent token refresh error:', error);
    }
  }

  // 로그아웃
  signOut(): void {
    if (this.accessToken) {
      window.google.accounts.oauth2.revoke(this.accessToken, () => {
        this.accessToken = null;
        this.user = null;
        localStorage.removeItem('google_drive_access_token');
        localStorage.removeItem('google_drive_user');
        localStorage.removeItem('google_drive_token_expiry');
      });
    }
  }

  // 로그인 상태 확인
  isSignedIn(): boolean {
    return this.accessToken !== null && this.user !== null;
  }

  // 현재 사용자 정보
  getCurrentUser(): GoogleUser | null {
    return this.user;
  }

  // 토큰 유효성 검사
  private async validateToken(): Promise<boolean> {
    if (!this.accessToken) return false;

    try {
      const response = await fetch('https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=' + this.accessToken);
      return response.ok;
    } catch {
      return false;
    }
  }

  // 파일 목록 가져오기
  async listFiles(): Promise<DriveFile[]> {
    if (!this.accessToken) {
      throw new Error('Not authenticated');
    }

    let query = "name = 'portfolio.json' and trashed = false";
    if (this.folderId) {
      query += ` and '${this.folderId}' in parents`;
    }

    const searchParams = new URLSearchParams({
      q: query,
      spaces: 'drive',
      fields: 'files(id,name),nextPageToken',
      pageSize: '10',
    });

    const response = await fetch(
      `https://www.googleapis.com/drive/v3/files?${searchParams.toString()}`,
      {
        headers: {
          Authorization: `Bearer ${this.accessToken}`,
        },
      }
    );

    if (!response.ok) {
      const errorText = await response.text().catch(() => 'Unknown error');
      console.error('Drive list files error', response.status, errorText);
      throw new Error(`Failed to list files (${response.status})`);
    }

    const data = await response.json();
    return data.files || [];
  }

  // 파일 저장 (생성 또는 업데이트)
  async saveFile(content: string, fileName: string = 'portfolio.json'): Promise<void> {
    if (!this.accessToken) {
      throw new Error('Not authenticated');
    }

    // 기존 파일 확인
    const files = await this.listFiles();
    const existingFile = files.find(f => f.name === fileName);

    const fileContent = new Blob([content], { type: 'application/json' });
    const baseMetadata = {
      name: fileName,
      mimeType: 'application/json',
    };

    if (existingFile) {
      // 파일 업데이트
      const form = new FormData();
      form.append('metadata', new Blob([JSON.stringify(baseMetadata)], { type: 'application/json' }));
      form.append('file', fileContent);

      const response = await fetch(
        `https://www.googleapis.com/upload/drive/v3/files/${existingFile.id}?uploadType=multipart`,
        {
          method: 'PATCH',
          headers: {
            Authorization: `Bearer ${this.accessToken}`,
          },
          body: form,
        }
      );

      if (!response.ok) {
        throw new Error('Failed to update file');
      }
    } else {
      // 새 파일 생성
      const metadata: any = { ...baseMetadata };
      if (this.folderId) {
        metadata.parents = [this.folderId];
      }
      const form = new FormData();
      form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
      form.append('file', fileContent);

      const response = await fetch(
        'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart',
        {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${this.accessToken}`,
          },
          body: form,
        }
      );

      if (!response.ok) {
        throw new Error('Failed to create file');
      }
    }
  }

  // 파일 불러오기
  async loadFile(fileName: string = 'portfolio.json'): Promise<string | null> {
    if (!this.accessToken) {
      throw new Error('Not authenticated');
    }

    const files = await this.listFiles();
    const file = files.find(f => f.name === fileName);

    if (!file) {
      return null;
    }

    const response = await fetch(
      `https://www.googleapis.com/drive/v3/files/${file.id}?alt=media`,
      {
        headers: {
          Authorization: `Bearer ${this.accessToken}`,
        },
      }
    );

    if (!response.ok) {
      const errorText = await response.text().catch(() => 'Unknown error');
      console.error('Drive load file error', response.status, errorText);
      throw new Error(`Failed to load file (${response.status})`);
    }

    return await response.text();
  }
}

// 싱글톤 인스턴스
export const googleDriveService = new GoogleDriveService();

// 타입 선언
declare global {
  interface Window {
    google: {
      accounts: {
        oauth2: {
          initTokenClient: (config: {
            client_id: string;
            scope: string;
            callback: (response: google.accounts.oauth2.TokenResponse) => void;
          }) => google.accounts.oauth2.TokenClient;
          revoke: (token: string, callback: () => void) => void;
        };
      };
    };
    gapi: {
      load: (api: string, callback: () => void) => void;
      client: {
        init: (config: {
          discoveryDocs: string[];
        }) => Promise<void>;
        setToken: (token: { access_token: string }) => void;
        load: (apiName: string, version: string) => Promise<void>;
        oauth2: {
          userinfo: {
            get: () => Promise<{ result: { email?: string; name?: string; picture?: string } }>;
          };
        };
      };
    };
  }

  namespace google {
    namespace accounts {
      namespace oauth2 {
        interface TokenClient {
          requestAccessToken: (options?: { prompt?: string }) => void;
        }
        interface TokenResponse {
          access_token: string;
          expires_in: number;
          scope: string;
          token_type: string;
          error?: string;
        }
      }
    }
  }
}
</file>

<file path="services/upbitService.ts">
// src/services/upbitService.ts

export interface UpbitTicker {
  market: string;
  trade_price: number;
  prev_closing_price: number;
  signed_change_price: number;
  signed_change_rate: number;
}

// 심볼 변환 (BTC -> KRW-BTC)
export const toUpbitPair = (symbol: string): string => {
  const s = (symbol || '').trim().toUpperCase();
  if (s.startsWith('KRW-') || s.startsWith('BTC-') || s.startsWith('USDT-')) {
    return s;
  }
  return `KRW-${s.replace(/USDT$/, '')}`;
};

// 배치 조회 (여러 코인 한 번에 조회)
export const fetchUpbitPricesBatch = async (symbols: string[]): Promise<Map<string, UpbitTicker>> => {
  if (symbols.length === 0) return new Map();

  // 중복 제거 및 마켓 코드 변환
  const uniqueMarkets = Array.from(new Set(symbols.map(s => toUpbitPair(s))));
  
  // 업비트 API URL (쉼표로 구분해서 한 번에 요청)
  const marketsParam = uniqueMarkets.join(',');
  
  try {
    const res = await fetch(`https://api.upbit.com/v1/ticker?markets=${marketsParam}`, {
      headers: { Accept: 'application/json' }
    });
    
    if (!res.ok) throw new Error(`Upbit API failed: ${res.status}`);
    
    const data: UpbitTicker[] = await res.json();
    const resultMap = new Map<string, UpbitTicker>();
    
    data.forEach(ticker => {
      // 결과 매핑: KRW-BTC -> Ticker 데이터
      resultMap.set(ticker.market, ticker);
      // "BTC"라고만 검색해도 찾을 수 있게 추가 매핑
      if(ticker.market.startsWith('KRW-')) {
        resultMap.set(ticker.market.replace('KRW-', ''), ticker);
      }
    });

    return resultMap;
  } catch (error) {
    console.error("Upbit fetch error:", error);
    return new Map();
  }
};
</file>

<file path="utils/migrateData.ts">
// utils/migrateData.ts
// 기존 DB 데이터를 새 구조로 변환하는 마이그레이션 스크립트

import { Currency, AssetCategory } from '../types';

/**
 * 마이그레이션 실행
 * 
 * 핵심 변경:
 * 1. 암호화폐: purchasePrice가 원화로 입력된 경우 currency를 KRW로 복구
 * 2. USD/JPY 자산: currentPrice가 원화로 저장된 경우 priceOriginal로 교체
 */
export const runMigrationIfNeeded = (data: any) => {
  if (!data || typeof data !== 'object') return data;
  
  // 환율 초기화
  if (!data.exchangeRates) {
    data.exchangeRates = { USD: 0, JPY: 0 };
  }
  
  // 자산 마이그레이션
  if (Array.isArray(data.assets)) {
    console.log('[Migration] 데이터 마이그레이션 시작...');
    let fixedCount = 0;
    
    data.assets = data.assets.map((asset: any) => {
      const ticker = asset.ticker || '?';
      const category = asset.category || '';
      const currency = asset.currency || 'KRW';
      const purchasePrice = asset.purchasePrice || 0;
      const currentPrice = asset.currentPrice || 0;
      const priceOriginal = asset.priceOriginal || 0;
      
      // ✅ 암호화폐 특별 처리
      if (category === '암호화폐' || category === AssetCategory.CRYPTOCURRENCY) {
        // USD로 설정되어 있지만 purchasePrice가 원화 수준인 경우
        if (currency === 'USD' || currency === Currency.USD) {
          // BTC: purchasePrice가 1억 이상이면 원화
          // ETH: purchasePrice가 100만 이상이면 원화
          // 기타: purchasePrice가 1000 이상이고 currentPrice가 1000 미만이면 원화
          const isKRWPurchase = 
            (purchasePrice > 100000000) ||  // 1억 이상 (BTC급)
            (purchasePrice > 1000000 && currentPrice < 10000) ||  // 100만 이상, 현재가 1만 미만 (ETH급)
            (purchasePrice > 1000 && currentPrice < 1000);  // 1000 이상, 현재가 1000 미만 (일반)
          
          if (isKRWPurchase) {
            console.log(`[Migration] ${ticker}: 암호화폐 KRW 복구`);
            console.log(`  - purchasePrice: ${purchasePrice.toLocaleString()} (KRW)`);
            console.log(`  - currency: USD → KRW`);
            fixedCount++;
            
            return {
              ...asset,
              currency: Currency.KRW,
            };
          }
        }
      }
      
      // ✅ USD/JPY 자산: currentPrice가 원화로 저장된 경우 복구
      if (currency === 'USD' || currency === 'JPY' || 
          currency === Currency.USD || currency === Currency.JPY) {
        
        if (priceOriginal > 0 && currentPrice > 0) {
          const ratio = currentPrice / priceOriginal;
          
          // currentPrice가 priceOriginal보다 100배 이상 크면 원화로 저장된 것
          if (ratio > 100) {
            console.log(`[Migration] ${ticker}: 가격 복구 (원화→원래통화)`);
            console.log(`  - currentPrice: ${currentPrice.toLocaleString()} → ${priceOriginal}`);
            fixedCount++;
            
            // 최고가도 복구
            let newHighestPrice = priceOriginal;
            if (asset.highestPrice > 0) {
              newHighestPrice = asset.highestPrice / ratio;
              if (newHighestPrice < priceOriginal) {
                newHighestPrice = priceOriginal;
              }
            }
            
            return {
              ...asset,
              currentPrice: priceOriginal,
              highestPrice: newHighestPrice,
            };
          }
        }
      }
      
      return asset;
    });
    
    console.log(`[Migration] 완료! ${fixedCount}개 자산 수정됨`);
  }
  
  return data;
};
</file>

<file path="components/SellAssetModal.tsx">
// components/SellAssetModal.tsx
// 수정된 버전: 매도 통화를 자산 통화로 고정

import React, { useState, useEffect } from 'react';
import { Asset, Currency, CURRENCY_SYMBOLS } from '../types';

interface SellAssetModalProps {
  asset: Asset | null;
  isOpen: boolean;
  onClose: () => void;
  onSell: (
    assetId: string, 
    sellDate: string, 
    sellPrice: number,      // 자산 통화 기준 매도가
    sellQuantity: number,
    currency: Currency      // 자산의 통화
  ) => void;
  isLoading: boolean;
}

const SellAssetModal: React.FC<SellAssetModalProps> = ({ 
  asset, 
  isOpen, 
  onClose, 
  onSell, 
  isLoading 
}) => {
  const [sellDate, setSellDate] = useState<string>(new Date().toISOString().slice(0, 10));
  const [sellPrice, setSellPrice] = useState<string>('');
  const [sellQuantity, setSellQuantity] = useState<string>('');

  useEffect(() => {
    if (asset && isOpen) {
      setSellDate(new Date().toISOString().slice(0, 10));
      // 현재가를 자산 통화 기준으로 표시
      setSellPrice(asset.currentPrice.toString());
      setSellQuantity(asset.quantity.toString());
    }
  }, [asset, isOpen]);

  if (!isOpen || !asset) return null;

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!sellDate || !sellPrice || !sellQuantity) {
      alert('모든 필드를 입력해주세요.');
      return;
    }

    const quantity = parseFloat(sellQuantity);
    const price = parseFloat(sellPrice);

    if (quantity <= 0 || quantity > asset.quantity) {
      alert(`매도 수량은 0보다 크고 보유 수량(${asset.quantity}) 이하여야 합니다.`);
      return;
    }

    if (price <= 0) {
      alert('매도가는 0보다 커야 합니다.');
      return;
    }

    // 자산의 원래 통화로 매도 처리
    onSell(
      asset.id,
      sellDate,
      price,           // 자산 통화 기준 매도가
      quantity,
      asset.currency   // 자산의 통화
    );
  };

  const inputClasses = "w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition";
  const labelClasses = "block text-sm font-medium text-gray-300 mb-1";

  const formatCurrency = (num: number, currency: Currency): string => {
    if (currency === Currency.KRW) {
      return new Intl.NumberFormat('ko-KR', { 
        style: 'currency', 
        currency: 'KRW', 
        maximumFractionDigits: 0 
      }).format(num);
    }
    if (currency === Currency.JPY) {
      return `${CURRENCY_SYMBOLS[currency]}${new Intl.NumberFormat('ja-JP', { 
        maximumFractionDigits: 0 
      }).format(num)}`;
    }
    return `${CURRENCY_SYMBOLS[currency]}${new Intl.NumberFormat('en-US', { 
      minimumFractionDigits: 2,
      maximumFractionDigits: 2 
    }).format(num)}`;
  };

  const currencySymbol = CURRENCY_SYMBOLS[asset.currency];
  const currencyLabel = asset.currency;

  // 예상 매도금액 계산
  const estimatedTotal = parseFloat(sellPrice || '0') * parseFloat(sellQuantity || '0');

  return (
    <div 
      className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-50" 
      onClick={onClose} 
      role="dialog" 
      aria-modal="true"
    >
      <div 
        className="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-lg" 
        onClick={(e) => e.stopPropagation()}
      >
        <h2 className="text-2xl font-bold text-white mb-6">
          매도: {asset.customName?.trim() || asset.name}
        </h2>
        
        <form onSubmit={handleSubmit} className="space-y-4">
          {/* 보유 정보 */}
          <div className="bg-gray-700 p-4 rounded-md">
            <div className={labelClasses}>보유정보</div>
            <div className="grid grid-cols-3 gap-4 text-sm">
              <div>
                <div className="text-gray-400">보유 수량</div>
                <div className="text-white font-semibold">
                  {asset.quantity.toLocaleString()}
                </div>
              </div>
              <div>
                <div className="text-gray-400">현재가</div>
                <div className="text-white font-semibold">
                  {formatCurrency(asset.currentPrice, asset.currency)}
                </div>
              </div>
              <div>
                <div className="text-gray-400">평가금액</div>
                <div className="text-white font-semibold">
                  {formatCurrency(asset.currentPrice * asset.quantity, asset.currency)}
                </div>
              </div>
            </div>
          </div>

          {/* 통화 표시 (변경 불가) */}
          <div className="bg-gray-700/50 p-3 rounded-md">
            <div className="flex items-center justify-between">
              <span className="text-sm text-gray-400">매도 통화</span>
              <span className="text-white font-medium flex items-center gap-2">
                {asset.currency === Currency.USD && '🇺🇸'}
                {asset.currency === Currency.JPY && '🇯🇵'}
                {asset.currency === Currency.KRW && '🇰🇷'}
                {currencyLabel}
              </span>
            </div>
            <p className="text-xs text-gray-500 mt-1">
              * 매수 통화와 동일한 통화로만 매도할 수 있습니다.
            </p>
          </div>

          {/* 매도일자 */}
          <div>
            <label htmlFor="sellDate" className={labelClasses}>매도일자</label>
            <input
              id="sellDate"
              type="date"
              value={sellDate}
              onChange={(e) => setSellDate(e.target.value)}
              className={inputClasses}
              required
            />
          </div>

          {/* 매도가 */}
          <div>
            <label htmlFor="sellPrice" className={labelClasses}>
              매도가 ({currencySymbol})
            </label>
            <div className="relative">
              <span className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400">
                {currencySymbol}
              </span>
              <input
                id="sellPrice"
                type="number"
                value={sellPrice}
                onChange={(e) => setSellPrice(e.target.value)}
                className={`${inputClasses} pl-8`}
                required
                min="0"
                step="any"
                placeholder="매도가를 입력하세요"
              />
            </div>
          </div>

          {/* 매도 수량 */}
          <div>
            <label htmlFor="sellQuantity" className={labelClasses}>매도 수량</label>
            <input
              id="sellQuantity"
              type="number"
              value={sellQuantity}
              onChange={(e) => setSellQuantity(e.target.value)}
              className={inputClasses}
              required
              min="1"
              max={asset.quantity}
              step="any"
              placeholder="매도할 수량을 입력하세요"
            />
            <div className="flex justify-between mt-1">
              <button
                type="button"
                onClick={() => setSellQuantity(asset.quantity.toString())}
                className="text-xs text-primary hover:text-primary-light"
              >
                전량 매도
              </button>
              <span className="text-xs text-gray-500">
                최대: {asset.quantity.toLocaleString()}
              </span>
            </div>
          </div>

          {/* 예상 매도금액 */}
          {estimatedTotal > 0 && (
            <div className="bg-gray-900 p-4 rounded-md">
              <div className="flex justify-between items-center">
                <span className="text-gray-400">예상 매도금액</span>
                <span className="text-xl font-bold text-white">
                  {formatCurrency(estimatedTotal, asset.currency)}
                </span>
              </div>
            </div>
          )}

          {/* 버튼 */}
          <div className="pt-4 flex gap-3">
            <button
              type="button"
              onClick={onClose}
              className="flex-1 bg-gray-600 hover:bg-gray-500 text-white font-medium py-2.5 px-4 rounded-md transition duration-300"
            >
              취소
            </button>
            <button
              type="submit"
              disabled={isLoading}
              className="flex-1 bg-danger hover:bg-red-600 text-white font-bold py-2.5 px-4 rounded-md disabled:bg-gray-600 disabled:cursor-not-allowed transition duration-300 flex items-center justify-center"
            >
              {isLoading ? (
                <svg className="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
              ) : '매도 확인'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default SellAssetModal;
</file>

<file path="components/WatchlistPage.tsx">
import React, { useMemo, useState, useEffect } from 'react';
import Toggle from './common/Toggle';
import { Filter, Trash2 } from 'lucide-react';
import { AssetCategory, Currency, CURRENCY_SYMBOLS, ALLOWED_CATEGORIES, WatchlistItem, inferCategoryFromExchange, normalizeExchange, SymbolSearchResult } from '../types';
import { searchSymbols } from '../services/geminiService';

interface WatchlistPageProps {
  watchlist: WatchlistItem[];
  onAdd: (item: Omit<WatchlistItem, 'id' | 'currentPrice' | 'priceOriginal' | 'currency' | 'yesterdayPrice' | 'highestPrice' | 'lastSignalAt' | 'lastSignalType'>) => void;
  onUpdate: (item: WatchlistItem) => void;
  onDelete: (id: string) => void;
  onToggleMonitoring: (id: string, enabled: boolean) => void;
  onRefreshAll: () => void;
  isLoading: boolean;
  onBulkDelete?: (ids: string[]) => void;
}

const WatchlistPage: React.FC<WatchlistPageProps> = ({ watchlist, onAdd, onUpdate, onDelete, onToggleMonitoring, onRefreshAll, isLoading, onBulkDelete }) => {
  const [filterCategory, setFilterCategory] = useState<AssetCategory | 'ALL'>('ALL');
  const [search, setSearch] = useState('');
  const [monitoringOnly, setMonitoringOnly] = useState(false);
  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());
  const [openFilterOptions, setOpenFilterOptions] = useState<boolean>(false);

  const [form, setForm] = useState<{ ticker: string; exchange: string; name: string; category: AssetCategory; buyZoneMin?: string; buyZoneMax?: string; dropFromHighThreshold?: string; notes?: string }>({
    ticker: '',
    exchange: 'KRX (코스피/코스닥)',
    name: '',
    category: AssetCategory.KOREAN_STOCK,
  });
  const [symbolQuery, setSymbolQuery] = useState('');
  const [symbolResults, setSymbolResults] = useState<SymbolSearchResult[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [isFocused, setIsFocused] = useState(false);

  const DEFAULT_SYMBOLS: SymbolSearchResult[] = [
    { ticker: '005930', name: '삼성전자', exchange: 'KRX (코스피/코스닥)' },
    { ticker: '005380', name: '현대자동차', exchange: 'KRX (코스피/코스닥)' },
    { ticker: '035420', name: 'NAVER', exchange: 'KRX (코스피/코스닥)' },
    { ticker: '035720', name: '카카오', exchange: 'KRX (코스피/코스닥)' },
    { ticker: 'AAPL', name: 'Apple Inc.', exchange: 'NASDAQ' },
    { ticker: 'TSLA', name: 'Tesla, Inc.', exchange: 'NASDAQ' },
    { ticker: 'GOOGL', name: 'Alphabet Inc.', exchange: 'NASDAQ' },
    { ticker: 'MSFT', name: 'Microsoft Corporation', exchange: 'NASDAQ' },
    { ticker: 'BTC', name: '비트코인', exchange: '주요 거래소 (종합)' },
    { ticker: 'ETH', name: '이더리움', exchange: '주요 거래소 (종합)' },
  ];

  const categoryOptions = useMemo(() => {
    const extras = Array.from(new Set(watchlist.map(w => w.category))).filter(cat => !ALLOWED_CATEGORIES.includes(cat));
    return [...ALLOWED_CATEGORIES, ...extras];
  }, [watchlist]);

  const filtered = useMemo(() => {
    return watchlist
      .filter(w => (filterCategory === 'ALL' ? true : w.category === filterCategory))
      .filter(w => (monitoringOnly ? w.monitoringEnabled : true))
      .filter(w => {
        if (!search) return true;
        const s = search.toLowerCase();
        return w.name.toLowerCase().includes(s) || w.ticker.toLowerCase().includes(s) || (w.notes || '').toLowerCase().includes(s);
      })
      .map(w => ({
        ...w,
        dropFromHigh: w.highestPrice && w.currentPrice ? ((w.currentPrice - w.highestPrice) / w.highestPrice) * 100 : 0,
        yesterdayChange: w.yesterdayPrice && w.currentPrice ? ((w.currentPrice - w.yesterdayPrice) / w.yesterdayPrice) * 100 : 0,
        inBuyZone: w.buyZoneMin !== undefined && w.buyZoneMax !== undefined && w.currentPrice !== undefined
          ? w.currentPrice >= w.buyZoneMin && w.currentPrice <= w.buyZoneMax
          : false,
      }));
  }, [watchlist, filterCategory, monitoringOnly, search]);

  useEffect(() => {
    if (symbolQuery.length < 2) {
      setSymbolResults([]);
      return;
    }
    const handler = setTimeout(async () => {
      setIsSearching(true);
      try {
        const results = await searchSymbols(symbolQuery);
        if (Array.isArray(results) && results.length > 0) {
          setSymbolResults(results);
        } else {
          const q = symbolQuery.toLowerCase();
          const local = DEFAULT_SYMBOLS.filter(r => r.name.toLowerCase().includes(q) || r.ticker.toLowerCase().includes(q)).slice(0, 10);
          setSymbolResults(local);
        }
      } catch {
        const q = symbolQuery.toLowerCase();
        const local = DEFAULT_SYMBOLS.filter(r => r.name.toLowerCase().includes(q) || r.ticker.toLowerCase().includes(q)).slice(0, 10);
        setSymbolResults(local);
      } finally {
        setIsSearching(false);
      }
    }, 300);
    return () => { clearTimeout(handler); };
  }, [symbolQuery]);

  useEffect(() => {
    setSelectedIds(prev => {
      const next = new Set<string>();
      filtered.forEach(w => {
        if (prev.has(w.id)) next.add(w.id);
      });
      return next;
    });
  }, [filtered]);

  const formatKRW = (num: number) => new Intl.NumberFormat('ko-KR', { style: 'currency', currency: 'KRW', maximumFractionDigits: 0 }).format(num);
  const formatOriginalCurrency = (num: number, currency: Currency) => `${CURRENCY_SYMBOLS[currency]}${new Intl.NumberFormat('en-US', { maximumFractionDigits: 2 }).format(num)}`;
  const getChangeColor = (value: number) => (value > 0 ? 'text-success' : value < 0 ? 'text-danger' : 'text-gray-400');
  const allSelected = filtered.length > 0 && filtered.every(w => selectedIds.has(w.id));
  const isEditMode = selectedIds.size === 1;

  useEffect(() => {
    if (!isEditMode) return;
    const selectedId = Array.from(selectedIds)[0];
    const selected = watchlist.find(w => w.id === selectedId);
    if (!selected) return;
    setForm({
      ticker: selected.ticker,
      exchange: selected.exchange,
      name: selected.name,
      category: selected.category,
      buyZoneMin: selected.buyZoneMin !== undefined ? String(selected.buyZoneMin) : undefined,
      buyZoneMax: selected.buyZoneMax !== undefined ? String(selected.buyZoneMax) : undefined,
      dropFromHighThreshold: selected.dropFromHighThreshold !== undefined ? String(selected.dropFromHighThreshold) : undefined,
      notes: selected.notes,
    });
    setSymbolQuery(selected.name);
  }, [isEditMode, selectedIds, watchlist]);

  return (
    <div className="space-y-6">
      <div className="bg-gray-800 p-4 rounded-lg shadow-lg flex items-center justify-between gap-4">
        <div className="flex items-center gap-4">
          <div className="relative">
            <input type="text" value={search} onChange={e => setSearch(e.target.value)} placeholder="이름/티커/메모 검색" className="bg-gray-700 border border-gray-600 rounded-md py-2 pl-10 pr-10 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary w-64" />
            <svg className="absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
          </div>
        </div>
        <div className="flex items-center gap-2">
          <button onClick={() => {
            if (filtered.length === 0) return;
            const ids = filtered.map(w => w.id);
            const next = new Set<string>(selectedIds);
            const selectAll = !(filtered.every(w => selectedIds.has(w.id)));
            if (selectAll) ids.forEach(id => next.add(id)); else ids.forEach(id => next.delete(id));
            setSelectedIds(next);
          }} className="border border-gray-600 text-gray-300 hover:bg-gray-700 hover:text-white font-medium py-2 px-3 rounded-md transition duration-300">
            {allSelected ? '전체 해제' : '전체 선택'}
          </button>
          <button onClick={() => {
            const ids = Array.from(selectedIds);
            if (ids.length === 0) return;
            if (onBulkDelete) onBulkDelete(ids); else ids.forEach(id => onDelete(id));
            setSelectedIds(new Set());
          }} disabled={selectedIds.size === 0} className="border border-gray-600 text-red-400 hover:bg-gray-700 font-medium py-2 px-4 rounded-md transition duration-300 disabled:text-gray-500 disabled:border-gray-700 disabled:cursor-not-allowed">
            선택 삭제
          </button>
          <button onClick={onRefreshAll} disabled={isLoading} className="bg-primary hover:bg-primary-dark text-white font-medium py-2 px-4 rounded-md transition duration-300 flex items-center disabled:bg-gray-600 disabled:cursor-not-allowed">
          {isLoading ? (
            <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
          ) : null}
          <span>{isLoading ? '업데이트 중...' : '가격 새로고침'}</span>
          </button>
          <div className="relative">
            <button
              onClick={() => setOpenFilterOptions(prev => !prev)}
              className="border border-gray-600 text-gray-300 hover:bg-gray-700 hover:text-white font-medium py-2 px-3 rounded-md transition duration-300 flex items-center gap-2"
              title="필터"
            >
              <Filter className="h-4 w-4" />
              <span className="hidden sm:inline">필터</span>
            </button>
            {openFilterOptions && (
              <div className="absolute right-0 mt-2 w-72 bg-gray-800 border border-gray-700 rounded-md shadow-lg z-20 p-3">
                <div className="space-y-3">
                  <div>
                    <div className="text-xs text-gray-400 mb-1">카테고리</div>
                    <div className="relative">
                      <select value={filterCategory} onChange={e => setFilterCategory(e.target.value as AssetCategory | 'ALL')} className="bg-gray-700 border border-gray-600 rounded-md py-2 pl-3 pr-8 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary appearance-none w-full">
                        <option value="ALL">전체</option>
                        {categoryOptions.map(cat => (
                          <option key={cat} value={cat}>{cat}</option>
                        ))}
                      </select>
                      <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-400">
                        <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                      </div>
                    </div>
                  </div>
                  <Toggle
                    label="모니터링 ON만"
                    checked={monitoringOnly}
                    onChange={(next) => setMonitoringOnly(next)}
                  />
                </div>
              </div>
            )}
          </div>
        </div>
      </div>

      <div className="bg-gray-800 p-4 rounded-lg shadow-lg">
        <h3 className="text-lg font-semibold text-white mb-3">{isEditMode ? '종목 수정' : '종목 추가'}</h3>
        <div className="mb-3">
          <div className="relative">
            <input 
              id="watchlist-symbol-search" 
              type="text" 
              value={symbolQuery} 
              onChange={(e) => setSymbolQuery(e.target.value)} 
              onFocus={() => setIsFocused(true)}
              onBlur={() => setTimeout(() => setIsFocused(false), 150)}
              placeholder="티커/종목 검색"
              className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm w-full"
              autoComplete="off"
            />
            {isSearching && (
              <div className="absolute top-2 right-3">
                <svg className="animate-spin h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
              </div>
            )}
            {isFocused && symbolResults.length > 0 && (
              <ul className="absolute z-10 w-full bg-gray-700 border border-gray-600 rounded-md mt-1 max-h-60 overflow-y-auto shadow-lg">
                {symbolResults.map((result) => (
                  <li 
                    key={`${result.ticker}-${result.exchange}`} 
                    onMouseDown={() => {
                      const ex = normalizeExchange(result.exchange);
                      const cat = inferCategoryFromExchange(ex);
                      setForm(prev => ({ ...prev, ticker: result.ticker, exchange: ex, name: result.name, category: cat }));
                      setSymbolQuery(`${result.name}`);
                      setSymbolResults([]);
                    }} 
                    className="px-3 py-2 cursor-pointer hover:bg-primary-dark transition-colors"
                  >
                    <div className="font-bold text-white">{result.name} ({result.ticker})</div>
                    <div className="text-sm text-gray-400">{result.exchange}</div>
                  </li>
                ))}
              </ul>
            )}
          </div>
        </div>
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3">
          <input className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm" placeholder="티커" value={form.ticker} onChange={e => setForm({ ...form, ticker: e.target.value })} />
          <input className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm" placeholder="거래소" value={form.exchange} onChange={e => setForm({ ...form, exchange: e.target.value })} />
          <input className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm" placeholder="이름" value={form.name} onChange={e => setForm({ ...form, name: e.target.value })} />
          <div className="relative">
            <select value={form.category} onChange={e => setForm({ ...form, category: e.target.value as AssetCategory })} className="bg-gray-700 border border-gray-600 rounded-md py-2 pl-3 pr-8 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary appearance-none w-full">
              {ALLOWED_CATEGORIES.map(cat => <option key={cat} value={cat}>{cat}</option>)}
            </select>
            <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-400">
              <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
            </div>
          </div>
          <input className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm" placeholder="매수존 하한(KRW)" value={form.buyZoneMin || ''} onChange={e => setForm({ ...form, buyZoneMin: e.target.value })} />
          <input className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm" placeholder="매수존 상한(KRW)" value={form.buyZoneMax || ''} onChange={e => setForm({ ...form, buyZoneMax: e.target.value })} />
          <input className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm" placeholder="최고가대비 하락%" value={form.dropFromHighThreshold || ''} onChange={e => setForm({ ...form, dropFromHighThreshold: e.target.value })} />
          <input className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm" placeholder="메모" value={form.notes || ''} onChange={e => setForm({ ...form, notes: e.target.value })} />
          <div className="sm:col-span-2 lg:col-span-4">
            <button
              onClick={() => {
                if (!form.ticker || !form.exchange || !form.name) return;
                if (selectedIds.size === 1) {
                  const selectedId = Array.from(selectedIds)[0];
                  const original = watchlist.find(w => w.id === selectedId);
                  if (!original) return;
                  const updated: WatchlistItem = {
                    ...original,
                    ticker: form.ticker,
                    exchange: form.exchange,
                    name: form.name,
                    category: form.category,
                    notes: form.notes,
                    buyZoneMin: form.buyZoneMin ? parseFloat(form.buyZoneMin) : undefined,
                    buyZoneMax: form.buyZoneMax ? parseFloat(form.buyZoneMax) : undefined,
                    dropFromHighThreshold: form.dropFromHighThreshold ? parseFloat(form.dropFromHighThreshold) : undefined,
                  };
                  onUpdate(updated);
                } else {
                  onAdd({
                    id: '',
                    ticker: form.ticker,
                    exchange: form.exchange,
                    name: form.name,
                    category: form.category,
                    monitoringEnabled: true,
                    notes: form.notes,
                    buyZoneMin: form.buyZoneMin ? parseFloat(form.buyZoneMin) : undefined,
                    buyZoneMax: form.buyZoneMax ? parseFloat(form.buyZoneMax) : undefined,
                    dropFromHighThreshold: form.dropFromHighThreshold ? parseFloat(form.dropFromHighThreshold) : undefined,
                  } as any);
                }
                setForm({ ticker: '', exchange: 'KRX (코스피/코스닥)', name: '', category: AssetCategory.KOREAN_STOCK });
                setSymbolQuery('');
                setSelectedIds(new Set());
              }}
              className="bg-primary hover:bg-primary-dark text-white font-medium py-2 px-4 rounded-md transition duration-300"
            >
              {selectedIds.size === 1 ? '수정' : '추가'}
            </button>
          </div>
        </div>
      </div>

      <div className="w-full px-0 sm:px-0">
        <table className="w-full text-sm text-left text-gray-400 table-auto">
          <thead className="text-xs text-gray-300 uppercase bg-gray-700 select-none sticky top-0 z-10">
            <tr>
              <th className="px-4 py-3 text-center">
                <input type="checkbox" checked={allSelected} onChange={() => {
                  const ids = filtered.map(w => w.id);
                  const next = new Set<string>(selectedIds);
                  const selectAll = !(filtered.every(w => selectedIds.has(w.id)));
                  if (selectAll) ids.forEach(id => next.add(id)); else ids.forEach(id => next.delete(id));
                  setSelectedIds(next);
                }} />
              </th>
              <th className="px-4 py-3">종목명</th>
              <th className="px-4 py-3 text-right">현재가</th>
              <th className="px-4 py-3 text-right">어제대비</th>
              <th className="px-4 py-3 text-right">최고가대비</th>
              <th className="px-4 py-3 text-center">매수존</th>
              <th className="px-4 py-3 text-center">신호</th>
              <th className="px-4 py-3 text-center">모니터링</th>
              <th className="px-4 py-3">메모</th>
              <th className="px-4 py-3 text-center">삭제</th>
            </tr>
          </thead>
          <tbody>
            {filtered.length > 0 ? filtered.map(w => {
              const isNonKRW = w.currency !== undefined && w.currency !== Currency.KRW;
              const signalBuyZone = w.inBuyZone;
              const signalDrop = w.dropFromHighThreshold !== undefined && (w.dropFromHigh || 0) <= -(w.dropFromHighThreshold || 0);
              const signalDailyDrop = (w.yesterdayChange || 0) < -2;
              const hasSignal = signalBuyZone || signalDrop || signalDailyDrop;
              return (
                <tr key={w.id} className={`border-b border-gray-700`}>
                  <td className="px-4 py-3 text-center">
                    <input type="checkbox" checked={selectedIds.has(w.id)} onChange={(e) => {
                      const next = new Set<string>(selectedIds);
                      if (e.target.checked) next.add(w.id); else next.delete(w.id);
                      setSelectedIds(next);
                    }} />
                  </td>
                  <td className="px-4 py-3">
                    <div className="flex flex-col">
                      <div className="font-bold text-white">{w.name}</div>
                      <div className="text-xs text-gray-500">{w.ticker} | {w.exchange} | {w.category}</div>
                    </div>
                  </td>
                  <td className="px-4 py-3 text-right">
                    {w.currentPrice !== undefined ? formatKRW(w.currentPrice) : '-'}
                    {isNonKRW && w.priceOriginal !== undefined && w.currency !== undefined && (
                      <div className="text-xs text-gray-500">{formatOriginalCurrency(w.priceOriginal, w.currency)}</div>
                    )}
                  </td>
                  <td className={`px-4 py-3 text-right ${getChangeColor(w.yesterdayChange || 0)}`}>{w.yesterdayChange !== undefined ? `${(w.yesterdayChange || 0).toFixed(2)}%` : '-'}</td>
                  <td className={`px-4 py-3 text-right ${getChangeColor(w.dropFromHigh || 0)}`}>{w.dropFromHigh !== undefined ? `${(w.dropFromHigh || 0).toFixed(2)}%` : '-'}</td>
                  <td className="px-4 py-3 text-center">
                    {w.buyZoneMin !== undefined && w.buyZoneMax !== undefined ? (
                      <span className="text-gray-200">{formatKRW(w.buyZoneMin)} ~ {formatKRW(w.buyZoneMax)}</span>
                    ) : '-'}
                  </td>
                  <td className="px-4 py-3 text-center">
                    {hasSignal ? (
                      <div className="flex justify-center gap-2">
                        {signalBuyZone && <span className="px-2 py-1 rounded bg-success/20 text-success text-xs">매수존</span>}
                        {signalDrop && <span className="px-2 py-1 rounded bg-blue-500/20 text-blue-400 text-xs">최고가대비</span>}
                        {signalDailyDrop && <span className="px-2 py-1 rounded bg-danger/20 text-danger text-xs">일중하락</span>}
                      </div>
                    ) : <span className="text-gray-500">-</span>}
                  </td>
                  <td className="px-4 py-3 text-center">
                    <label className="inline-flex items-center cursor-pointer">
                      <input type="checkbox" className="sr-only" checked={w.monitoringEnabled} onChange={() => onToggleMonitoring(w.id, !w.monitoringEnabled)} />
                      <span className={`w-10 h-6 ${w.monitoringEnabled ? 'bg-green-600' : 'bg-gray-600'} rounded-full relative inline-block`}>
                        <span className={`absolute left-1 top-1 w-4 h-4 rounded-full ${w.monitoringEnabled ? 'bg-green-500 translate-x-full' : 'bg-white'} transition-transform duration-300`}></span>
                      </span>
                    </label>
                  </td>
                  <td className="px-4 py-3">
                    <input
                      value={w.notes || ''}
                      onChange={e => onUpdate({ ...w, notes: e.target.value })}
                      className="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm"
                      placeholder="메모"
                    />
                  </td>
                  <td className="px-4 py-3 text-center">
                    <button onClick={() => onDelete(w.id)} className="p-2 text-red-400 hover:text-red-300" title="삭제">
                      <Trash2 className="h-5 w-5" />
                    </button>
                  </td>
                </tr>
              );
            }) : (
              <tr>
                <td colSpan={10} className="text-center py-8 text-gray-500">관심 종목을 추가해주세요.</td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
};

export default WatchlistPage;
</file>

<file path="services/priceService.ts">
import { AssetCategory, Currency, AssetDataResult, normalizeExchange } from '../types';

const STOCK_API_URL = 'https://asset-manager-887842923289.asia-northeast3.run.app';

function toNumber(v: any, fallback = 0): number {
  const n = Number(v);
  return isFinite(n) ? n : fallback;
}

function createMockResult(ticker: string): AssetDataResult {
  return {
    name: ticker,
    priceOriginal: 0,
    priceKRW: 0,
    currency: 'KRW',
    pricePreviousClose: 0,
    highestPrice: 0,
    isMocked: true,
  };
}

function extractByTickerKey(data: any, key?: string): any {
  if (!data) return undefined;
  if (Array.isArray(data?.results)) {
    if (!key) return data.results?.[0];
    const k = String(key).toUpperCase();
    return data.results.find((x: any) => String(x?.ticker ?? x?.symbol ?? '').toUpperCase() === k);
  }
  if (Array.isArray(data)) {
    if (!key) return data[0];
    const k = String(key).toUpperCase();
    return data.find((x: any) => String(x?.ticker ?? x?.symbol ?? '').toUpperCase() === k);
  }
  if (typeof data === 'object') {
    if (!key) {
      const firstKey = Object.keys(data)[0];
      return data[firstKey];
    }
    const k = String(key).toUpperCase();
    const direct = Object.prototype.hasOwnProperty.call(data, k) ? data[k] : undefined;
    if (direct) return direct;
    const alt = Object.keys(data).find((kk) => String(kk).toUpperCase() === k);
    return alt ? data[alt] : undefined;
  }
  return undefined;
}

async function fetchStocksBatch(payload: Array<{ ticker: string; exchange?: string }>): Promise<any> {
  console.log('fetchStocksBatch request', payload);
  const res = await fetch(STOCK_API_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ tickers: payload }),
  });
  if (!res.ok) {
    const text = await res.text().catch(() => '');
    throw new Error(`시세 서버 호출 실패: ${res.status} ${text}`);
  }
  try {
    const json = await res.json();
    console.log('fetchStocksBatch response', json);
    return json;
  } catch {
    const text = await res.text().catch(() => '');
    throw new Error(`시세 서버 응답 처리 실패: ${text}`);
  }
}

export async function fetchExchangeRate(): Promise<number> {
  try {
    const data = await fetchStocksBatch([{ ticker: 'USD/KRW', exchange: 'KRX' }]);
    const obj: any = extractByTickerKey(data, 'USD/KRW');
    console.log('fetchExchangeRate parsed', obj);
    const rate = toNumber(obj?.priceOriginal ?? obj?.price ?? obj?.close, 0);
    if (rate > 0) return rate;
    throw new Error('환율 데이터가 올바르지 않습니다');
  } catch (e) {
    throw e;
  }
}

export async function fetchExchangeRateJPY(): Promise<number> {
  try {
    const data = await fetchStocksBatch([{ ticker: 'JPY/KRW', exchange: 'KRX' }]);
    const obj: any = extractByTickerKey(data, 'JPY/KRW');
    console.log('fetchExchangeRateJPY parsed', obj);
    const rate = toNumber(obj?.priceOriginal ?? obj?.price ?? obj?.close, 0);
    if (rate > 0) return rate;
    throw new Error('엔화 환율 데이터가 올바르지 않습니다');
  } catch (e) {
    throw e;
  }
}

export async function fetchBatchAssetPrices(
  assets: { ticker: string; exchange: string; id: string; category?: AssetCategory; currency?: Currency }[],
): Promise<Map<string, AssetDataResult>> {
  const resultMap = new Map<string, AssetDataResult>();
  if (assets.length === 0) return resultMap;

  console.log('fetchBatchAssetPrices input assets', assets);

  try {
    const payload = assets.map(s => {
      const isCrypto = s.category === AssetCategory.CRYPTOCURRENCY;
      const reqTicker = isCrypto ? `${String(s.ticker).toUpperCase()}-USD` : String(s.ticker).toUpperCase();
      return { ticker: reqTicker, exchange: normalizeExchange(s.exchange) };
    });
    console.log('fetchBatchAssetPrices payload', payload);
    const data = await fetchStocksBatch(payload);
    console.log('fetchBatchAssetPrices raw response', data);

    const items: any[] = [];
    if (Array.isArray(data?.results)) {
      items.push(...data.results);
    } else if (Array.isArray(data)) {
      items.push(...data);
    } else if (typeof data === 'object' && data) {
      Object.keys(data).forEach(k => {
        const v = data[k];
        if (v && typeof v === 'object') items.push({ ...v, ticker: k });
      });
    }

    items.forEach((item: any) => {
      const ticker = String(item.ticker ?? item.symbol ?? '').toUpperCase();
      const normalizedTicker = ticker.endsWith('-USD') ? ticker.replace(/-USD$/i, '') : ticker;
      const matched = assets.find(a => a.ticker.toUpperCase() === normalizedTicker);
      if (!matched) return;
      const priceOrig = toNumber(item.priceOriginal ?? item.price ?? item.close, 0);
      const prev = toNumber(item.previousClose ?? item.prev_close ?? item.yesterdayPrice, priceOrig);
      const currencyFromServer = String(item.currency ?? matched.currency ?? Currency.USD);
      const keepOriginalCurrency = matched.category === AssetCategory.CRYPTOCURRENCY;
      const currency = keepOriginalCurrency ? String(matched.currency ?? currencyFromServer) : currencyFromServer;
      const priceKRW = typeof item.priceKRW === 'number'
        ? item.priceKRW
        : (currency === Currency.KRW ? priceOrig : priceOrig);
      const name = String(item.name ?? matched.ticker);
      const isMocked = !(priceOrig > 0);
      const result: AssetDataResult = {
        name,
        priceOriginal: priceOrig,
        priceKRW,
        currency,
        pricePreviousClose: prev,
        highestPrice: (currency === Currency.KRW ? priceKRW : priceOrig) * 1.1,
        isMocked,
      };
      resultMap.set(matched.id, result);
    });

    assets.forEach(s => {
      if (!resultMap.has(s.id)) resultMap.set(s.id, {
        name: s.ticker,
        priceOriginal: 0,
        priceKRW: 0,
        currency: String(s.currency ?? Currency.USD),
        pricePreviousClose: 0,
        highestPrice: 0,
        isMocked: true,
      });
    });
  } catch (e) {
    assets.forEach(s => resultMap.set(s.id, {
      name: s.ticker,
      priceOriginal: 0,
      priceKRW: 0,
      currency: String(s.currency ?? Currency.USD),
      pricePreviousClose: 0,
      highestPrice: 0,
      isMocked: true,
    }));
  }

  return resultMap;
}

export async function fetchAssetData(asset: { ticker: string; exchange: string; category?: AssetCategory; currency?: Currency }): Promise<AssetDataResult> {
  const normalizedExchange = normalizeExchange(asset.exchange);
  try {
    const isCrypto = asset.category === AssetCategory.CRYPTOCURRENCY;
    const reqTicker = isCrypto ? `${String(asset.ticker).toUpperCase()}-USD` : String(asset.ticker).toUpperCase();
    const data = await fetchStocksBatch([{ ticker: reqTicker, exchange: normalizedExchange }]);
    const obj: any = extractByTickerKey(data, reqTicker);
    console.log('fetchAssetData parsed', obj);
    const priceOrig = toNumber(obj?.priceOriginal ?? obj?.price ?? obj?.close, 0);
    const prev = toNumber(obj?.previousClose ?? obj?.prev_close ?? obj?.yesterdayPrice, priceOrig);
    const currency = String(obj?.currency ?? asset.currency ?? Currency.USD);
    const priceKRW = typeof obj?.priceKRW === 'number'
      ? obj.priceKRW
      : (currency === Currency.KRW ? priceOrig : priceOrig);
    const name = String(obj?.name ?? asset.ticker);
    return {
      name,
      priceOriginal: priceOrig,
      priceKRW,
      currency,
      pricePreviousClose: prev,
      highestPrice: (currency === Currency.KRW ? priceKRW : priceOrig) * 1.1,
      isMocked: false,
    };
  } catch {
    throw new Error('시세 데이터를 가져오지 못했습니다. 잠시 후 다시 시도해주세요.');
  }
}
</file>

<file path="components/EditAssetModal.tsx">
import React, { useState, useEffect, useMemo } from 'react';
import { Asset, AssetCategory, Currency, ALL_EXCHANGES, inferCategoryFromExchange, ALLOWED_CATEGORIES, normalizeExchange } from '../types';
import { searchSymbols } from '../services/geminiService';

interface EditAssetModalProps {
  asset: Asset | null;
  isOpen: boolean;
  onClose: () => void;
  onSave: (asset: Asset) => void;
  onDelete: (assetId: string) => void;
  isLoading: boolean;
}

const EditAssetModal: React.FC<EditAssetModalProps> = ({ asset, isOpen, onClose, onSave, onDelete, isLoading }) => {
  const [formData, setFormData] = useState<Asset | null>(null);
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [searchResults, setSearchResults] = useState<{ ticker: string; name: string; exchange: string }[]>([]);
  const [isSearching, setIsSearching] = useState<boolean>(false);
  const categoryOptions = useMemo(() => {
    if (!formData) return ALLOWED_CATEGORIES;
    return ALLOWED_CATEGORIES.includes(formData.category)
      ? ALLOWED_CATEGORIES
      : [formData.category, ...ALLOWED_CATEGORIES];
  }, [formData]);

  useEffect(() => {
    if (asset) {
        setFormData({
            ...asset,
            purchaseDate: new Date(asset.purchaseDate).toISOString().slice(0, 10)
        });
        setSearchQuery('');
        setSearchResults([]);
        setIsSearching(false);
    }
  }, [asset]);

  if (!isOpen || !formData) return null;
  
  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData(prev => {
        if (!prev) return null;

        let newValue: any = value;
        if (name === 'quantity' || name === 'purchasePrice') {
            newValue = parseFloat(value) || 0;
        } else if (name === 'sellAlertDropRate') {
            newValue = value === '' ? undefined : parseFloat(value);
            if (isNaN(newValue as number)) newValue = undefined;
        }

        return { ...prev, [name]: newValue };
    });
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (formData) {
      onSave(formData);
    }
  };

  const handleSearchChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const q = e.target.value;
    setSearchQuery(q);
    if (!q || q.length < 2) {
      setSearchResults([]);
      return;
    }
    setIsSearching(true);
    try {
      const results = await searchSymbols(q);
      setSearchResults(results);
    } catch {
      setSearchResults([]);
    } finally {
      setIsSearching(false);
    }
  };

  const applySymbol = (r: { ticker: string; name: string; exchange: string }) => {
    const ex = normalizeExchange(r.exchange);
    const cat = inferCategoryFromExchange(ex);
    setFormData(prev => {
      if (!prev) return null;
      const current = (prev.ticker || '').trim();
      let nextTicker = current;
      const ok = window.confirm(`티커를 '${current || '(비어있음)'}'에서 '${r.ticker}'로 변경하시겠습니까?`);
      if (ok) nextTicker = r.ticker;
      return { ...prev, ticker: nextTicker, name: r.name, exchange: ex, category: cat };
    });
    setSearchQuery('');
    setSearchResults([]);
  };

  const handleDelete = () => {
    if (asset && window.confirm(`'${(asset.customName?.trim() || asset.name)}' 자산을 정말 삭제하시겠습니까?\n이 작업은 되돌릴 수 없습니다.`)) {
      onDelete(asset.id);
    }
  };

  const inputClasses = "w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition";
  const labelClasses = "block text-sm font-medium text-gray-300 mb-1";

  return (
    <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-50" onClick={onClose} role="dialog" aria-modal="true">
      <div className="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-lg" onClick={(e) => e.stopPropagation()}>
        <h2 className="text-2xl font-bold text-white mb-6">자산 수정: {(asset?.customName?.trim() || asset?.name)}</h2>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="category-edit" className={labelClasses}>자산 구분</label>
            <select id="category-edit" name="category" value={formData.category} onChange={handleChange} className={inputClasses}>
              {categoryOptions.map((cat) => (
                <option key={cat} value={cat}>{cat}</option>
              ))}
            </select>
          </div>
          <div>
            <label htmlFor="customName-edit" className={labelClasses}>표시용 종목명 (사용자 지정)</label>
            <input
              id="customName-edit"
              name="customName"
              type="text"
              value={formData.customName || ''}
              onChange={handleChange}
              className={inputClasses}
              placeholder="비워두면 공식 종목명을 사용합니다"
            />
            <p className="text-xs text-gray-400 mt-1">티커/거래소·가격 계산에는 영향이 없고 화면 표시 및 내보내기에만 적용됩니다.</p>
          </div>
           <div className="grid grid-cols-2 gap-4">
            <div>
              <label className={labelClasses}>거래소/시장</label>
              <input value={formData.exchange} readOnly className="w-full bg-gray-600 border border-gray-500 rounded-md py-2 px-3 text-gray-300 cursor-not-allowed" />
            </div>
            <div>
              <label htmlFor="ticker-edit" className={labelClasses}>티커 (종목코드)</label>
              <input id="ticker-edit" name="ticker" type="text" value={formData.ticker} onChange={handleChange} className={inputClasses} required />
              <div className="mt-2">
                <label htmlFor="ticker-search" className={labelClasses}>티커/종목 검색</label>
                <input id="ticker-search" type="text" value={searchQuery} onChange={handleSearchChange} placeholder="예: BMNR 또는 회사명" className={inputClasses} />
                {isSearching && <p className="text-xs text-gray-400 mt-1">검색 중...</p>}
                {searchResults.length > 0 && (
                  <ul className="mt-1 bg-gray-700 border border-gray-600 rounded-md max-h-40 overflow-y-auto">
                    {searchResults.map((r) => (
                      <li key={`${r.ticker}-${r.exchange}`} className="px-3 py-2 cursor-pointer hover:bg-gray-600" onMouseDown={() => applySymbol(r)}>
                        <div className="text-white font-semibold">{r.name} ({r.ticker})</div>
                        <div className="text-xs text-gray-300">{r.exchange}</div>
                      </li>
                    ))}
                  </ul>
                )}
              </div>
            </div>
          </div>
          <div className="grid grid-cols-3 gap-4">
            <div>
              <label htmlFor="quantity-edit" className={labelClasses}>수량</label>
              <input id="quantity-edit" name="quantity" type="number" value={formData.quantity} onChange={handleChange} className={inputClasses} required min="0" step="any" />
            </div>
            <div>
              <label htmlFor="purchasePrice-edit" className={labelClasses}>매수가</label>
              <input id="purchasePrice-edit" name="purchasePrice" type="number" value={formData.purchasePrice} onChange={handleChange} className={inputClasses} required min="0" step="any" />
            </div>
            <div>
              <label htmlFor="currency-edit" className={labelClasses}>매수 통화</label>
              <select id="currency-edit" name="currency" value={formData.currency} onChange={handleChange} className={inputClasses}>
                  {Object.values(Currency).map((cur) => (
                    <option key={cur} value={cur}>{cur}</option>
                  ))}
              </select>
            </div>
          </div>
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label htmlFor="purchaseDate-edit" className={labelClasses}>매수일</label>
              <input id="purchaseDate-edit" name="purchaseDate" type="date" value={formData.purchaseDate} onChange={handleChange} className={inputClasses} required />
            </div>
            <div>
                <label htmlFor="sellAlertDropRate-edit" className={labelClasses}>
                    개별 매도 알림률 (%)
                </label>
                <input
                    id="sellAlertDropRate-edit"
                    name="sellAlertDropRate"
                    type="number"
                    placeholder="기본값 사용"
                    value={formData.sellAlertDropRate ?? ''}
                    onChange={handleChange}
                    className={inputClasses}
                    min="0"
                    step="1"
                    title="비워두면 전역 설정을 따릅니다."
                />
            </div>
          </div>
          <div>
            <label htmlFor="memo-edit" className={labelClasses}>메모</label>
            <textarea
              id="memo-edit"
              name="memo"
              value={formData.memo || ''}
              onChange={handleChange}
              className={inputClasses}
              rows={3}
              placeholder="종목에 대한 메모를 입력하세요..."
            />
          </div>
          
          <div className="mt-8 flex justify-between items-center pt-4">
            <button
              type="button"
              onClick={handleDelete}
              disabled={isLoading}
              className="bg-danger hover:bg-red-600 text-white font-medium py-2 px-4 rounded-md transition duration-300 disabled:bg-gray-600 disabled:cursor-not-allowed"
            >
              삭제
            </button>
            <div className="flex space-x-4">
              <button type="button" onClick={onClose} className="bg-gray-600 hover:bg-gray-500 text-white font-medium py-2 px-4 rounded-md transition duration-300">
                취소
              </button>
              <button type="submit" disabled={isLoading} className="bg-primary hover:bg-primary-dark text-white font-bold py-2 px-4 rounded-md disabled:bg-gray-600 disabled:cursor-not-allowed transition duration-300 flex items-center justify-center">
                {isLoading ? (
                  <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                ) : '저장'}
              </button>
            </div>
          </div>
        </form>
      </div>
    </div>
  );
};

export default EditAssetModal;
</file>

<file path="components/AddNewAssetModal.tsx">
import React, { useState, useEffect, useCallback } from 'react';
import { Asset, AssetCategory, NewAssetForm, EXCHANGE_MAP, Currency, SymbolSearchResult, ALL_EXCHANGES, inferCategoryFromExchange, ALLOWED_CATEGORIES, normalizeExchange } from '../types';
import { searchSymbols } from '../services/geminiService';

interface AddNewAssetModalProps {
  isOpen: boolean;
  onClose: () => void;
  onAddAsset: (asset: NewAssetForm) => void;
  isLoading: boolean;
  assets: Asset[];
}

const AddNewAssetModal: React.FC<AddNewAssetModalProps> = ({ isOpen, onClose, onAddAsset, isLoading, assets }) => {
  const [ticker, setTicker] = useState('');
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<SymbolSearchResult[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [isFocused, setIsFocused] = useState(false);
  const [duplicateError, setDuplicateError] = useState<string | null>(null);
  
  const [quantity, setQuantity] = useState('');
  const [purchasePrice, setPurchasePrice] = useState('');
  const [purchaseDate, setPurchaseDate] = useState(new Date().toISOString().slice(0, 10));
  const [category, setCategory] = useState<AssetCategory>(AssetCategory.US_STOCK);
  const initialExchange = EXCHANGE_MAP[AssetCategory.US_STOCK]?.[0] || ALL_EXCHANGES[0] || '';
  const [exchange, setExchange] = useState<string>(initialExchange);
  const [currency, setCurrency] = useState<Currency>(Currency.USD);

  const clearForm = useCallback(() => {
    setTicker('');
    setSearchQuery('');
    setQuantity('');
    setPurchasePrice('');
    setSearchResults([]);
    setCategory(AssetCategory.US_STOCK);
    setExchange(initialExchange);
    setPurchaseDate(new Date().toISOString().slice(0, 10));
    setCurrency(Currency.USD);
    setDuplicateError(null);
  }, [initialExchange]);

  useEffect(() => {
    if (!isOpen) {
      clearForm();
    }
  }, [isOpen, clearForm]);


  const handleSearchChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const newQuery = e.target.value;
    setSearchQuery(newQuery);
    if (ticker) {
      setTicker('');
    }
    setDuplicateError(null);
  }, [ticker]);

  useEffect(() => {
    if (searchQuery.length < 2 || searchQuery === ticker) {
      setSearchResults([]);
      return;
    }

    const handler = setTimeout(async () => {
      setIsSearching(true);
      try {
        const results = await searchSymbols(searchQuery);
        setSearchResults(results);
      } catch (error) {
        console.error("Search failed:", error);
        setSearchResults([]);
      } finally {
        setIsSearching(false);
      }
    }, 300);

    return () => { clearTimeout(handler); };
  }, [searchQuery, ticker]);

  const handleSelectSymbol = (result: SymbolSearchResult) => {
     const isDuplicate = assets.some(
      asset => asset.ticker.toUpperCase() === result.ticker.toUpperCase() &&
               normalizeExchange(asset.exchange) === normalizeExchange(result.exchange)
    );

    if (isDuplicate) {
      setDuplicateError('이미 포트폴리오에 존재하는 자산입니다.');
    } else {
      setDuplicateError(null);
    }
    setSearchResults([]);
    const current = (ticker || '').trim();
    let nextTicker = current;
    if (!current) {
      nextTicker = result.ticker;
    } else {
      const ok = window.confirm(`티커를 '${current}'에서 '${result.ticker}'로 변경하시겠습니까?`);
      if (ok) nextTicker = result.ticker;
    }
    setTicker(nextTicker);
    setSearchQuery(result.name);
    setExchange(normalizeExchange(result.exchange));

    // 거래소에서 자산구분 자동 추론
    const inferredCategory = inferCategoryFromExchange(normalizeExchange(result.exchange));
    setCategory(inferredCategory);
    
    setSearchResults([]);
  };

  useEffect(() => {
    if (category === AssetCategory.KOREAN_STOCK) {
      setExchange('KRX (코스피/코스닥)');
    } else if (category === AssetCategory.US_STOCK) {
      setExchange('NASDAQ');
    } else if (category === AssetCategory.CRYPTOCURRENCY) {
      setExchange('주요 거래소 (종합)');
    }
  }, [category]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!ticker) {
      alert('종목 검색을 통해 유효한 자산을 선택해주세요.');
      return;
    }
    if (!quantity || !purchasePrice || !purchaseDate || !exchange || !currency || !category) {
      alert('모든 필드를 입력해주세요.');
      return;
    }
    const isDuplicateSubmit = assets.some(
      asset => asset.ticker.toUpperCase() === ticker.toUpperCase() &&
               normalizeExchange(asset.exchange) === normalizeExchange(exchange)
    );
    if (isDuplicateSubmit) {
      alert('이미 포트폴리오에 존재하는 자산입니다.');
      return;
    }
    onAddAsset({
      ticker,
      quantity: parseFloat(quantity),
      purchasePrice: parseFloat(purchasePrice),
      purchaseDate,
      category,
      exchange,
      currency
    });
  };
  
  const inputClasses = "w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition";
  const labelClasses = "block text-sm font-medium text-gray-300 mb-1";
  const showResults = isFocused && searchResults.length > 0;

  if (!isOpen) return null;

  return (
     <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-50" onClick={onClose} role="dialog" aria-modal="true">
      <div className="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-lg" onClick={(e) => e.stopPropagation()}>
        <div className="flex justify-between items-center mb-6">
            <h2 className="text-2xl font-bold text-white">신규 자산 추가</h2>
            <button onClick={onClose} className="text-gray-400 hover:text-white transition">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
        <form onSubmit={handleSubmit} className="space-y-4">
            <div>
                <label htmlFor="category" className={labelClasses}>자산 구분</label>
                <select 
                  id="category" 
                  value={category} 
                  onChange={(e) => setCategory(e.target.value as AssetCategory)} 
                  className={inputClasses} 
                  title="자산의 구분을 선택하세요. 거래소 선택 시 자동으로 설정되며 수동으로 변경할 수 있습니다."
                >
                  {ALLOWED_CATEGORIES.map((cat) => (
                    <option key={cat} value={cat}>{cat}</option>
                  ))}
                </select>
            </div>
            <div>
                <label className={labelClasses}>거래소/시장</label>
                <input value={exchange} readOnly className="w-full bg-gray-600 border border-gray-500 rounded-md py-2 px-3 text-gray-300 cursor-not-allowed" title="자산구분 또는 종목 검색에 따라 자동으로 결정됩니다." />
            </div>
            
            <div className="relative">
            <label htmlFor="ticker-search" className={labelClasses}>티커 (종목 검색)</label>
            <input 
                id="ticker-search" 
                type="text" 
                value={searchQuery} 
                onChange={handleSearchChange} 
                onFocus={() => setIsFocused(true)}
                onBlur={() => setTimeout(() => setIsFocused(false), 150)} // Delay to allow click on results
                placeholder="예: Apple, 삼성전자"
                className={inputClasses}
                required 
                autoComplete="off"
                title="자산의 이름 또는 티커를 입력하여 검색하세요."
            />
            {duplicateError && <p className="text-danger text-sm mt-1">{duplicateError}</p>}
            {isSearching && (
                <div className="absolute top-9 right-3">
                    <svg className="animate-spin h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8_0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </div>
            )}
            {showResults && (
                <ul className="absolute z-10 w-full bg-gray-700 border border-gray-600 rounded-md mt-1 max-h-60 overflow-y-auto shadow-lg">
                {searchResults.map((result) => (
                    <li 
                    key={`${result.ticker}-${result.exchange}`} 
                    onMouseDown={() => handleSelectSymbol(result)} 
                    className="px-3 py-2 cursor-pointer hover:bg-primary-dark transition-colors"
                    role="option"
                    aria-selected="false"
                    >
                    <div className="font-bold text-white">{result.name} ({result.ticker})</div>
                    <div className="text-sm text-gray-400">{result.exchange}</div>
                    </li>
                ))}
                </ul>
            )}
            </div>

            <div className="grid grid-cols-3 gap-4">
            <div>
                <label htmlFor="quantity" className={labelClasses}>수량</label>
                <input id="quantity" type="number" value={quantity} onChange={(e) => setQuantity(e.target.value)} placeholder="10" className={inputClasses} required min="0" step="any" title="보유하고 있는 자산의 수량을 입력하세요."/>
            </div>
            <div>
                <label htmlFor="purchasePrice" className={labelClasses}>매수가</label>
                <input id="purchasePrice" type="number" value={purchasePrice} onChange={(e) => setPurchasePrice(e.target.value)} placeholder="150.00" className={inputClasses} required min="0" step="any" title="자산을 매수한 평균 단가를 선택한 통화 기준으로 입력하세요." />
            </div>
            <div>
                <label htmlFor="currency" className={labelClasses}>통화</label>
                <select id="currency" value={currency} onChange={(e) => setCurrency(e.target.value as Currency)} className={inputClasses} title="매수 가격의 통화 단위를 선택하세요.">
                    {Object.values(Currency).map((cur) => (
                    <option key={cur} value={cur}>{cur}</option>
                    ))}
                </select>
            </div>
            </div>
            <div>
            <label htmlFor="purchaseDate" className={labelClasses}>매수/보유 시작일</label>
            <input id="purchaseDate" type="date" value={purchaseDate} onChange={(e) => setPurchaseDate(e.target.value)} className={inputClasses} required title="자산을 매수했거나 보유하기 시작한 날짜를 선택하세요."/>
            </div>
            <div className="pt-4 flex justify-end">
                <button type="submit" disabled={isLoading || !!duplicateError} className="w-full bg-primary hover:bg-primary-dark text-white font-bold py-2.5 px-4 rounded-md disabled:bg-gray-600 disabled:cursor-not-allowed transition duration-300 flex items-center justify-center" title="입력한 정보로 새 자산을 포트폴리오에 추가합니다.">
                {isLoading ? (
                    <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                ) : '자산 추가'}
                </button>
            </div>
        </form>
      </div>
    </div>
  );
};

export default AddNewAssetModal;
</file>

<file path="types.ts">
export enum AssetCategory {
  KOREAN_STOCK = "한국주식",
  US_STOCK = "미국주식",
  FOREIGN_STOCK = "해외주식",
  OTHER_FOREIGN_STOCK = "기타해외주식",
  KOREAN_BOND = "한국채권",
  US_BOND = "미국채권",
  PHYSICAL_ASSET = "실물자산",
  CRYPTOCURRENCY = "암호화폐",
  CASH = "현금",
}

export enum Currency {
    KRW = "KRW",
    USD = "USD",
    JPY = "JPY",
    CNY = "CNY",
}

export const CURRENCY_SYMBOLS: Record<Currency, string> = {
    [Currency.KRW]: "₩",
    [Currency.USD]: "$",
    [Currency.JPY]: "¥",
    [Currency.CNY]: "¥",
};

export interface ExchangeRates {
  USD: number;
  JPY: number;
}

export const COMMON_EXCHANGES: string[] = [
  "KRX (코스피/코스닥)",
  "KONEX",
  "NASDAQ",
  "NYSE",
  "TSE (도쿄)",
  "SSE (상하이)",
  "HKEX (홍콩)",
  "KRX 금시장",
  "COMEX",
  "NYMEX",
  "주요 거래소 (종합)"
];

export const ALL_EXCHANGES: string[] = [
  "KRX (코스피/코스닥)",
  "KONEX",
  "NASDAQ",
  "NYSE",
  "AMEX",
  "NYSE American",
  "TSE (도쿄)",
  "SSE (상하이)",
  "SZSE (선전)",
  "HKEX (홍콩)",
  "KRX 금시장",
  "COMEX",
  "LBMA",
  "NYMEX",
  "CME",
  "ICE",
  "주요 거래소 (종합)"
];

export const inferCategoryFromExchange = (exchange: string): AssetCategory => {
  if (exchange.includes('KRX') || exchange.includes('KONEX')) {
    return AssetCategory.KOREAN_STOCK;
  } else if (['NASDAQ', 'NYSE', 'AMEX', 'NYSE American'].includes(exchange)) {
    return AssetCategory.US_STOCK;
  } else if (exchange.includes('TSE') || exchange.includes('도쿄')) {
    return AssetCategory.FOREIGN_STOCK;
  } else if (exchange.includes('SSE') || exchange.includes('SZSE') || exchange.includes('HKEX') || exchange.includes('상하이') || exchange.includes('선전') || exchange.includes('홍콩')) {
    return AssetCategory.FOREIGN_STOCK;
  } else if (exchange.includes('국채')) {
    if (exchange.includes('한국') || exchange.includes('대한민국')) {
      return AssetCategory.KOREAN_BOND;
    } else if (exchange.includes('미국')) {
      return AssetCategory.US_BOND;
    }
  } else if (exchange.includes('금') || exchange.includes('COMEX') || exchange.includes('LBMA') || exchange.includes('NYMEX') || exchange.includes('CME') || exchange.includes('ICE')) {
    return AssetCategory.PHYSICAL_ASSET;
  } else if (exchange.includes('거래소 (종합)')) {
    return AssetCategory.CRYPTOCURRENCY;
  }
  return AssetCategory.OTHER_FOREIGN_STOCK;
};

export const EXCHANGE_MAP: Record<string, string[]> = {
    [AssetCategory.KOREAN_STOCK]: ["KRX (코스피/코스닥)", "KONEX"],
    [AssetCategory.US_STOCK]: ["NASDAQ", "NYSE", "AMEX", "NYSE American"],
    [AssetCategory.FOREIGN_STOCK]: ["TSE (도쿄)", "SSE (상하이)", "SZSE (선전)", "HKEX (홍콩)"],
    [AssetCategory.OTHER_FOREIGN_STOCK]: ["TSE (도쿄)", "SSE (상하이)", "SZSE (선전)", "HKEX (홍콩)"],
    [AssetCategory.KOREAN_BOND]: ["대한민국 국채"],
    [AssetCategory.US_BOND]: ["미국 국채"],
    [AssetCategory.PHYSICAL_ASSET]: ["KRX 금시장", "COMEX", "LBMA", "NYMEX", "CME", "ICE"],
    [AssetCategory.CRYPTOCURRENCY]: ["주요 거래소 (종합)"],
    [AssetCategory.CASH]: ["현금"],
};

export const ALLOWED_CATEGORIES: AssetCategory[] = [
  AssetCategory.KOREAN_STOCK,
  AssetCategory.US_STOCK,
  AssetCategory.OTHER_FOREIGN_STOCK,
  AssetCategory.KOREAN_BOND,
  AssetCategory.US_BOND,
  AssetCategory.CRYPTOCURRENCY,
  AssetCategory.PHYSICAL_ASSET,
];

export interface WatchlistItem {
  id: string;
  ticker: string;
  exchange: string;
  name: string;
  category: AssetCategory;
  monitoringEnabled: boolean;
  notes?: string;
  buyZoneMin?: number;
  buyZoneMax?: number;
  dropFromHighThreshold?: number;
  currentPrice?: number;
  priceOriginal?: number;
  currency?: Currency;
  yesterdayPrice?: number;
  highestPrice?: number;
  lastSignalAt?: string;
  lastSignalType?: 'BUY_ZONE' | 'DROP_FROM_HIGH' | 'DAILY_DROP' | null;
}

export interface SellTransaction {
  id: string;
  sellDate: string;
  sellPrice: number;
  sellPriceOriginal?: number;
  sellQuantity: number;
  sellExchangeRate?: number;
  settlementCurrency?: Currency;
  sellPriceSettlement?: number;
}

export interface SellRecord extends SellTransaction {
  assetId: string;
  ticker: string;
  name: string;
  category: AssetCategory;
}

export interface Asset {
  id: string;
  category: AssetCategory;
  ticker: string;
  exchange: string;
  name: string;
  customName?: string;
  quantity: number;
  purchasePrice: number;
  purchaseDate: string;
  currency: Currency;
  purchaseExchangeRate?: number;
  currentPrice: number;
  priceOriginal: number;
  highestPrice: number;
  yesterdayPrice?: number;
  sellAlertDropRate?: number;
  memo?: string;
  sellTransactions?: SellTransaction[];
}

export type NewAssetForm = Omit<Asset, 'id' | 'name' | 'currentPrice' | 'priceOriginal' | 'highestPrice' | 'purchaseExchangeRate'>;

export interface SymbolSearchResult {
  ticker: string;
  name: string;
  exchange: string;
}

export interface BulkUploadResult {
  successCount: number;
  failedCount: number;
  errors: { ticker: string; reason: string }[];
}

export interface AssetSnapshot {
  id: string;
  name: string;
  currentValue: number;
  purchaseValue: number;
  unitPrice?: number; // [추가] 1주당 단가 (원화 환산 기준 권장)
}

export interface PortfolioSnapshot {
  date: string;
  assets: AssetSnapshot[];
}

export const normalizeExchange = (exchange: string): string => {
  const e = exchange.trim();
  if (e.toUpperCase() === 'AMEX' || e.toUpperCase() === 'NYSE MKT') return 'NYSE American';
  if (e.toUpperCase() === 'NYSE AMERICAN') return 'NYSE American';
  return e;
};

export interface AssetDataResult {
  name: string;
  priceOriginal: number;
  priceKRW: number;
  currency: string;
  pricePreviousClose: number;
  highestPrice?: number;
  isMocked: boolean;
}
</file>

<file path="components/PortfolioTable.tsx">
import React, { useMemo, useState, Fragment, useRef, useEffect } from 'react';
import { Asset, Currency, CURRENCY_SYMBOLS, AssetCategory, PortfolioSnapshot, ALLOWED_CATEGORIES, ExchangeRates } from '../types';
import AssetTrendChart from './AssetTrendChart';
import { MoreHorizontal } from 'lucide-react';
import { useOnClickOutside } from '../hooks/useOnClickOutside';

interface PortfolioTableProps {
  assets: Asset[];
  history: PortfolioSnapshot[];
  onRefreshAll: () => void;
  onRefreshSelected?: (ids: string[]) => void | Promise<void>;
  onRefreshOne?: (id: string) => void | Promise<void>;
  onEdit: (asset: Asset) => void;
  onSell?: (asset: Asset) => void;
  isLoading: boolean;
  sellAlertDropRate: number;
  filterCategory: AssetCategory | 'ALL';
  onFilterChange: (category: AssetCategory | 'ALL') => void;
  filterAlerts: boolean;
  onFilterAlertsChange: (isActive: boolean) => void;
  searchQuery?: string;
  onSearchChange?: (query: string) => void;
  onAddSelectedToWatchlist?: (assets: Asset[]) => void;
  failedIds?: Set<string>;
  exchangeRates: ExchangeRates;
}

type SortKey = 'name' | 'purchaseDate' | 'quantity' | 'purchasePrice' | 'currentPrice' | 'returnPercentage' | 'dropFromHigh' | 'yesterdayChange' | 'purchaseValue' | 'currentValue' | 'allocation' | 'profitLoss' | 'profitLossKRW';
type SortDirection = 'ascending' | 'descending';

// [헬퍼] 원화 환산 함수
const getValueInKRW = (
  value: number, 
  currency: Currency, 
  exchangeRates: ExchangeRates
): number => {
  switch (currency) {
    case Currency.USD: return value * (exchangeRates.USD || 0);
    case Currency.JPY: return value * (exchangeRates.JPY || 0);
    case Currency.KRW: default: return value;
  }
};

const PortfolioTable: React.FC<PortfolioTableProps> = ({ 
  assets, 
  history, 
  onRefreshAll, 
  onRefreshSelected, 
  onRefreshOne, 
  onEdit, 
  onSell, 
  isLoading, 
  sellAlertDropRate, 
  filterCategory, 
  onFilterChange, 
  filterAlerts, 
  onFilterAlertsChange, 
  searchQuery = '', 
  onSearchChange, 
  onAddSelectedToWatchlist, 
  failedIds,
  exchangeRates 
}) => {
  const [sortConfig, setSortConfig] = useState<{ key: SortKey; direction: SortDirection } | null>(null);
  const [expandedAssetId, setExpandedAssetId] = useState<string | null>(null);
  const [showHiddenColumns, setShowHiddenColumns] = useState<boolean>(false);
  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());
  const [showFailedOnly, setShowFailedOnly] = useState<boolean>(false);
  const [openMenuId, setOpenMenuId] = useState<string | null>(null);
  const menuRef = useRef<HTMLDivElement | null>(null);
  const prevLoadingRef = useRef<boolean>(false);
  const [lastRunWasFullUpdate, setLastRunWasFullUpdate] = useState<boolean>(false);

  useOnClickOutside(menuRef, () => setOpenMenuId(null), !!openMenuId);

  // 총 자산 가치 계산 (비중 계산용)
  const totalValueKRW = useMemo(() => {
    return assets.reduce((sum, asset) => {
      const valueInOriginalCurrency = asset.currentPrice * asset.quantity;
      return sum + getValueInKRW(valueInOriginalCurrency, asset.currency, exchangeRates);
    }, 0);
  }, [assets, exchangeRates]);

  const handleToggleExpand = (assetId: string) => {
    setExpandedAssetId(prevId => (prevId === assetId ? null : assetId));
  };
  
  const categoryOptions = useMemo(() => {
    const extras = Array.from(new Set(assets.map(asset => asset.category))).filter(
      (cat) => !ALLOWED_CATEGORIES.includes(cat) && cat !== AssetCategory.FOREIGN_STOCK
    );
    return [...ALLOWED_CATEGORIES, ...extras];
  }, [assets]);

  // [핵심] 데이터 가공 및 정렬 로직 (원화 환산 정렬 포함)
  const enrichedAndSortedAssets = useMemo(() => {
    let enriched = assets.map(asset => {
      const currentValue = asset.currentPrice * asset.quantity;
      const purchaseValue = asset.purchasePrice * asset.quantity;
      
      const profitLoss = currentValue - purchaseValue;
      const returnPercentage = purchaseValue === 0 ? 0 : (profitLoss / purchaseValue) * 100;
      
      const currentValueKRW = getValueInKRW(currentValue, asset.currency, exchangeRates);
      const purchaseValueKRW = getValueInKRW(purchaseValue, asset.currency, exchangeRates);
      const profitLossKRW = currentValueKRW - purchaseValueKRW;
      
      // [정렬용] 원화 환산 단가
      const currentPriceKRW = getValueInKRW(asset.currentPrice, asset.currency, exchangeRates);
      const purchasePriceKRW = getValueInKRW(asset.purchasePrice, asset.currency, exchangeRates);

      const allocation = totalValueKRW === 0 ? 0 : (currentValueKRW / totalValueKRW) * 100;
      const dropFromHigh = asset.highestPrice === 0 ? 0 : ((asset.currentPrice - asset.highestPrice) / asset.highestPrice) * 100;
      const diffFromHigh = asset.currentPrice - asset.highestPrice;
      
      const yesterdayPrice = asset.yesterdayPrice || 0;
      const yesterdayChange = yesterdayPrice > 0 ? ((asset.currentPrice - yesterdayPrice) / yesterdayPrice) * 100 : 0;
      const diffFromYesterday = yesterdayPrice > 0 ? asset.currentPrice - yesterdayPrice : 0;
      
      return {
        ...asset,
        metrics: {
          purchasePrice: asset.purchasePrice,
          currentPrice: asset.currentPrice,
          // 정렬을 위해 KRW 환산가 추가
          currentPriceKRW,
          purchasePriceKRW,
          purchaseValue, currentValue, purchaseValueKRW, currentValueKRW,
          returnPercentage, allocation, dropFromHigh, profitLoss, profitLossKRW,
          diffFromHigh, yesterdayChange, diffFromYesterday,
        }
      };
    });

    // 필터링
    if (filterAlerts) {
      enriched = enriched.filter(asset => {
        const alertRate = asset.sellAlertDropRate ?? sellAlertDropRate;
        return asset.metrics.dropFromHigh <= -alertRate;
      });
    }

    if (showFailedOnly && failedIds && failedIds.size > 0) {
      enriched = enriched.filter(asset => failedIds.has(asset.id));
    }

    // 정렬 로직
    if (sortConfig !== null) {
      enriched.sort((a, b) => {
        const { key, direction } = sortConfig;
        let aValue: any, bValue: any;

        if (key === 'name') {
          aValue = (a.customName?.toLowerCase() || a.name.toLowerCase());
          bValue = (b.customName?.toLowerCase() || b.name.toLowerCase());
        } else if (key === 'purchaseDate') {
          aValue = a.purchaseDate; bValue = b.purchaseDate;
        } else if (key === 'quantity') {
          aValue = a.quantity; bValue = b.quantity;
        } else if (key === 'currentPrice') {
          // [수정] 원화 기준 정렬
          aValue = a.metrics.currentPriceKRW;
          bValue = b.metrics.currentPriceKRW;
        } else if (key === 'purchasePrice') {
          // [수정] 원화 기준 정렬
          aValue = a.metrics.purchasePriceKRW;
          bValue = b.metrics.purchasePriceKRW;
        } else if (key === 'currentValue') {
           aValue = a.metrics.currentValueKRW;
           bValue = b.metrics.currentValueKRW;
        } else if (key === 'purchaseValue') {
           aValue = a.metrics.purchaseValueKRW;
           bValue = b.metrics.purchaseValueKRW;
        } else {
          aValue = a.metrics[key as keyof typeof a.metrics];
          bValue = b.metrics[key as keyof typeof b.metrics];
        }

        if (aValue < bValue) return direction === 'ascending' ? -1 : 1;
        if (aValue > bValue) return direction === 'ascending' ? 1 : -1;
        return 0;
      });
    }

    return enriched;
  }, [assets, sortConfig, totalValueKRW, exchangeRates, filterAlerts, sellAlertDropRate, showFailedOnly, failedIds]);

  const allSelected = enrichedAndSortedAssets.length > 0 && enrichedAndSortedAssets.every(a => selectedIds.has(a.id));
  const selectedAssets = useMemo(() => assets.filter(a => selectedIds.has(a.id)), [assets, selectedIds]);

  const requestSort = (key: SortKey) => {
    let direction: SortDirection = 'ascending';
    if (sortConfig && sortConfig.key === key && sortConfig.direction === 'ascending') {
      direction = 'descending';
    }
    setSortConfig({ key, direction });
  };
  
  const toggleReturnSort = () => {
    const s = sortConfig;
    if (!s || (s.key !== 'returnPercentage' && s.key !== 'profitLossKRW')) {
      setSortConfig({ key: 'returnPercentage', direction: 'descending' });
      return;
    }
    if (s.key === 'returnPercentage' && s.direction === 'descending') {
      setSortConfig({ key: 'returnPercentage', direction: 'ascending' });
      return;
    }
    if (s.key === 'returnPercentage' && s.direction === 'ascending') {
      setSortConfig({ key: 'profitLossKRW', direction: 'descending' });
      return;
    }
    if (s.key === 'profitLossKRW' && s.direction === 'descending') {
      setSortConfig({ key: 'profitLossKRW', direction: 'ascending' });
      return;
    }
    setSortConfig(null);
  };
  
  const getReturnHeaderLabel = () => {
    if (!sortConfig) return '수익률';
    if (sortConfig.key === 'returnPercentage') return `수익률 ${sortConfig.direction === 'descending' ? '▼' : '▲'}`;
    if (sortConfig.key === 'profitLossKRW') return `평가손익 ${sortConfig.direction === 'descending' ? '▼' : '▲'}`;
    return '수익률';
  };
  
  // [수정] 포맷팅 함수들 (소수점 제거)
  const formatNumber = (num: number) => new Intl.NumberFormat('ko-KR', { maximumFractionDigits: 0 }).format(num);
  const formatKRW = (num: number) => new Intl.NumberFormat('ko-KR', { style: 'currency', currency: 'KRW', maximumFractionDigits: 0 }).format(num);

  const formatOriginalCurrency = (num: number, currency: Currency) => {
    // 외화 표시 시에도 리스트에서는 깔끔하게 정수로 표현하거나, 필요시 소수점 유지 (여기서는 사용자 요청대로 소수점 제거 적용)
    const symbol = CURRENCY_SYMBOLS[currency];
    if (currency === Currency.KRW || currency === Currency.JPY) {
         return `${symbol}${formatNumber(num)}`;
    }
    // 달러 등은 소수점 2자리가 일반적이나, 요청에 따라 리스트에서는 간소화 가능. 일단 2자리 유지하되 .00은 제거
    return `${symbol}${new Intl.NumberFormat('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 2 }).format(num)}`;
  };

  const formatProfitLoss = (num: number, currency: Currency) => {
    const sign = num >= 0 ? '+' : '';
    if (currency === Currency.KRW) {
      return `${sign}${formatKRW(num)}`;
    }
    return `${sign}${formatOriginalCurrency(num, currency)}`;
  };
  
  const getChangeColor = (value: number) => (value > 0 ? 'text-success' : value < 0 ? 'text-danger' : 'text-gray-400');
  
  // 내부 아이콘 컴포넌트들
  const SortIcon = ({ sortKey }: { sortKey: SortKey }) => {
    if (!sortConfig || sortConfig.key !== sortKey) return <span className="opacity-30">↕</span>;
    return sortConfig.direction === 'descending' ? <span>▼</span> : <span>▲</span>;
  };
  
  const RefreshIcon: React.FC<{className?: string}> = ({className}) => (
    <svg xmlns="http://www.w3.org/2000/svg" className={`h-5 w-5 ${className}`} fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h5M20 20v-5h-5M4 4l1.5 1.5A9 9 0 0120.5 10M20 20l-1.5-1.5A9 9 0 003.5 14" />
    </svg>
  );

  const ChartBarIcon: React.FC = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
    </svg>
  );

  useEffect(() => {
    if (!isLoading && prevLoadingRef.current && lastRunWasFullUpdate && failedIds && failedIds.size > 0) {
      const ok = window.confirm('업데이트에 실패한 항목이 있습니다. 실패한 리스트만 보시겠습니까?');
      if (ok) setShowFailedOnly(true);
    }
    prevLoadingRef.current = isLoading;
  }, [isLoading, lastRunWasFullUpdate, failedIds]);

  const thClasses = "px-4 py-3 cursor-pointer hover:bg-gray-600 transition-colors sticky top-0 bg-gray-700 z-10 whitespace-nowrap"; // sticky 적용
  const thContentClasses = "flex items-center gap-2";

  return (
    <div className="bg-gray-800 rounded-lg shadow-lg">
      {/* 헤더 영역 */}
      <div className="bg-gray-800 px-4 sm:px-6 pt-4 sm:pt-6 pb-4 flex justify-between items-center gap-4 border-b border-gray-700">
        <div className="flex items-center gap-4">
          <h2 className="text-xl font-bold text-white">포트폴리오 현황</h2>
          {onSearchChange && (
            <div className="relative">
              <input
                type="text"
                value={searchQuery}
                onChange={(e) => onSearchChange(e.target.value)}
                placeholder="검색..."
                className="bg-gray-700 border border-gray-600 rounded-md py-2 pl-10 pr-10 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary w-48 sm:w-64"
              />
              <svg className="absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
              </svg>
              {searchQuery && (
                <button onClick={() => onSearchChange('')} className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-white">
                  <svg className="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
              )}
            </div>
          )}
        </div>
        <div className="flex items-center gap-2">
          {/* [추가] 선택 개수 배지 */}
          {selectedIds.size > 0 && (
            <span className="bg-primary/20 text-primary px-2 py-1 rounded text-xs font-bold hidden sm:inline-block">
              {selectedIds.size}개 선택됨
            </span>
          )}

          <button
            onClick={() => {
              const ids = Array.from(selectedIds);
              if (ids.length > 0) {
                setLastRunWasFullUpdate(false);
                onRefreshSelected ? onRefreshSelected(ids) : onRefreshAll();
              } else {
                if (window.confirm('전체 종목을 업데이트 하시겠습니까?')) {
                  setLastRunWasFullUpdate(true);
                  onRefreshAll();
                }
              }
            }}
            disabled={isLoading}
            className="bg-primary hover:bg-primary-dark text-white font-medium py-2 px-3 sm:px-4 rounded-md transition duration-300 flex items-center disabled:bg-gray-600"
          >
            {isLoading ? (
              <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
            ) : <RefreshIcon className="-ml-1 mr-2 h-4 w-4"/>}
            <span>{isLoading ? '중...' : '업데이트'}</span>
          </button>
          
          <div className="flex items-center gap-2">
            <div className="relative hidden sm:block">
              <select
                value={filterCategory}
                onChange={(e) => onFilterChange(e.target.value as AssetCategory | 'ALL')}
                className="appearance-none bg-gray-700 border border-gray-600 text-white text-sm rounded-md py-2 pl-3 pr-8 focus:outline-none focus:ring-2 focus:ring-primary"
              >
                <option value="ALL">전체 자산</option>
                {categoryOptions.map(cat => (
                  <option key={cat} value={cat}>{cat}</option>
                ))}
              </select>
               <svg className="absolute right-2 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400 pointer-events-none" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
              </svg>
            </div>
            
             <button
              onClick={() => setShowHiddenColumns(!showHiddenColumns)}
              className={`py-2 px-3 rounded-md text-sm font-medium transition whitespace-nowrap ${showHiddenColumns ? 'bg-primary text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
            >
              {showHiddenColumns ? '간소화' : '더보기'}
            </button>
          </div>
        </div>
      </div>

      {/* [수정] 스크롤 영역: 헤더 고정 및 세로/가로 스크롤 */}
      <div className="overflow-x-auto overflow-y-auto max-h-[70vh] relative">
        <table className="w-full text-sm">
          <thead className="bg-gray-700 text-gray-300 uppercase text-xs">
            <tr>
              <th scope="col" className="px-4 py-3 text-center sticky top-0 bg-gray-700 z-20">
                <input type="checkbox" checked={allSelected} onChange={(e) => {
                  if (e.target.checked) setSelectedIds(new Set(enrichedAndSortedAssets.map(a => a.id)));
                  else setSelectedIds(new Set());
                }} />
              </th>
              <th scope="col" className={`${thClasses} z-20`} onClick={() => requestSort('name')}>
                <div className={thContentClasses}><span>종목명</span> <SortIcon sortKey='name'/></div>
              </th>
              {showHiddenColumns && <th scope="col" className={`${thClasses} text-right`} onClick={() => requestSort('quantity')}><div className={`${thContentClasses} justify-end`}><span>보유수량</span> <SortIcon sortKey='quantity'/></div></th>}
              {showHiddenColumns && <th scope="col" className={`${thClasses} text-right`} onClick={() => requestSort('purchasePrice')}><div className={`${thContentClasses} justify-end`}><span>매수평균가</span> <SortIcon sortKey='purchasePrice'/></div></th>}
              <th scope="col" className={`${thClasses} text-right`} onClick={() => requestSort('currentPrice')}><div className={`${thContentClasses} justify-end`}><span>현재가</span> <SortIcon sortKey='currentPrice'/></div></th>
              <th scope="col" className={`${thClasses} justify-end`} onClick={toggleReturnSort}><div className={`${thContentClasses} justify-end`}><span>{getReturnHeaderLabel()}</span></div></th>
              <th scope="col" className={`${thClasses} justify-end`} onClick={() => requestSort('purchaseValue')}><div className={`${thContentClasses} justify-end`}><span>투자원금</span> <SortIcon sortKey='purchaseValue'/></div></th>
              <th scope="col" className={`${thClasses} justify-end`} onClick={() => requestSort('currentValue')}><div className={`${thContentClasses} justify-end`}><span>평가총액</span> <SortIcon sortKey='currentValue'/></div></th>
              {showHiddenColumns && <th scope="col" className={`${thClasses} text-center`} onClick={() => requestSort('purchaseDate')}><div className={`${thContentClasses} justify-center`}><span>매수일</span> <SortIcon sortKey='purchaseDate'/></div></th>}
              {showHiddenColumns && <th scope="col" className={`${thClasses} justify-end`} onClick={() => requestSort('allocation')}><div className={`${thContentClasses} justify-end`}><span>비중</span> <SortIcon sortKey='allocation'/></div></th>}
              <th scope="col" className={`${thClasses} justify-end`} onClick={() => requestSort('dropFromHigh')}><div className={`${thContentClasses} justify-end`}><span>최고가 대비</span> <SortIcon sortKey='dropFromHigh'/></div></th>
              <th scope="col" className={`${thClasses} justify-end`} onClick={() => requestSort('yesterdayChange')}><div className={`${thContentClasses} justify-end`}><span>어제대비</span> <SortIcon sortKey='yesterdayChange'/></div></th>
              <th scope="col" className="px-4 py-3 text-center sticky top-0 bg-gray-700 z-20">관리</th>
            </tr>
          </thead>
          <tbody>
            {enrichedAndSortedAssets.length > 0 ? enrichedAndSortedAssets.map(asset => {
              const { purchaseValue, currentValue, purchaseValueKRW, currentValueKRW, returnPercentage, allocation, dropFromHigh, profitLoss, profitLossKRW, diffFromHigh, yesterdayChange, diffFromYesterday } = asset.metrics;
              const alertRate = asset.sellAlertDropRate ?? sellAlertDropRate;
              const isAlertTriggered = dropFromHigh <= -alertRate;
              const isNonKRW = asset.currency !== Currency.KRW;
              const investmentColor = getChangeColor(returnPercentage);

              return (
                <Fragment key={asset.id}>
                  <tr className={`border-b border-gray-700 transition-colors duration-200 hover:bg-gray-700/50`}>
                    <td className="px-4 py-4 text-center">
                      <input type="checkbox" checked={selectedIds.has(asset.id)} onChange={(e) => {
                        const next = new Set(selectedIds);
                        e.target.checked ? next.add(asset.id) : next.delete(asset.id);
                        setSelectedIds(next);
                      }} />
                    </td>
                    <td className="px-4 py-4 font-medium text-white break-words">
                      <div className="flex flex-col">
                         <div className="flex items-center gap-2">
                           <a 
                             href={`https://www.google.com/search?q=${encodeURIComponent(asset.ticker + ' 주가')}`}
                             target="_blank" 
                             rel="noopener noreferrer"
                             className="font-bold hover:underline text-primary-light cursor-pointer"
                           >
                             {(asset.customName?.trim() || asset.name)}
                           </a>
                           {isAlertTriggered && <span className="text-xs" title="알림 조건 도달">⚠️</span>}
                         </div>
                        <span className="text-xs text-gray-500 break-all">{asset.ticker} | {asset.exchange}</span>
                      </div>
                    </td>
                    {showHiddenColumns && <td className="px-4 py-4 text-right">{formatNumber(asset.quantity)}</td>}
                    {showHiddenColumns && (
                      <td className="px-4 py-4 text-right">
                        <div>{formatOriginalCurrency(asset.purchasePrice, asset.currency)}</div>
                        {isNonKRW && <div className="text-xs text-gray-500">≈ {formatKRW(asset.metrics.purchasePriceKRW)}</div>}
                      </td>
                    )}
                    <td className="px-4 py-4 text-right">
                      <div className="font-semibold text-white">{formatOriginalCurrency(asset.currentPrice, asset.currency)}</div>
                      {isNonKRW && <div className="text-xs text-gray-500">≈ {formatKRW(asset.metrics.currentPriceKRW)}</div>}
                    </td>
                    <td className={`px-4 py-4 font-medium text-right ${getChangeColor(returnPercentage)}`}>
                      <div>{returnPercentage.toFixed(2)}%</div>
                      <div className="text-xs opacity-80">{formatProfitLoss(profitLoss, asset.currency)}</div>
                    </td>
                    <td className="px-4 py-4 text-right">
                      <div className={investmentColor}>{formatOriginalCurrency(purchaseValue, asset.currency)}</div>
                      {isNonKRW && <div className="text-xs text-gray-500">≈ {formatKRW(purchaseValueKRW)}</div>}
                    </td>
                    <td className="px-4 py-4 text-right">
                      <div className="font-semibold text-white">{formatOriginalCurrency(currentValue, asset.currency)}</div>
                      {isNonKRW && <div className="text-xs text-gray-500">≈ {formatKRW(currentValueKRW)}</div>}
                    </td>
                    {showHiddenColumns && <td className="px-4 py-4 text-center">{asset.purchaseDate}</td>}
                    {showHiddenColumns && <td className="px-4 py-4 text-right">{allocation.toFixed(2)}%</td>}
                    <td className={`px-4 py-4 font-medium text-right ${getChangeColor(dropFromHigh)}`}>
                        <div>{dropFromHigh.toFixed(2)}%</div>
                        <div className="text-xs opacity-80">{formatProfitLoss(diffFromHigh, asset.currency)}</div>
                    </td>
                    <td className={`px-4 py-4 font-medium text-right ${getChangeColor(yesterdayChange)}`}>
                        <div>{yesterdayChange.toFixed(2)}%</div>
                        <div className="text-xs opacity-80">{formatProfitLoss(diffFromYesterday, asset.currency)}</div>
                    </td>
                    <td className="px-4 py-4 text-center relative">
                      <div className="flex items-center justify-center gap-1">
                        <button onClick={() => handleToggleExpand(asset.id)} className="p-2 text-gray-300 hover:text-white" title="차트">
                            <ChartBarIcon />
                        </button>
                        <button onClick={() => setOpenMenuId(openMenuId === asset.id ? null : asset.id)} className="p-2 text-gray-300 hover:text-white">
                            <MoreHorizontal className="h-5 w-5" />
                        </button>
                      </div>
                      {openMenuId === asset.id && (
                        <div ref={menuRef} className="absolute right-0 mt-2 w-44 bg-gray-800 border border-gray-700 rounded-md shadow-lg z-30 text-sm">
                           <button onClick={() => { setOpenMenuId(null); onEdit(asset); }} className="block w-full text-left px-3 py-2 hover:bg-gray-700 text-white">수정</button>
                           {onSell && <button onClick={() => { setOpenMenuId(null); onSell(asset); }} className="block w-full text-left px-3 py-2 text-red-400 hover:bg-gray-700">매도</button>}
                           <button onClick={() => { setOpenMenuId(null); handleToggleExpand(asset.id); }} className="block w-full text-left px-3 py-2 text-gray-200 hover:bg-gray-700">차트 보기</button>
                        </div>
                      )}
                    </td>
                  </tr>
                  {expandedAssetId === asset.id && (
                    <tr className="bg-gray-900/50">
                      <td colSpan={showHiddenColumns ? 13 : 9} className="p-0 sm:p-2">
                        <AssetTrendChart
                          history={history}
                          assetId={asset.id}
                          assetName={(asset.customName?.trim() || asset.name)}
                          // @ts-ignore: AssetTrendChart가 currentQuantity를 prop으로 받도록 수정되었는지 확인 필요
                          currentQuantity={asset.quantity} 
                        />
                      </td>
                    </tr>
                  )}
                </Fragment>
              );
            }) : (
              <tr><td colSpan={13} className="text-center py-8 text-gray-500">
                  {filterAlerts ? '알림 기준을 초과한 자산이 없습니다.' : '자산이 없습니다.'}
              </td></tr>
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
};

export default PortfolioTable;
</file>

<file path="services/geminiService.ts">
import { GoogleGenAI } from '@google/genai';
import { Asset, Currency, SymbolSearchResult, normalizeExchange } from '../types';

// =================================================================
// 1. 설정 및 초기화
// =================================================================
const API_KEY = import.meta.env.VITE_GEMINI_API_KEY;
const ai = API_KEY ? new GoogleGenAI({ apiKey: API_KEY }) : null;

console.log("Gemini Service Status:", API_KEY ? "✅ API Key Loaded" : "❌ No API Key");

// =================================================================
// 2. 캐싱 시스템 (API 호출 횟수 감소)
// =================================================================
interface CacheEntry<T> {
  data: T;
  timestamp: number;
}

const CACHE_TTL = 5 * 60 * 1000; // 5분
const priceCache = new Map<string, CacheEntry<AssetDataResult>>();
const searchCache = new Map<string, CacheEntry<SymbolSearchResult[]>>();
const exchangeRateCache = new Map<string, CacheEntry<number>>();

function getCached<T>(cache: Map<string, CacheEntry<T>>, key: string): T | null {
  const entry = cache.get(key);
  if (entry && Date.now() - entry.timestamp < CACHE_TTL) {
    return entry.data;
  }
  cache.delete(key);
  return null;
}

function setCache<T>(cache: Map<string, CacheEntry<T>>, key: string, data: T): void {
  cache.set(key, { data, timestamp: Date.now() });
}

// =================================================================
// 3. Rate Limiting (API 차단 방지)
// =================================================================
const requestQueue: Array<() => Promise<void>> = [];
let isProcessing = false;
const MIN_REQUEST_INTERVAL = 500; // 0.5초 간격

async function processQueue(): Promise<void> {
  if (isProcessing || requestQueue.length === 0) return;
  
  isProcessing = true;
  while (requestQueue.length > 0) {
    const request = requestQueue.shift();
    if (request) {
      await request();
      await delay(MIN_REQUEST_INTERVAL);
    }
  }
  isProcessing = false;
}

function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// =================================================================
// 4. Gemini API 호출 (SDK 방식 - 안정적)
// =================================================================
async function callGeminiWithSearch(prompt: string): Promise<string> {
  if (!ai) {
    console.error("Gemini AI not initialized");
    return "";
  }

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
      config: {
        tools: [{ googleSearch: {} }],
      }
    });

    const text = response.text?.trim() || "";
    // JSON 블록 정리
    return text.replace(/^```json\s*|```$/g, '').trim();
  } catch (error) {
    console.error("Gemini API Error:", error);
    return "";
  }
}

async function callGeminiBasic(prompt: string): Promise<string> {
  if (!ai) {
    console.error("Gemini AI not initialized");
    return "";
  }

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
    });

    return response.text?.trim() || "";
  } catch (error) {
    console.error("Gemini API Error:", error);
    return "";
  }
}

// =================================================================
// 5. 종목 검색
// =================================================================
export async function searchSymbols(query: string): Promise<SymbolSearchResult[]> {
  const cacheKey = query.toLowerCase();
  const cached = getCached(searchCache, cacheKey);
  if (cached) return cached;

  if (!ai) return [];

  const prompt = `Search for stock or crypto symbols matching "${query}".
Return a JSON array of up to 5 results. Each object in the array must have these exact keys: "ticker", "name" (in Korean), and "exchange" (e.g., "NASDAQ", "KRX (코스피/코스닥)", "주요 거래소 (종합)").

Example for query "samsung":
[
  {
    "ticker": "005930",
    "name": "삼성전자",
    "exchange": "KRX (코스피/코스닥)"
  }
]

Example for query "apple":
[
  {
    "ticker": "AAPL",
    "name": "Apple Inc.",
    "exchange": "NASDAQ"
  }
]

If no results are found, return an empty array [].
Your final output must be only the JSON array, with no other text or markdown formatting.`;

  try {
    const jsonText = await callGeminiWithSearch(prompt);
    const results = JSON.parse(jsonText || "[]");
    
    const validResults = results.filter((item: any) =>
      typeof item.ticker === 'string' &&
      typeof item.name === 'string' &&
      typeof item.exchange === 'string'
    );
    
    setCache(searchCache, cacheKey, validResults);
    return validResults;
  } catch (error) {
    console.error(`Search failed for "${query}":`, error);
    return [];
  }
}

// =================================================================
// 6. 단일 자산 시세 조회
// =================================================================
export interface AssetDataResult {
  name: string;
  priceOriginal: number;
  priceKRW: number;
  currency: string;
  pricePreviousClose: number;
  highestPrice?: number;
  isMocked: boolean;
}

export const fetchAssetData = async (
  ticker: string, 
  exchange: string, 
  currencyInput?: Currency
): Promise<AssetDataResult> => {
  const normalizedExchange = normalizeExchange(exchange);
  const cacheKey = `${ticker}-${exchange}`;
  const cached = getCached(priceCache, cacheKey);
  if (cached) {
    console.log(`📦 Cache hit: ${ticker}`);
    return cached;
  }

  if (!ai) {
    return createMockResult(ticker);
  }

  const prompt = `Using Google Search, find the following data for the asset with ticker "${ticker}" listed on the "${normalizedExchange}" exchange.
Use EXACT ticker match ("${ticker}"). If the exchange is NYSE American/AMEX, treat them as synonyms.
Do NOT return data for similarly named tickers:
1. The closing price for the MOST RECENT trading day.
1. The closing price for the MOST RECENT trading day.
2. The closing price for the PREVIOUS trading day (the day before the most recent one).
3. Its official name in Korean.

Return the response ONLY as a JSON object with these keys:
- "name": Official Korean name.
- "priceOriginal": Most recent closing price in native currency.
- "previousClose": Previous trading day's closing price in native currency.
- "currency": ISO 4217 currency code (e.g., USD, KRW, JPY).
- "priceKRW": Most recent closing price converted to Korean Won (KRW).

Example for AAPL (NASDAQ):
{
  "name": "애플",
  "priceOriginal": 215.50,
  "previousClose": 214.00,
  "currency": "USD",
  "priceKRW": 295000
}

Ensure all prices are numbers. Return ONLY the JSON object.`;

  try {
    const jsonText = await callGeminiWithSearch(prompt);
    const data = JSON.parse(jsonText || "{}");

    const priceOriginal = Number(data.priceOriginal) || 0;
    const priceKRW = Number(data.priceKRW) || 0;
    const previousClose = Number(data.previousClose) || priceOriginal;

    if (priceOriginal === 0 && priceKRW === 0) {
      throw new Error('Invalid price data');
    }

    const result: AssetDataResult = {
      name: data.name || ticker,
      priceOriginal,
      priceKRW,
      currency: data.currency || 'KRW',
      pricePreviousClose: previousClose,
      highestPrice: priceKRW * 1.1,
      isMocked: false
    };

    setCache(priceCache, cacheKey, result);
    console.log(`✅ Fetched: ${ticker} = ${priceKRW.toLocaleString()} KRW`);
    return result;
  } catch (error) {
    console.error(`❌ Failed to fetch ${ticker}:`, error);
    return createMockResult(ticker);
  }
};

function createMockResult(ticker: string): AssetDataResult {
  return {
    name: ticker,
    priceOriginal: 0,
    priceKRW: 0,
    currency: 'KRW',
    pricePreviousClose: 0,
    highestPrice: 0,
    isMocked: true
  };
}

// =================================================================
// 7. 배치 시세 조회 (핵심 성능 개선!)
// =================================================================
export const fetchBatchAssetPrices = async (
  assets: { ticker: string; exchange: string; id: string }[]
): Promise<Map<string, AssetDataResult>> => {
  const resultMap = new Map<string, AssetDataResult>();
  
  if (assets.length === 0) return resultMap;
  if (!ai) {
    assets.forEach(a => resultMap.set(a.id, createMockResult(a.ticker)));
    return resultMap;
  }

  // 캐시 확인 - 캐시에 있는 것들은 바로 반환
  const uncachedAssets: typeof assets = [];
  for (const asset of assets) {
    const cacheKey = `${asset.ticker}-${asset.exchange}`;
    const cached = getCached(priceCache, cacheKey);
    if (cached) {
      resultMap.set(asset.id, cached);
      console.log(`📦 Cache hit: ${asset.ticker}`);
    } else {
      uncachedAssets.push(asset);
    }
  }

  if (uncachedAssets.length === 0) {
    return resultMap;
  }

  // 배치 크기 제한 (한 번에 최대 10개)
  const BATCH_SIZE = 10;
  const batches: typeof assets[] = [];
  
  for (let i = 0; i < uncachedAssets.length; i += BATCH_SIZE) {
    batches.push(uncachedAssets.slice(i, i + BATCH_SIZE));
  }

  for (const batch of batches) {
    const batchResults = await fetchBatchInternal(batch);
    batchResults.forEach((value, key) => {
      resultMap.set(key, value);
    });
    
    // 배치 간 딜레이
    if (batches.length > 1) {
      await delay(1000);
    }
  }

  return resultMap;
};

async function fetchBatchInternal(
  assets: { ticker: string; exchange: string; id: string }[]
): Promise<Map<string, AssetDataResult>> {
  const resultMap = new Map<string, AssetDataResult>();

  const assetsListString = assets
    .map(a => `{"ticker": "${a.ticker}", "exchange": "${normalizeExchange(a.exchange)}", "id": "${a.id}"}`)
    .join(',\n');

  const prompt = `I have a list of assets. Using Google Search, find the following for EACH asset:
1. Closing price of the MOST RECENT trading day.
2. Closing price of the PREVIOUS trading day (Previous Close).

Assets List:
[
${assetsListString}
]

Use EXACT ticker matches. If the exchange is NYSE American/AMEX, treat them as synonyms.
Return the response ONLY as a JSON ARRAY of objects. Each object must strictly follow this structure:
{
  "id": "The exact id provided in the input",
  "name": "The official Korean name of the asset",
  "priceOriginal": Number (recent close in native currency),
  "previousClose": Number (previous close in native currency),
  "currency": "ISO 4217 currency code (e.g. USD, KRW, JPY)",
  "priceKRW": Number (recent close converted to Korean Won)
}

Ensure all prices are numbers. Do not miss any assets. Return ONLY the JSON array.`;

  try {
    const jsonText = await callGeminiWithSearch(prompt);
    const data = JSON.parse(jsonText || "[]");

    if (!Array.isArray(data)) {
      throw new Error('Batch API did not return an array.');
    }

    data.forEach((item: any) => {
      if (item.id && typeof item.priceKRW === 'number') {
        const result: AssetDataResult = {
          name: item.name || '',
          priceKRW: item.priceKRW,
          priceOriginal: item.priceOriginal || item.priceKRW,
          pricePreviousClose: item.previousClose || item.priceOriginal || item.priceKRW,
          currency: item.currency || 'KRW',
          highestPrice: item.priceKRW * 1.1,
          isMocked: false
        };
        
        resultMap.set(item.id, result);
        
        // 개별 캐시에도 저장
        const asset = assets.find(a => a.id === item.id);
        if (asset) {
          const cacheKey = `${asset.ticker}-${asset.exchange}`;
          setCache(priceCache, cacheKey, result);
        }
        
        console.log(`✅ Batch fetched: ${item.name || item.id} = ${item.priceKRW?.toLocaleString()} KRW`);
      }
    });

    // 실패한 자산들은 mock 데이터로 채움
    assets.forEach(asset => {
      if (!resultMap.has(asset.id)) {
        console.warn(`⚠️ Missing in batch result: ${asset.ticker}`);
        resultMap.set(asset.id, createMockResult(asset.ticker));
      }
    });

    return resultMap;
  } catch (error) {
    console.error('❌ Batch fetch failed:', error);
    // 전체 실패 시 개별 조회로 폴백
    for (const asset of assets) {
      try {
        const singleResult = await fetchAssetData(asset.ticker, asset.exchange);
        resultMap.set(asset.id, singleResult);
        await delay(500);
      } catch {
        resultMap.set(asset.id, createMockResult(asset.ticker));
      }
    }
    return resultMap;
  }
}

// =================================================================
// 8. 환율 조회
// =================================================================
export const fetchCurrentExchangeRate = async (
  fromCurrency: string, 
  toCurrency: string
): Promise<number> => {
  if (fromCurrency === toCurrency) return 1;

  const cacheKey = `${fromCurrency}-${toCurrency}`;
  const cached = getCached(exchangeRateCache, cacheKey);
  if (cached) return cached;

  if (!ai) return getDefaultExchangeRate(fromCurrency, toCurrency);

  const prompt = `Using Google Search, what was the closing exchange rate for the most recent business day between ${fromCurrency} and ${toCurrency}?
Return the response ONLY as a JSON object with a single key "rate".
The value should be a number representing how many ${toCurrency} one ${fromCurrency} is worth.
For example, for USD to KRW, the response should be:
{
  "rate": 1380.25
}
Do not include any other text, symbols, or explanations. Your final output must be only the JSON object.`;

  try {
    const jsonText = await callGeminiWithSearch(prompt);
    const data = JSON.parse(jsonText || "{}");

    if (typeof data.rate !== 'number') {
      throw new Error('Invalid rate format');
    }

    setCache(exchangeRateCache, cacheKey, data.rate);
    console.log(`💱 Exchange rate ${fromCurrency}→${toCurrency}: ${data.rate}`);
    return data.rate;
  } catch (error) {
    console.error(`Failed to fetch exchange rate ${fromCurrency}→${toCurrency}:`, error);
    return getDefaultExchangeRate(fromCurrency, toCurrency);
  }
};

export const fetchHistoricalExchangeRate = async (
  date: string, 
  fromCurrency: string, 
  toCurrency: string
): Promise<number> => {
  if (fromCurrency === toCurrency) return 1;
  if (!ai) return getDefaultExchangeRate(fromCurrency, toCurrency);

  const prompt = `Using Google Search, what was the exchange rate between ${fromCurrency} and ${toCurrency} at the end of the day on ${date}?
Return the response ONLY as a JSON object with a single key "rate".
The value should be a number representing how many ${toCurrency} one ${fromCurrency} was worth.
For example, for USD to KRW, the response should be:
{
  "rate": 1350.5
}
Do not include any other text, symbols, or explanations. Your final output must be only the JSON object.`;

  try {
    const jsonText = await callGeminiWithSearch(prompt);
    const data = JSON.parse(jsonText || "{}");

    if (typeof data.rate !== 'number') {
      throw new Error('Invalid rate format');
    }

    return data.rate;
  } catch (error) {
    console.error(`Failed to fetch historical exchange rate:`, error);
    return getDefaultExchangeRate(fromCurrency, toCurrency);
  }
};

function getDefaultExchangeRate(from: string, to: string): number {
  // 기본 환율 (폴백용)
  const rates: Record<string, number> = {
    'USD-KRW': 1400,
    'JPY-KRW': 9.5,
    'EUR-KRW': 1500,
    'CNY-KRW': 195,
  };
  return rates[`${from}-${to}`] || 1;
}

// =================================================================
// 9. 포트폴리오 분석 (AI 채팅)
// =================================================================
function formatAssetsForAI(assets: Asset[]): string {
  return assets.map(asset => {
    const value = asset.quantity * asset.currentPrice;
    const displayName = asset.customName ?? asset.name;
    return `- ${displayName} (${asset.ticker}): ${asset.quantity}주, 현재가 ${asset.currentPrice.toLocaleString()}원, 평가액 ${value.toLocaleString()}원, 카테고리: ${asset.category}`;
  }).join('\n');
}

export const askPortfolioQuestion = async (
  assets: Asset[], 
  question: string
): Promise<string> => {
  if (!ai) return "API 키가 설정되지 않았습니다.";

  const simplifiedAssets = assets.map(asset => ({
    name: asset.customName ?? asset.name,
    ticker: asset.ticker,
    exchange: asset.exchange,
    category: asset.category,
    quantity: asset.quantity,
    purchase_price_original: asset.purchasePrice,
    purchase_date: asset.purchaseDate,
    current_price_krw: asset.currentPrice,
    price_original: asset.priceOriginal,
    currency: asset.currency,
    current_value_krw: asset.currentPrice * asset.quantity,
    highest_price_krw: asset.highestPrice,
    yesterday_price_krw: asset.yesterdayPrice ?? null,
  }));

  const portfolioJson = JSON.stringify(simplifiedAssets, null, 2);

  const prompt = `당신은 사용자의 자산 포트폴리오를 분석하고 질문에 답변하는 전문 금융 어시스턴트입니다.
    
다음은 사용자의 현재 포트폴리오 데이터입니다 (JSON 형식). 각 항목에는 현재가와 함께 어제 종가가 포함될 수 있으므로, "어제 대비" 변동을 계산할 때는 \`yesterday_price_krw\`를 사용하세요. 날짜 메타가 없으면 제공된 값만으로 판단하세요:
\`\`\`json
${portfolioJson}
\`\`\`

위 데이터를 기반으로 다음 사용자의 질문에 대해 명확하고 간결하게 답변해주세요. 답변은 한국어로 작성하고, 마크다운 형식을 사용하여 가독성을 높여주세요. 외부 정보는 사용하지 말고, 제공된 포트폴리오 데이터만을 근거로 분석해야 합니다.

사용자 질문: "${question}"`;

  try {
    const response = await callGeminiBasic(prompt);
    return response || "죄송합니다. 답변을 생성할 수 없습니다.";
  } catch (error) {
    console.error('Portfolio question error:', error);
    return "포트폴리오 질문에 대한 답변 생성에 실패했습니다.";
  }
};

// 레거시 호환용
export const analyzePortfolio = askPortfolioQuestion;

// =================================================================
// 10. 캐시 관리 유틸리티
// =================================================================
export function clearPriceCache(): void {
  priceCache.clear();
  console.log("🗑️ Price cache cleared");
}

export function clearAllCaches(): void {
  priceCache.clear();
  searchCache.clear();
  exchangeRateCache.clear();
  console.log("🗑️ All caches cleared");
}

export function getCacheStats(): { prices: number; searches: number; rates: number } {
  return {
    prices: priceCache.size,
    searches: searchCache.size,
    rates: exchangeRateCache.size
  };
}
</file>

<file path="App.tsx">
import React, { useState, useMemo, useCallback, useEffect } from 'react';
import { Asset, NewAssetForm, AssetCategory, EXCHANGE_MAP, Currency, PortfolioSnapshot, AssetSnapshot, BulkUploadResult, ALLOWED_CATEGORIES, SellRecord, WatchlistItem, normalizeExchange, ExchangeRates } from './types';
import { fetchHistoricalExchangeRate, fetchCurrentExchangeRate } from './services/geminiService';
import { fetchAssetData as fetchAssetDataNew, fetchBatchAssetPrices as fetchBatchAssetPricesNew, fetchExchangeRate, fetchExchangeRateJPY } from './services/priceService';
import { googleDriveService, GoogleUser } from './services/googleDriveService';
import { useGoogleDriveSync } from './hooks/useGoogleDriveSync';
import PortfolioTable from './components/PortfolioTable';
import AllocationChart from './components/AllocationChart';
import Header from './components/Header';
import StatCard from './components/StatCard';
import EditAssetModal from './components/EditAssetModal';
import SellAssetModal from './components/SellAssetModal';
import BulkUploadModal from './components/BulkUploadModal';
import SellAlertControl from './components/SellAlertControl';
import CategorySummaryTable from './components/CategorySummaryTable';
import ProfitLossChart from './components/ProfitLossChart';
import AddNewAssetModal from './components/AddNewAssetModal';
import TopBottomAssets from './components/TopBottomAssets';
import PortfolioAssistant from './components/PortfolioAssistant';
import SellAnalyticsPage from './components/SellAnalyticsPage';
import WatchlistPage from './components/WatchlistPage';
import ExchangeRateInput from './components/ExchangeRateInput';
import { runMigrationIfNeeded } from './utils/migrateData';

type ActiveTab = 'dashboard' | 'portfolio' | 'analytics' | 'watchlist';

const mapToNewAssetStructure = (asset: any): Asset => {
  let newAsset = { ...asset };

  if (!newAsset.exchange) newAsset.exchange = EXCHANGE_MAP[newAsset.category]?.[0] || '';
  if (!newAsset.currency) {
      newAsset.currency = Currency.KRW;
      newAsset.priceOriginal = newAsset.currentPrice;
  }
  if (!newAsset.purchaseExchangeRate) {
      newAsset.purchaseExchangeRate = newAsset.currency === Currency.KRW ? 1 : undefined;
  }

  const oldCategory = newAsset.category;
  if (['주식', 'ETF'].includes(oldCategory)) {
      if (newAsset.exchange?.startsWith('KRX')) {
          newAsset.category = AssetCategory.KOREAN_STOCK;
      } else if (['NASDAQ', 'NYSE', 'AMEX'].includes(newAsset.exchange)) {
          newAsset.category = AssetCategory.US_STOCK;
      } else {
          newAsset.category = AssetCategory.OTHER_FOREIGN_STOCK;
      }
  } else if (['KRX금현물', '금', '실물자산'].includes(oldCategory)) {
      newAsset.category = AssetCategory.PHYSICAL_ASSET;
  } else {
      const categoryMap: { [key: string]: AssetCategory } = {
          "국내주식": AssetCategory.KOREAN_STOCK,
          "해외주식": AssetCategory.US_STOCK,
          "국내국채": AssetCategory.KOREAN_BOND,
          "해외국채": AssetCategory.US_BOND,
      };
      if (categoryMap[oldCategory]) {
          newAsset.category = categoryMap[oldCategory];
      }
  }
  
  if (!Object.values(AssetCategory).includes(newAsset.category)) {
      newAsset.category = AssetCategory.OTHER_FOREIGN_STOCK;
  }

  if ('region' in newAsset) {
    delete newAsset.region;
  }

  return newAsset as Asset;
};


const App: React.FC = () => {
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const { isSignedIn, googleUser, isInitializing, handleSignIn: hookSignIn, handleSignOut: hookSignOut, loadFromGoogleDrive: hookLoadFromGoogleDrive, autoSave: hookAutoSave } = useGoogleDriveSync({ onError: setError, onSuccessMessage: setSuccessMessage });

  useEffect(() => {}, []);

  const loadFromGoogleDrive = useCallback(async () => {
    try {
      const loaded = await hookLoadFromGoogleDrive();
      if (loaded) {
        const data = runMigrationIfNeeded(loaded);
        const driveAssets = Array.isArray(data.assets) ? data.assets.map(mapToNewAssetStructure) : [];
        setAssets(driveAssets);
        if (Array.isArray(data.portfolioHistory)) {
          setPortfolioHistory(data.portfolioHistory);
        } else {
          setPortfolioHistory([]);
        }
        if (Array.isArray(data.sellHistory)) {
          setSellHistory(data.sellHistory);
        } else {
          setSellHistory([]);
        }
        if (Array.isArray(data.watchlist)) {
          setWatchlist(data.watchlist);
        } else {
          setWatchlist([]);
        }
        if (data.exchangeRates) {
          // 환율 정보가 유효한지 확인하고 기본값 설정
          const rates = data.exchangeRates;
          if (!rates.USD || rates.USD < 100) rates.USD = 1450;
          if (!rates.JPY || rates.JPY < 1) rates.JPY = 9.5;
          setExchangeRates(rates);
        } else {
           setExchangeRates({ USD: 1450, JPY: 9.5 });
        }
        setSuccessMessage('Google Drive에서 포트폴리오를 불러왔습니다.');
        setTimeout(() => setSuccessMessage(null), 3000);
      } else {
        setAssets([]);
        setPortfolioHistory([]);
        setSellHistory([]);
        setWatchlist([]);
        setSuccessMessage('Google Drive에 저장된 포트폴리오가 없습니다. 자산을 추가해주세요.');
        setTimeout(() => setSuccessMessage(null), 3000);
      }
    } catch (error: any) {
      console.error('Failed to load from Google Drive:', error);
      const message = error?.message ? error.message : '';
      setError(`Google Drive에서 데이터를 불러오지 못했습니다.${message ? ` (${message})` : ''}`);
      setTimeout(() => setError(null), 3000);
    }
  }, []);

  const [assets, setAssets] = useState<Asset[]>([]);
  const [portfolioHistory, setPortfolioHistory] = useState<PortfolioSnapshot[]>([]);
  const [sellHistory, setSellHistory] = useState<SellRecord[]>([]);
  const [watchlist, setWatchlist] = useState<WatchlistItem[]>([]);
  const [exchangeRates, setExchangeRates] = useState<ExchangeRates>({ USD: 1450, JPY: 9.5 }); // 기본값 설정
  const [hasAutoUpdated, setHasAutoUpdated] = useState<boolean>(false);

  useEffect(() => {
    if (isInitializing) return;
    if (isSignedIn) {
      setHasAutoUpdated(false);
      loadFromGoogleDrive();
    } else {
      setAssets([]);
      setPortfolioHistory([]);
      setSellHistory([]);
      setHasAutoUpdated(false);
    }
  }, [isInitializing, isSignedIn, loadFromGoogleDrive]);

  const [fileName, setFileName] = useState<string>('portfolio.json');
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [isWatchlistLoading, setIsWatchlistLoading] = useState<boolean>(false);
  
  const [editingAsset, setEditingAsset] = useState<Asset | null>(null);
  const [sellingAsset, setSellingAsset] = useState<Asset | null>(null);
  const [isBulkUploadModalOpen, setIsBulkUploadModalOpen] = useState<boolean>(false);
  const [isAddAssetModalOpen, setIsAddAssetModalOpen] = useState<boolean>(false);
  const [sellAlertDropRate, setSellAlertDropRate] = useState<number>(15);
  const [filterCategory, setFilterCategory] = useState<AssetCategory | 'ALL'>('ALL');
  const [activeTab, setActiveTab] = useState<ActiveTab>('dashboard');
  const [dashboardFilterCategory, setDashboardFilterCategory] = useState<AssetCategory | 'ALL'>('ALL');
  const [isAssistantOpen, setIsAssistantOpen] = useState<boolean>(false);
  const [filterAlerts, setFilterAlerts] = useState(false);
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [updateAvailable, setUpdateAvailable] = useState<boolean>(false);
  const [updateLastModified, setUpdateLastModified] = useState<string | null>(null);
  const [versionInfo, setVersionInfo] = useState<{ commit?: string; buildTime?: string } | null>(null);
  const [failedAssetIds, setFailedAssetIds] = useState<Set<string>>(new Set());
  const categoryOptions = useMemo(() => {
    const extras = Array.from(new Set(assets.map(asset => asset.category))).filter(
      (cat) => !ALLOWED_CATEGORIES.includes(cat)
    );
    return [...ALLOWED_CATEGORIES, ...extras];
  }, [assets]);
  const showExchangeRateWarning = useMemo(() => {
    const hasUSD = assets.some(a => a.currency === Currency.USD);
    const hasJPY = assets.some(a => a.currency === Currency.JPY);
    return (hasUSD && (!exchangeRates.USD || exchangeRates.USD < 100)) || (hasJPY && (!exchangeRates.JPY || exchangeRates.JPY < 1));
  }, [assets, exchangeRates]);
  

  useEffect(() => {
    const checkForUpdate = async () => {
      try {
        const res = await fetch('metadata.json', { cache: 'no-store' });
        if (!res.ok) return;
        const lm = res.headers.get('last-modified');
        if (lm) {
          const prev = localStorage.getItem('app.lastModified');
          if (prev && prev !== lm) {
            setUpdateAvailable(true);
            setUpdateLastModified(lm);
          }
          localStorage.setItem('app.lastModified', lm);
        }
        try {
          const data = await res.clone().json();
          const commit = typeof data?.commit === 'string' ? data.commit : undefined;
          const buildTime = typeof data?.buildTime === 'string' ? data.buildTime : undefined;
          setVersionInfo({ commit, buildTime });
        } catch {}
      } catch {}
    };
    checkForUpdate();
  }, []);
  
  const handleExchangeRatesChange = useCallback((newRates: ExchangeRates) => {
    setExchangeRates(newRates);
    if (isSignedIn) {
      hookAutoSave(assets, portfolioHistory, sellHistory, watchlist, newRates);
    }
  }, [assets, portfolioHistory, sellHistory, isSignedIn, hookAutoSave, watchlist]);

  const handleRefreshAllPrices = useCallback(async (isAutoUpdate = false, isScheduled = false) => {
    if (assets.length === 0) return;
    
    setIsLoading(true);
    setError(null);
    setFailedAssetIds(new Set());
    console.log('handleRefreshAllPrices start', { totalAssets: assets.length, isAutoUpdate, isScheduled });
    
    if (isAutoUpdate || isScheduled) {
        setSuccessMessage('최신 종가 정보를 불러오는 중입니다...');
    } else {
        setSuccessMessage(null);
    }

    // [중요 변경점 1] 최신 환율을 먼저 가져와서 상태를 업데이트합니다.
    // 환율 정보가 정확해야 이후 자산 가치 계산(원화 환산 정렬 등)이 맞습니다.
    try {
        const [usdRate, jpyRate] = await Promise.all([
            fetchExchangeRate(),
            fetchExchangeRateJPY()
        ]);
        setExchangeRates(prev => ({
            ...prev,
            USD: usdRate > 1000 ? usdRate : prev.USD,
            JPY: jpyRate > 5 ? jpyRate : prev.JPY
        }));
    } catch (e) {
        console.warn("환율 업데이트 실패, 기존 값 사용", e);
    }

    // 자산 분류 (현금 vs 비현금)
    const cashAssets = assets.filter(a => a.category === AssetCategory.CASH);
    const nonCashAssets = assets.filter(a => a.category !== AssetCategory.CASH);

    // 현금 자산 업데이트 로직
    const cashPromises = cashAssets.map(asset => 
      (asset.currency === Currency.USD 
        ? fetchExchangeRate() 
        : asset.currency === Currency.JPY 
          ? fetchExchangeRateJPY() 
          : fetchCurrentExchangeRate(asset.currency, Currency.KRW)
      ).then(rate => ({
        id: asset.id,
        name: `현금 (${asset.currency})`,
        priceKRW: rate * asset.priceOriginal,
        priceOriginal: asset.priceOriginal,
        currency: asset.currency,
        pricePreviousClose: rate * asset.priceOriginal,
      }))
    );

    // 일반 자산 업데이트 로직
    const assetsToFetch = nonCashAssets.map(a => ({
      ticker: a.ticker,
      exchange: a.exchange,
      id: a.id,
      category: a.category,
      currency: a.currency,
    }));
    console.log('handleRefreshAllPrices batch payload', assetsToFetch);

    try {
      const [cashResults, batchPriceMap] = await Promise.all([
        Promise.allSettled(cashPromises),
        fetchBatchAssetPricesNew(assetsToFetch)
      ]);
      console.log('handleRefreshAllPrices cashResults', cashResults);
      console.log('handleRefreshAllPrices batchPriceMap size', batchPriceMap.size);

      const failedTickers: string[] = [];
      const failedIds: string[] = [];

      const updatedAssets = assets.map((asset) => {
        // 1. 현금 자산 처리
        if (asset.category === AssetCategory.CASH) {
          const cashIdx = cashAssets.findIndex(ca => ca.id === asset.id);
          const result = cashResults[cashIdx];
          
          if (result && result.status === 'fulfilled') {
            const data = result.value;
            return {
              ...asset,
              yesterdayPrice: data.pricePreviousClose,
              currentPrice: data.priceKRW,
              priceOriginal: data.priceOriginal,
              currency: data.currency as Currency,
              highestPrice: Math.max(asset.highestPrice, data.priceOriginal),
            };
          }
          failedTickers.push(asset.ticker);
          failedIds.push(asset.id);
          return asset;
        }

        // 2. 일반 자산 처리
        const priceData = batchPriceMap.get(asset.id);
        if (priceData && !priceData.isMocked) {
          const shouldKeepOriginalCurrency = asset.category === AssetCategory.CRYPTOCURRENCY;
          const newCurrency = shouldKeepOriginalCurrency ? asset.currency : (priceData.currency as Currency);
          
          let newCurrentPrice = asset.currency === Currency.KRW 
            ? priceData.priceKRW 
            : priceData.priceOriginal;
          if (asset.category === AssetCategory.CRYPTOCURRENCY && asset.currency === Currency.KRW) {
            const usdRate = exchangeRates.USD || 0;
            if (usdRate > 0) {
              newCurrentPrice = priceData.priceOriginal * usdRate;
            }
          }
          
          // [중요 변경점 2] KRW 자산 단위 오류 자동 보정 로직
          let newYesterdayPrice = priceData.pricePreviousClose;
          
          if (asset.currency === Currency.KRW && newYesterdayPrice > 0) {
             const ratio = newCurrentPrice / newYesterdayPrice;
             // 가격 차이가 50배 이상 나거나 0.02배 이하일 때 (단위 오류 의심 시) 보정
             if (ratio > 50 || ratio < 0.02) {
                 const impliedRate = priceData.priceOriginal > 0 ? (priceData.priceKRW / priceData.priceOriginal) : 1450;
                 if (ratio > 50) {
                    newYesterdayPrice = newYesterdayPrice * impliedRate;
                 }
             }
          }

          return {
            ...asset,
            yesterdayPrice: newYesterdayPrice,
            currentPrice: newCurrentPrice,
            currency: newCurrency,
            highestPrice: Math.max(asset.highestPrice, newCurrentPrice),
          };
        } else {
          // 실패 시
          console.error(`Failed to refresh price for ${asset.ticker}`);
          failedTickers.push(asset.ticker);
          failedIds.push(asset.id);
          return asset;
        }
      });

      setAssets(updatedAssets);
      setFailedAssetIds(new Set(failedIds));

      const successCount = assets.length - failedIds.length;
      const failedCount = failedIds.length;
      console.log('handleRefreshAllPrices done', { successCount, failedCount, failedTickers });

      if (failedTickers.length > 0) {
        setError(`실패 종목: ${failedTickers.join(', ')}`);
        setTimeout(() => setError(null), 5000);
      }

      const msg = `${successCount}건 성공, ${failedCount}건 실패`;
      setSuccessMessage(msg);
      setTimeout(() => setSuccessMessage(null), 5000);
      
      if (isSignedIn) {
        hookAutoSave(updatedAssets, portfolioHistory, sellHistory, watchlist, exchangeRates);
      }
    } catch (error) {
      console.error('Price refresh failed:', error);
      setError('가격 업데이트 중 오류가 발생했습니다.');
      setTimeout(() => setError(null), 3000);
    }

    setIsLoading(false);
  }, [assets, portfolioHistory, sellHistory, hookAutoSave, isSignedIn, watchlist, exchangeRates]);

 const handleRefreshSelectedPrices = useCallback(async (ids: string[]) => {
    if (ids.length === 0) return;
    
    setIsLoading(true);
    setError(null);

    const idSet = new Set(ids);
    const targetAssets = assets.filter(a => idSet.has(a.id));
    
    // 현금과 비현금 자산 분리
    const cashAssets = targetAssets.filter(a => a.category === AssetCategory.CASH);
    const nonCashAssets = targetAssets.filter(a => a.category !== AssetCategory.CASH);
    
    // 현금 자산 환율 업데이트 준비
    const cashPromises = cashAssets.map(asset => 
      (asset.currency === Currency.USD 
        ? fetchExchangeRate() 
        : asset.currency === Currency.JPY 
          ? fetchExchangeRateJPY() 
          : fetchCurrentExchangeRate(asset.currency, Currency.KRW)
      ).then(rate => ({
        id: asset.id, 
        priceKRW: rate * asset.priceOriginal, 
        priceOriginal: asset.priceOriginal, 
        currency: asset.currency, 
        pricePreviousClose: rate * asset.priceOriginal
      }))
    );

    // 일반 자산 가격 업데이트 준비
    const itemsToFetch = nonCashAssets.map(a => ({ 
      ticker: a.ticker, 
      exchange: a.exchange, 
      id: a.id,
      category: a.category,
      currency: a.currency,
    }));

    try {
      const [cashResults, batchPriceMap] = await Promise.all([
        Promise.allSettled(cashPromises),
        fetchBatchAssetPricesNew(itemsToFetch)
      ]);

      const updatedAssets = assets.map((asset) => {
          // 선택되지 않은 자산은 그대로 유지
          if (!idSet.has(asset.id)) return asset;

          // 1. 현금 자산 업데이트
          if (asset.category === AssetCategory.CASH) {
            const cashIdx = cashAssets.findIndex(ca => ca.id === asset.id);
            const result = cashResults[cashIdx];
            if (result && result.status === 'fulfilled') {
                const data = result.value;
                return { 
                  ...asset, 
                  yesterdayPrice: data.pricePreviousClose, 
                  currentPrice: data.priceKRW, 
                  priceOriginal: data.priceOriginal, 
                  currency: data.currency as Currency, 
                  highestPrice: Math.max(asset.highestPrice, data.priceOriginal) 
                };
            }
            return asset;
          }

          // 2. 일반 자산 업데이트
          const priceData = batchPriceMap.get(asset.id);
          if (priceData && !priceData.isMocked) {
            const shouldKeepOriginalCurrency = asset.category === AssetCategory.CRYPTOCURRENCY;
            const newCurrency = shouldKeepOriginalCurrency ? asset.currency : (priceData.currency as Currency);
            
            let newCurrentPrice = asset.currency === Currency.KRW ? priceData.priceKRW : priceData.priceOriginal;
            if (asset.category === AssetCategory.CRYPTOCURRENCY && asset.currency === Currency.KRW) {
              const usdRate = exchangeRates.USD || 0;
              if (usdRate > 0) {
                newCurrentPrice = priceData.priceOriginal * usdRate;
              }
            }
            
            // KRW 단위 오류 보정 로직 (handleRefreshAllPrices와 동일)
            let newYesterdayPrice = priceData.pricePreviousClose;
            if (asset.currency === Currency.KRW && newYesterdayPrice > 0) {
                  const ratio = newCurrentPrice / newYesterdayPrice;
                  if (ratio > 50 || ratio < 0.02) {
                      const impliedRate = priceData.priceOriginal > 0 ? (priceData.priceKRW / priceData.priceOriginal) : 1450;
                      if (ratio > 50) newYesterdayPrice = newYesterdayPrice * impliedRate;
                  }
            }

            return { 
              ...asset, 
              yesterdayPrice: newYesterdayPrice, 
              currentPrice: newCurrentPrice, 
              currency: newCurrency, 
              highestPrice: Math.max(asset.highestPrice, newCurrentPrice) 
            };
          }
          
          return asset;
      });

      setAssets(updatedAssets);
      setSuccessMessage('선택한 자산 업데이트 완료'); 
      setTimeout(() => setSuccessMessage(null), 3000);
      
      if (isSignedIn) {
        hookAutoSave(updatedAssets, portfolioHistory, sellHistory, watchlist, exchangeRates);
      }
    } catch (error) { 
      console.error('Selected update failed:', error);
      setError('선택한 항목 업데이트 중 오류가 발생했습니다.'); 
      setTimeout(() => setError(null), 3000); 
    } finally {
      setIsLoading(false);
    }
  }, [assets, hookAutoSave, portfolioHistory, sellHistory, isSignedIn, watchlist, exchangeRates]);

  const handleRefreshOnePrice = useCallback(async (assetId: string) => {
    const target = assets.find(a => a.id === assetId);
    if (!target) return;
    setIsLoading(true);
    setError(null);
    try {
      const d = await fetchAssetDataNew({ ticker: target.ticker, exchange: target.exchange, category: target.category, currency: target.currency });
      
      const shouldKeepOriginalCurrency = target.category === AssetCategory.CRYPTOCURRENCY;
      const newCurrency = shouldKeepOriginalCurrency ? target.currency : (d.currency as Currency);
      
      let newCurrentPrice = target.currency === Currency.KRW 
        ? d.priceKRW 
        : d.priceOriginal;
      if (target.category === AssetCategory.CRYPTOCURRENCY && target.currency === Currency.KRW) {
        const usdRate = exchangeRates.USD || 0;
        if (usdRate > 0) {
          newCurrentPrice = d.priceOriginal * usdRate;
        }
      }
      
      const updated = assets.map(a => a.id === assetId ? {
        ...a,
        yesterdayPrice: d.pricePreviousClose,
        currentPrice: newCurrentPrice,
        currency: newCurrency,
        highestPrice: Math.max(a.highestPrice, newCurrentPrice),
      } : a);
      setAssets(updated);
      if (isSignedIn) {
        hookAutoSave(updated, portfolioHistory, sellHistory, watchlist, exchangeRates);
      }
    } catch (e) {
      setError('해당 종목 가격 갱신에 실패했습니다.');
      setTimeout(() => setError(null), 3000);
    } finally {
      setIsLoading(false);
    }
  }, [assets, hookAutoSave, portfolioHistory, sellHistory, watchlist, exchangeRates]);


useEffect(() => {
    const updatePortfolioHistory = () => {
      if (assets.length === 0) return;

      const today = new Date().toISOString().slice(0, 10);
      
      const newAssetSnapshots: AssetSnapshot[] = assets.map(asset => {
        let currentValueKRW = 0;
        // [중요] 원화 환산 단가 계산 (차트용)
        let unitPriceKRW = 0;
        
        const rate = (asset.currency !== Currency.KRW) ? (exchangeRates[asset.currency] || 0) : 1;
        
        currentValueKRW = asset.currentPrice * asset.quantity * rate;
        unitPriceKRW = asset.currentPrice * rate; // 1주당 현재가(원화)

        let purchaseValueKRW;
         if (asset.currency === Currency.KRW) {
            purchaseValueKRW = asset.purchasePrice * asset.quantity;
        } else if (asset.purchaseExchangeRate) {
            purchaseValueKRW = asset.purchasePrice * asset.purchaseExchangeRate * asset.quantity;
        } else if (asset.priceOriginal > 0) {
            const exchangeRate = asset.currentPrice / asset.priceOriginal;
            purchaseValueKRW = asset.purchasePrice * exchangeRate * asset.quantity;
        } else {
            purchaseValueKRW = asset.purchasePrice * asset.quantity;
        }
        
        return {
          id: asset.id,
          name: (asset.customName?.trim() || asset.name),
          currentValue: currentValueKRW,
          purchaseValue: purchaseValueKRW,
          unitPrice: unitPriceKRW, // [추가] 중요: 단가 기록 (이 값이 있어야 차트가 정확히 나옵니다)
        };
      });

      const newSnapshot: PortfolioSnapshot = {
        date: today,
        assets: newAssetSnapshots,
      };

      setPortfolioHistory(prevHistory => {
        const todayIndex = prevHistory.findIndex(snap => snap.date === today);
        let updatedHistory;
        if (todayIndex > -1) {
          // 오늘 데이터가 이미 있으면 갱신
          updatedHistory = [...prevHistory];
          updatedHistory[todayIndex] = newSnapshot;
        } else {
          // 없으면 추가
          updatedHistory = [...prevHistory, newSnapshot];
        }
        
        // 최근 365일 데이터만 유지
        if (updatedHistory.length > 365) {
            updatedHistory = updatedHistory.slice(updatedHistory.length - 365);
        }

        return updatedHistory;
      });
    };
    
    // 자산 정보나 환율이 변경될 때마다 히스토리(오늘자 데이터)를 갱신
    updatePortfolioHistory();
  }, [assets, exchangeRates]);

  const filteredAssets = useMemo(() => {
    let filtered = assets;
    if (filterCategory !== 'ALL') {
      filtered = filtered.filter(asset => asset.category === filterCategory);
    }
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase().trim();
      filtered = filtered.filter(asset => 
        ((asset.customName?.toLowerCase() || asset.name.toLowerCase()).includes(query)) ||
        asset.ticker.toLowerCase().includes(query) ||
        (asset.memo && asset.memo.toLowerCase().includes(query))
      );
    }
    return filtered;
  }, [assets, filterCategory, searchQuery]);

  const handleSaveAssets = useCallback(async () => {
    if (!isSignedIn) {
      setError('Google Drive 로그인 후 저장할 수 있습니다.');
      setTimeout(() => setError(null), 3000);
      return;
    }
    setIsLoading(true);
    setError(null);
    setSuccessMessage(null);
    try {
      const exportData = {
        assets: assets,
        portfolioHistory: portfolioHistory,
        sellHistory: sellHistory,
        exchangeRates,
        lastUpdateDate: new Date().toISOString().slice(0, 10)
      };
      const portfolioJSON = JSON.stringify(exportData, null, 2);
      await googleDriveService.saveFile(portfolioJSON);
      setSuccessMessage('포트폴리오가 Google Drive에 성공적으로 저장되었습니다.');
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (e: any) {
      const errorMsg = 'Google Drive 저장에 실패했습니다. 네트워크 연결을 확인해주세요.';
      setError(errorMsg);
      setTimeout(() => setError(null), 3000);
    }
    setIsLoading(false);
  }, [assets, portfolioHistory, isSignedIn, exchangeRates]);

  const handleExportAssetsToFile = useCallback(async () => {
    if (!isSignedIn) {
      setError('Google Drive 로그인 후 내보내기 기능을 사용할 수 있습니다.');
      setTimeout(() => setError(null), 3000);
      return;
    }
    setIsLoading(true);
    setError(null);
    setSuccessMessage(null);

    const exportData = {
      assets: assets,
      portfolioHistory: portfolioHistory,
      sellHistory: sellHistory,
      exchangeRates,
      lastUpdateDate: new Date().toISOString().slice(0, 10)
    };
    const portfolioJSON = JSON.stringify(exportData, null, 2);
    const blob = new Blob([portfolioJSON], { type: 'application/json' });

    try {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      setSuccessMessage(`'${fileName}' 파일로 내보내기가 완료되었습니다.`);
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (e: any) {
      console.error("Failed to export assets", e);
      setError('파일 내보내기에 실패했습니다.');
      setTimeout(() => setError(null), 3000);
    } finally {
      setIsLoading(false);
    }
  }, [assets, portfolioHistory, fileName, isSignedIn, exchangeRates]);

  const handleImportAssetsFromFile = useCallback(async () => {
    if (!isSignedIn) {
      setError('Google Drive 로그인 후 가져오기 기능을 사용할 수 있습니다.');
      setTimeout(() => setError(null), 3000);
      return;
    }
    setError(null);
    setSuccessMessage(null);
    setIsLoading(true);

    try {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json,application/json';
      input.onchange = (event) => {
        const file = (event.target as HTMLInputElement).files?.[0];
        if (!file) {
          setIsLoading(false);
          return;
        }
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const contents = e.target?.result as string;
            const loadedData = JSON.parse(contents);
            
            let loadedAssets: any[];
            let loadedHistory: PortfolioSnapshot[] | undefined;
            let loadedSellHistory: SellRecord[] | undefined;
            let loadedWatchlist: WatchlistItem[] | undefined;

            if (Array.isArray(loadedData)) {
              loadedAssets = loadedData;
            } else if (loadedData && typeof loadedData === 'object' && Array.isArray(loadedData.assets)) {
              loadedAssets = loadedData.assets;
              if (Array.isArray(loadedData.portfolioHistory)) {
                loadedHistory = loadedData.portfolioHistory;
              }
              if (Array.isArray(loadedData.sellHistory)) {
                loadedSellHistory = loadedData.sellHistory;
              }
              if (Array.isArray(loadedData.watchlist)) {
                loadedWatchlist = loadedData.watchlist;
              }
              if (loadedData.exchangeRates) {
                  setExchangeRates(loadedData.exchangeRates);
              }
            } else {
              throw new Error("Invalid file format.");
            }
            
            const assetsWithDefaults = loadedAssets.map(mapToNewAssetStructure);

            setAssets(assetsWithDefaults);
            if (loadedHistory) {
              setPortfolioHistory(loadedHistory);
            }
            if (loadedSellHistory) {
              setSellHistory(loadedSellHistory);
            } else {
              setSellHistory([]);
            }
            if (loadedWatchlist) {
              setWatchlist(loadedWatchlist);
            } else {
              setWatchlist([]);
            }
            hookAutoSave(assetsWithDefaults, loadedHistory ?? portfolioHistory, loadedSellHistory ?? sellHistory, watchlist, exchangeRates);
            setFileName(file.name);
            setSuccessMessage(`'${file.name}' 파일에서 성공적으로 가져왔습니다.`);
            setTimeout(() => setSuccessMessage(null), 3000);
          } catch (err) {
            setError('파일 가져오기에 실패했습니다. 파일 형식이 올바른지 확인해주세요.');
            setTimeout(() => setError(null), 3000);
          } finally {
            setIsLoading(false);
          }
        };
        reader.onerror = () => {
          setError('파일을 읽는 데 실패했습니다.');
          setTimeout(() => setError(null), 3000);
          setIsLoading(false);
        };
        reader.readAsText(file);
      };
      input.click();
    } catch (err: any) {
      console.error("Failed to load or parse assets from file", err);
      setError('파일 가져오기에 실패했습니다.');
      setTimeout(() => setError(null), 3000);
      setIsLoading(false);
    }
  }, [hookAutoSave, portfolioHistory, sellHistory, watchlist, exchangeRates, isSignedIn]);


  const handleAddAsset = useCallback(async (newAssetData: NewAssetForm) => {
    if (!isSignedIn) {
      setError('Google Drive 로그인 후 자산을 추가할 수 있습니다.');
      setTimeout(() => setError(null), 3000);
      return;
    }
    setIsAddAssetModalOpen(false);
    setIsLoading(true);
    setError(null);
    try {
      let newAsset: Omit<Asset, 'id'>;
      if (newAssetData.category === AssetCategory.CASH) {
        const [purchaseExchangeRate, currentExchangeRate] = await Promise.all([
          fetchHistoricalExchangeRate(newAssetData.purchaseDate, newAssetData.currency, Currency.KRW),
          (newAssetData.currency === Currency.USD 
            ? fetchExchangeRate() 
            : newAssetData.currency === Currency.JPY 
              ? fetchExchangeRateJPY() 
              : fetchCurrentExchangeRate(newAssetData.currency, Currency.KRW))
        ]);

        newAsset = {
          ...newAssetData,
          ticker: newAssetData.currency,
          name: `현금 (${newAssetData.currency})`,
          currentPrice: currentExchangeRate * newAssetData.purchasePrice,
          priceOriginal: newAssetData.purchasePrice,
          highestPrice: currentExchangeRate * newAssetData.purchasePrice,
          purchaseExchangeRate,
        };
      } else {
        const d = await fetchAssetDataNew({ ticker: newAssetData.ticker, exchange: newAssetData.exchange, category: newAssetData.category, currency: newAssetData.currency });
        const purchaseExchangeRate = await fetchHistoricalExchangeRate(newAssetData.purchaseDate, newAssetData.currency, Currency.KRW);
        const currentPrice = newAssetData.currency === Currency.KRW ? d.priceKRW : d.priceOriginal;
        newAsset = {
          ...newAssetData,
          name: d.name,
          currentPrice,
          priceOriginal: d.priceOriginal,
          highestPrice: currentPrice,
          purchaseExchangeRate,
          currency: (d.currency as Currency) || newAssetData.currency,
        };
      }
      
      const finalNewAsset: Asset = {
        id: new Date().getTime().toString(),
        ...newAsset
      };

      setAssets(prevAssets => {
        const newAssets = [...prevAssets, finalNewAsset];
        hookAutoSave(newAssets, portfolioHistory, sellHistory, watchlist, exchangeRates);
        return newAssets;
      });
      setSuccessMessage(`${finalNewAsset.name} 자산이 추가되었습니다.`);
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (e) {
      console.error(e);
      setError('자산 정보를 가져오는 데 실패했습니다. 티커, 거래소, 날짜를 확인해주세요.');
      setTimeout(() => setError(null), 3000);
    } finally {
      setIsLoading(false);
    }
  }, [hookAutoSave, portfolioHistory, sellHistory, watchlist, exchangeRates, isSignedIn]);
  
  const handleDeleteAsset = useCallback((assetId: string) => {
    if (!isSignedIn) {
      setError('Google Drive 로그인 후 자산을 삭제할 수 있습니다.');
      setTimeout(() => setError(null), 3000);
      return;
    }
    setAssets(prevAssets => {
      const updated = prevAssets.filter(asset => asset.id !== assetId);
      hookAutoSave(updated, portfolioHistory, sellHistory, watchlist, exchangeRates);
      return updated;
    });
    setEditingAsset(null);
  }, [hookAutoSave, portfolioHistory, sellHistory, watchlist, exchangeRates, isSignedIn]);

  const handleEditAsset = useCallback((asset: Asset) => {
    setEditingAsset(asset);
  }, []);

  const handleCloseEditModal = useCallback(() => {
    setEditingAsset(null);
  }, []);

  const handleSellAsset = useCallback((asset: Asset) => {
    setSellingAsset(asset);
  }, []);

  const handleCloseSellModal = useCallback(() => {
    setSellingAsset(null);
  }, []);

  const handleConfirmSell = useCallback(async (
    assetId: string,
    sellDate: string,
    sellPrice: number,
    sellQuantity: number,
    currency: Currency
  ) => {
    if (!isSignedIn) {
      setError('Google Drive 로그인 후 매도할 수 있습니다.');
      setTimeout(() => setError(null), 3000);
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      const updatedAssets = assets.map(a => {
        if (a.id === assetId) {
          const sellTransaction = {
            id: `${assetId}-${Date.now()}`,
            sellDate,
            sellPrice,
            sellQuantity,
            currency,
          };

          const updatedAsset: Asset = {
            ...a,
            quantity: a.quantity - sellQuantity,
            sellTransactions: [...(a.sellTransactions || []), sellTransaction],
          };

          const record: SellRecord = {
            assetId: a.id,
            ticker: a.ticker,
            name: a.name,
            category: a.category,
            ...sellTransaction,
          };
          setSellHistory(prev => [...prev, record]);

          return updatedAsset.quantity <= 0 ? null : updatedAsset;
        }
        return a;
      }).filter((a): a is Asset => a !== null);

      setAssets(updatedAssets);
      setSellingAsset(null);
      setSuccessMessage('매도가 완료되었습니다.');
      setTimeout(() => setSuccessMessage(null), 3000);
      
      hookAutoSave(updatedAssets, portfolioHistory, sellHistory, watchlist, exchangeRates);
    } catch (error) {
      console.error('Failed to sell asset:', error);
      setError('매도 처리 중 오류가 발생했습니다.');
      setTimeout(() => setError(null), 3000);
    } finally {
      setIsLoading(false);
    }
  }, [assets, hookAutoSave, portfolioHistory, sellHistory, watchlist, exchangeRates, isSignedIn]);

  const handleUpdateAsset = useCallback(async (updatedAsset: Asset) => {
    if (!isSignedIn) {
      setError('Google Drive 로그인 후 자산을 수정할 수 있습니다.');
      setTimeout(() => setError(null), 3000);
      return;
    }
    const originalAsset = assets.find(a => a.id === updatedAsset.id);
    if (!originalAsset) return;

    setIsLoading(true);
    setError(null);

    try {
      let finalAsset = { ...updatedAsset };
      
      if (updatedAsset.category === AssetCategory.CASH) {
          const dateOrCurrencyChanged = originalAsset.purchaseDate !== updatedAsset.purchaseDate ||
                                      originalAsset.currency !== updatedAsset.currency;

          if (dateOrCurrencyChanged) {
                const [purchaseExchangeRate, currentExchangeRate] = await Promise.all([
                  fetchHistoricalExchangeRate(updatedAsset.purchaseDate, updatedAsset.currency, Currency.KRW),
                  (updatedAsset.currency === Currency.USD 
                    ? fetchExchangeRate() 
                    : updatedAsset.currency === Currency.JPY 
                      ? fetchExchangeRateJPY() 
                      : fetchCurrentExchangeRate(updatedAsset.currency, Currency.KRW))
                ]);
                finalAsset = {
                    ...finalAsset,
                    ticker: updatedAsset.currency,
                    name: `현금 (${updatedAsset.currency})`,
                    purchaseExchangeRate,
                    currentPrice: currentExchangeRate * finalAsset.priceOriginal,
                    highestPrice: Math.max(originalAsset.highestPrice, currentExchangeRate * finalAsset.priceOriginal),
                };
          }
      } else {
          const infoChanged = originalAsset.ticker.toUpperCase() !== updatedAsset.ticker.toUpperCase() ||
                              originalAsset.exchange !== updatedAsset.exchange;
          
          const dateOrCurrencyChanged = originalAsset.purchaseDate !== updatedAsset.purchaseDate ||
                                        originalAsset.currency !== updatedAsset.currency;

          if (infoChanged) {
            const d = await fetchAssetDataNew({ ticker: updatedAsset.ticker, exchange: updatedAsset.exchange, category: updatedAsset.category, currency: updatedAsset.currency });
            const newCurrentPrice = finalAsset.currency === Currency.KRW ? d.priceKRW : d.priceOriginal;
            finalAsset = {
              ...finalAsset,
              name: d.name,
              currentPrice: newCurrentPrice,
              priceOriginal: d.priceOriginal,
              currency: (d.currency as Currency) || finalAsset.currency,
              highestPrice: Math.max(finalAsset.highestPrice, newCurrentPrice),
            };
          }
          
          if (infoChanged || dateOrCurrencyChanged) {
            const purchaseExchangeRate = await fetchHistoricalExchangeRate(finalAsset.purchaseDate, finalAsset.currency, Currency.KRW);
            finalAsset.purchaseExchangeRate = purchaseExchangeRate;
          }
      }


      setAssets(prevAssets => {
        const updated = prevAssets.map(asset => 
          asset.id === updatedAsset.id ? finalAsset : asset
        );
          hookAutoSave(updated, portfolioHistory, sellHistory, watchlist, exchangeRates);
        return updated;
      });
      setEditingAsset(null);
    } catch (e) {
      console.error(e);
      setError('자산 정보 업데이트에 실패했습니다. 입력값을 확인해주세요.');
      setTimeout(() => setError(null), 3000);
    } finally {
      setIsLoading(false);
    }
  }, [assets, hookAutoSave, portfolioHistory, sellHistory, watchlist, exchangeRates, isSignedIn]);
  
  const handleCsvFileUpload = useCallback(async (file: File): Promise<BulkUploadResult> => {
    if (!isSignedIn) {
      return {
        successCount: 0,
        failedCount: 0,
        errors: [{ ticker: '권한 없음', reason: 'Google Drive 로그인 후 이용해주세요.' }]
      };
    }
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = async (e) => {
            let successCount = 0;
            let failedCount = 0;
            const errors: { ticker: string; reason: string }[] = [];
            const lines = (e.target?.result as string).split('\n').filter(line => line.trim() !== '');

            try {
                if (lines.length < 2) throw new Error('CSV 파일에 헤더와 데이터가 포함되어야 합니다.');
                
                const headerLine = lines[0].trim().replace(/\uFEFF/g, '');
                const header = headerLine.split(',').map(h => h.trim());
                
                const expectedHeaders = [
                  ['ticker', 'exchange', 'quantity', 'purchasePrice', 'purchaseDate', 'category', 'currency', 'sellAlertDropRate'],
                  ['ticker', 'exchange', 'quantity', 'purchasePrice', 'purchaseDate', 'category', 'currency']
                ];

                const headerMatch = expectedHeaders.find(h => JSON.stringify(h) === JSON.stringify(header));

                if (!headerMatch) {
                    throw new Error(`잘못된 헤더입니다. 예상 헤더: ${expectedHeaders[1].join(',')}`);
                }
                const hasSellAlertRate = headerMatch.length === 8;
                
                const rows = lines.slice(1);
                const newAssetForms: (NewAssetForm & { sellAlertDropRate?: number } | { error: string, ticker: string })[] = rows.map((row, index) => {
                    const values = row.trim().split(',');
                    if (values.length < 7 || values.length > 8) {
                        return { error: `${headerMatch.length}개의 값이 필요합니다.`, ticker: `행 ${index + 2}` };
                    }
                    const [ticker, exchange, quantityStr, priceStr, dateStr, categoryStr, currencyStr, sellAlertDropRateStr] = values.map(v => v.trim());
                    
                    if (!ticker) return { error: '티커가 비어있습니다.', ticker: `행 ${index + 2}` };
                    if (!exchange) return { error: '거래소가 비어있습니다.', ticker: `행 ${index + 2}` };
                    if (isNaN(parseFloat(quantityStr)) || parseFloat(quantityStr) <= 0) return { error: '수량이 유효한 숫자가 아닙니다.', ticker };
                    if (isNaN(parseFloat(priceStr)) || parseFloat(priceStr) < 0) return { error: '매수가가 유효한 숫자가 아닙니다.', ticker };
                    if (!/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) return { error: '날짜 형식이 YYYY-MM-DD가 아닙니다.', ticker };
                    if (!ALLOWED_CATEGORIES.includes(categoryStr as AssetCategory)) return { error: '유효하지 않은 자산 구분입니다.', ticker };
                    if (!Object.values(Currency).includes(currencyStr as Currency)) return { error: '유효하지 않은 통화입니다.', ticker };
                    
                    const form: NewAssetForm & { sellAlertDropRate?: number } = {
                        ticker,
                        exchange,
                        quantity: parseFloat(quantityStr),
                        purchasePrice: parseFloat(priceStr),
                        purchaseDate: dateStr,
                        category: categoryStr as AssetCategory,
                        currency: currencyStr as Currency,
                    };

                    if (hasSellAlertRate && sellAlertDropRateStr) {
                      const rate = parseFloat(sellAlertDropRateStr);
                      if (!isNaN(rate) && rate > 0) {
                        form.sellAlertDropRate = rate;
                      }
                    }

                    return form;
                });

                const validForms = newAssetForms.filter(f => !('error' in f)) as (NewAssetForm & { sellAlertDropRate?: number })[];
                const invalidForms = newAssetForms.filter(f => 'error' in f) as { error: string, ticker: string }[];

                invalidForms.forEach(form => {
                    errors.push({ ticker: form.ticker, reason: form.error });
                });
                
                if (validForms.length > 0) {
                    const newAssets: Asset[] = [];
                    for (const form of validForms) {
                        try {
                           let newAsset: Omit<Asset, 'id'>;
                              const d = await fetchAssetDataNew({ ticker: form.ticker, exchange: form.exchange, category: form.category, currency: form.currency });
                              const purchaseExchangeRate = await fetchHistoricalExchangeRate(form.purchaseDate, form.currency, Currency.KRW);
                              {
                                  const currentPrice = form.currency === Currency.KRW ? d.priceKRW : d.priceOriginal;
                                  newAsset = {
                                      ...form,
                                      name: d.name,
                                      currentPrice,
                                      priceOriginal: d.priceOriginal,
                                      currency: (d.currency as Currency) || form.currency,
                                      highestPrice: currentPrice,
                                      purchaseExchangeRate,
                                  };
                              }
                            
                            const finalNewAsset: Asset = {
                                id: `${new Date().getTime()}-${form.ticker}`,
                                ...newAsset
                            };

                            if (form.sellAlertDropRate) {
                              finalNewAsset.sellAlertDropRate = form.sellAlertDropRate;
                            }
                            newAssets.push(finalNewAsset);
                        } catch (error: any) {
                            errors.push({
                                ticker: form.ticker,
                                reason: error.message || '데이터 조회 실패',
                            });
                        }
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    
                    setAssets(prev => {
                        const updated = [...prev, ...newAssets];
                        hookAutoSave(updated, portfolioHistory, sellHistory, watchlist, exchangeRates);
                        return updated;
                    });
                    successCount = newAssets.length;
                }
                
                failedCount = errors.length;
                resolve({ successCount, failedCount, errors });

            } catch (err: any) {
                resolve({ successCount: 0, failedCount: lines.length > 1 ? lines.length - 1 : 0, errors: [{ ticker: '파일 전체', reason: err.message }] });
            }
        };

        reader.onerror = () => {
             resolve({ successCount: 0, failedCount: 0, errors: [{ ticker: '파일 읽기 오류', reason: '파일을 읽는 데 실패했습니다.' }] });
        };
        
        reader.readAsText(file);
    });
  }, [hookAutoSave, portfolioHistory, sellHistory, watchlist, exchangeRates, isSignedIn]);

  const getValueInKRW = useCallback((value: number, currency: Currency): number => {
    if (currency === Currency.KRW) return value;
    
    // 환율 정보가 있으면 쓰고, 없으면 0으로 처리 (대시보드 입력값 우선)
    const rate = exchangeRates[currency] || 0;
    return value * rate;
  }, [exchangeRates]);
  const totalValue = useMemo(() => {
    return assets.reduce((acc, asset) => {
      const v = asset.currentPrice * asset.quantity;
      return acc + getValueInKRW(v, asset.currency);
    }, 0);
  }, [assets, getValueInKRW]);

  const totalPurchaseValue = useMemo(() => {
    return assets.reduce((acc, asset) => {
      const v = asset.purchasePrice * asset.quantity;
      return acc + getValueInKRW(v, asset.currency);
    }, 0);
  }, [assets, getValueInKRW]);
  
  const formatCurrencyKRW = (value: number) => {
    return value.toLocaleString('ko-KR', { 
        style: 'currency', 
        currency: 'KRW', 
        maximumFractionDigits: 0 
    });
  };

  const dashboardFilteredAssets = useMemo(() => {
      if (dashboardFilterCategory === 'ALL') {
          return assets;
      }
      return assets.filter(asset => asset.category === dashboardFilterCategory);
  }, [assets, dashboardFilterCategory]);

  const dashboardTotalValue = useMemo(() => {
      return dashboardFilteredAssets.reduce((acc, asset) => {
        const v = asset.currentPrice * asset.quantity;
        return acc + getValueInKRW(v, asset.currency);
      }, 0);
  }, [dashboardFilteredAssets, getValueInKRW]);

  const dashboardTotalPurchaseValue = useMemo(() => {
      return dashboardFilteredAssets.reduce((acc, asset) => {
        const v = asset.purchasePrice * asset.quantity;
        return acc + getValueInKRW(v, asset.currency);
      }, 0);
  }, [dashboardFilteredAssets, getValueInKRW]);

  const dashboardTotalGainLoss = dashboardTotalValue - dashboardTotalPurchaseValue;
  const dashboardTotalReturn = dashboardTotalPurchaseValue === 0 ? 0 : (dashboardTotalGainLoss / dashboardTotalPurchaseValue) * 100;
  
  const soldAssetsStats = useMemo(() => {
    let totalSoldAmount = 0;
    let totalSoldPurchaseValue = 0;
    let totalSoldProfit = 0;
    let soldCount = 0;

    assets.forEach(asset => {
      if (asset.sellTransactions && asset.sellTransactions.length > 0) {
        asset.sellTransactions.forEach(transaction => {
          totalSoldAmount += transaction.sellPrice * transaction.sellQuantity;
          soldCount += 1;
          
          let purchaseValueForSold: number;
          if (asset.currency === Currency.KRW) {
            purchaseValueForSold = asset.purchasePrice * transaction.sellQuantity;
          } else if (asset.purchaseExchangeRate) {
            purchaseValueForSold = asset.purchasePrice * asset.purchaseExchangeRate * transaction.sellQuantity;
          } else if (asset.priceOriginal > 0) {
            const exchangeRate = asset.currentPrice / asset.priceOriginal;
            purchaseValueForSold = asset.purchasePrice * exchangeRate * transaction.sellQuantity;
          } else {
            purchaseValueForSold = asset.purchasePrice * transaction.sellQuantity;
          }
          totalSoldPurchaseValue += purchaseValueForSold;
        });
      }
    });

    totalSoldProfit = totalSoldAmount - totalSoldPurchaseValue;
    const soldReturn = totalSoldPurchaseValue === 0 ? 0 : (totalSoldProfit / totalSoldPurchaseValue) * 100;

    return {
      totalSoldAmount,
      totalSoldPurchaseValue,
      totalSoldProfit,
      soldReturn,
      soldCount,
    };
  }, [assets]);
  
  const profitLossChartTitle = useMemo(() => (
      dashboardFilterCategory === 'ALL'
      ? '손익 추이 분석'
      : `${dashboardFilterCategory} 손익 추이 분석`
  ), [dashboardFilterCategory]);
  
  const alertCount = useMemo(() => {
    return assets.filter(asset => {
        if (asset.highestPrice === 0) return false;
        const dropFromHigh = ((asset.currentPrice - asset.highestPrice) / asset.highestPrice) * 100;
        const alertRate = asset.sellAlertDropRate ?? sellAlertDropRate;
        return dropFromHigh <= -alertRate;
    }).length;
  }, [assets, sellAlertDropRate]);

  const handleExportToCsv = useCallback(() => {
    if (!isSignedIn) {
      setError('Google Drive 로그인 후 내보내기 기능을 사용할 수 있습니다.');
      setTimeout(() => setError(null), 3000);
      return;
    }
    if (assets.length === 0) {
        alert('내보낼 데이터가 없습니다.');
        return;
    }

    setIsLoading(true);
    setError(null);

    try {
        const header = [
            '종목명', '티커', '거래소', '자산구분', '보유수량', 
            '매수단가(자국통화)', '매수환율', '총매수금액(원화)',
            '현재단가(원화)', '현재평가금액(원화)', '총손익(원화)', '수익률(%)'
        ];

const rows = assets.map(asset => {
            // [수정] CSV 내보내기 시 하드코딩된 환율 제거 및 대시보드 값 적용
            let currentPriceKRW = 0;
            let currentValueKRW = 0;
            
            // [변경] exchangeRates 상태값 그대로 사용 (없으면 0)
            let rate = 1;
            if (asset.currency !== Currency.KRW) {
                rate = exchangeRates[asset.currency] || 0;
            }

            if (asset.currency === Currency.KRW) {
                currentPriceKRW = asset.currentPrice;
                currentValueKRW = asset.currentPrice * asset.quantity;
            } else {
                currentPriceKRW = asset.currentPrice * rate;
                currentValueKRW = asset.currentPrice * asset.quantity * rate;
            }
            
            let purchaseValueKRW;
            if (asset.currency === Currency.KRW) {
                purchaseValueKRW = asset.purchasePrice * asset.quantity;
            } else if (asset.purchaseExchangeRate) {
                purchaseValueKRW = asset.purchasePrice * asset.purchaseExchangeRate * asset.quantity;
            } else if (asset.priceOriginal > 0) {
                const exchangeRate = asset.currentPrice / asset.priceOriginal;
                purchaseValueKRW = asset.purchasePrice * exchangeRate * asset.quantity;
            } else {
                purchaseValueKRW = asset.purchasePrice * asset.quantity;
            }
            
            const profitLoss = currentValueKRW - purchaseValueKRW;
            const returnPercentage = purchaseValueKRW === 0 ? 0 : (profitLoss / purchaseValueKRW) * 100;
            
            const escapeCsvCell = (cell: any) => {
                const cellStr = String(cell);
                if (cellStr.includes(',')) {
                    return `"${cellStr}"`;
                }
                return cellStr;
            };

            return [
                escapeCsvCell(asset.customName ?? asset.name),
                escapeCsvCell(asset.ticker),
                escapeCsvCell(asset.exchange),
                escapeCsvCell(asset.category),
                asset.quantity,
                asset.purchasePrice,
                asset.purchaseExchangeRate || 1,
                Math.round(purchaseValueKRW),
                Math.round(currentPriceKRW),    // [수정] 환율 적용된 원화 단가 사용
                Math.round(currentValueKRW),    // [수정] 환율 적용된 총액 사용
                Math.round(profitLoss),
                returnPercentage.toFixed(2),
            ].join(',');
        });

        const csvContent = [header.join(','), ...rows].join('\n');
        const blob = new Blob([`\uFEFF${csvContent}`], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'portfolio_export.csv';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        setSuccessMessage('포트폴리오를 CSV 파일로 성공적으로 내보냈습니다.');
        setTimeout(() => setSuccessMessage(null), 3000);

    } catch (e: any) {
        console.error("Failed to export to CSV", e);
        setError('CSV 파일 내보내기에 실패했습니다.');
        setTimeout(() => setError(null), 3000);
    } finally {
        setIsLoading(false);
    }
  }, [assets, isSignedIn, exchangeRates]);

  // (이하 나머지 코드는 동일하게 유지...)
  const handleAddWatchItem = useCallback((payload: Omit<WatchlistItem, 'id' | 'currentPrice' | 'priceOriginal' | 'currency' | 'yesterdayPrice' | 'highestPrice' | 'lastSignalAt' | 'lastSignalType'>) => {
    const id = `${Date.now()}`;
    const item: WatchlistItem = { ...payload, id } as WatchlistItem;
    setWatchlist(prev => {
      const exists = prev.some(w => w.ticker.toUpperCase() === item.ticker.toUpperCase() && normalizeExchange(w.exchange) === normalizeExchange(item.exchange));
      const next = exists ? prev : [...prev, item];
      hookAutoSave(assets, portfolioHistory, sellHistory, watchlist, exchangeRates);
      return next;
    });
  }, [assets, portfolioHistory, sellHistory, hookAutoSave, watchlist, exchangeRates]);

  const handleUpdateWatchItem = useCallback((item: WatchlistItem) => {
    setWatchlist(prev => {
      const next = prev.map(w => (w.id === item.id ? item : w));
      hookAutoSave(assets, portfolioHistory, sellHistory, watchlist, exchangeRates);
      return next;
    });
  }, [assets, portfolioHistory, sellHistory, hookAutoSave, watchlist, exchangeRates]);

  const handleDeleteWatchItem = useCallback((id: string) => {
    setWatchlist(prev => {
      const next = prev.filter(w => w.id !== id);
      hookAutoSave(assets, portfolioHistory, sellHistory, watchlist, exchangeRates);
      return next;
    });
  }, [assets, portfolioHistory, sellHistory, hookAutoSave, watchlist, exchangeRates]);

  const handleBulkDeleteWatchItems = useCallback((ids: string[]) => {
    setWatchlist(prev => {
      const remove = new Set(ids);
      const next = prev.filter(w => !remove.has(w.id));
      hookAutoSave(assets, portfolioHistory, sellHistory, watchlist, exchangeRates);
      return next;
    });
  }, [assets, portfolioHistory, sellHistory, hookAutoSave, watchlist, exchangeRates]);

  const handleAddAssetsToWatchlist = useCallback((selectedAssets: Asset[]) => {
    if (selectedAssets.length === 0) return;
    setWatchlist(prev => {
      const next = [...prev];
      selectedAssets.forEach(a => {
        const exists = next.some(w => w.ticker.toUpperCase() === a.ticker.toUpperCase() && normalizeExchange(w.exchange) === normalizeExchange(a.exchange));
        if (!exists) {
          next.push({
            id: `${Date.now()}-${a.id}`,
            ticker: a.ticker,
            exchange: a.exchange,
            name: a.customName?.trim() || a.name,
            category: a.category,
            monitoringEnabled: true,
          });
        }
      });
      hookAutoSave(assets, portfolioHistory, sellHistory, watchlist, exchangeRates);
      return next;
    });
  }, [assets, portfolioHistory, sellHistory, hookAutoSave, watchlist, exchangeRates]);

  const handleToggleWatchMonitoring = useCallback((id: string, enabled: boolean) => {
    setWatchlist(prev => prev.map(w => (w.id === id ? { ...w, monitoringEnabled: enabled } : w)));
  }, []);

const handleRefreshWatchlistPrices = useCallback(async () => {
    if (!isSignedIn) {
      setError('Google Drive 로그인 후 데이터를 갱신할 수 있습니다.');
      setTimeout(() => setError(null), 3000);
      return;
    }
    if (watchlist.length === 0) return;
    setIsWatchlistLoading(true);
    setError(null);

    const itemsToFetch = watchlist.map(item => ({
      ticker: item.ticker,
      exchange: item.exchange,
      id: item.id,
      category: item.category,
      currency: item.currency,
    }));

    const priceMap = await fetchBatchAssetPricesNew(itemsToFetch);

    const updated = watchlist.map((item) => {
      const d = priceMap.get(item.id);
      if (d && !d.isMocked) {
        const newCurrency = item.currency || (d.currency as Currency);
        const newCurrentPrice = item.currency === Currency.KRW 
          ? d.priceKRW 
          : d.priceOriginal;
        const highestPrice = item.highestPrice ? Math.max(item.highestPrice, newCurrentPrice) : newCurrentPrice;
        return {
          ...item,
          currentPrice: newCurrentPrice,
          priceOriginal: d.priceOriginal,
          currency: newCurrency,
          yesterdayPrice: d.pricePreviousClose,
          highestPrice,
        };
      }
      return item;
    });

    setWatchlist(updated);
    hookAutoSave(assets, portfolioHistory, sellHistory, watchlist, exchangeRates);
    setIsWatchlistLoading(false);
  }, [isSignedIn, watchlist, assets, portfolioHistory, sellHistory, hookAutoSave, exchangeRates]);


  const handleSignIn = useCallback(async () => {
    setIsLoading(true);
    setError(null);  

    try {
      await hookSignIn();
    } catch (error: any) {
      console.error('Sign in error:', error);
      setError('로그인에 실패했습니다: ' + (error.message || '알 수 없는 오류'));
      setTimeout(() => setError(null), 5000);
    } finally {
      setIsLoading(false);
    }
  }, [hookSignIn]);

  const handleSignOut = useCallback(() => {
    hookSignOut();
    setAssets([]);
    setPortfolioHistory([]);
    setSellHistory([]);
    setHasAutoUpdated(false);
    
  }, [hookSignOut]);

  const handleTabChange = (tabId: ActiveTab) => {
    if (tabId !== 'portfolio') {
        setFilterAlerts(false);
    }
    setActiveTab(tabId);
  };

  const TabButton: React.FC<{tabId: ActiveTab; children: React.ReactNode; onClick: () => void}> = ({ tabId, children, onClick }) => {
    const isActive = activeTab === tabId;
    const activeClasses = "border-primary text-primary";
    const inactiveClasses = "border-transparent text-gray-400 hover:text-white hover:border-gray-500";
    return (
        <button
          onClick={onClick}
          className={`py-4 px-1 text-center border-b-2 font-medium text-sm focus:outline-none transition-colors duration-300 ${isActive ? activeClasses : inactiveClasses}`}
        >
          {children}
        </button>
    );
  };
  
  return (
    <div className="min-h-screen bg-gray-900 font-sans p-4 sm:p-6 lg:p-8">
      <div className="max-w-7xl mx-auto">
        <Header 
          onSave={handleSaveAssets} 
          onImport={handleImportAssetsFromFile}
          onExport={handleExportAssetsToFile}
          onExportToCsv={handleExportToCsv}
          onOpenBulkUploadModal={() => setIsBulkUploadModalOpen(true)}
          onOpenAddAssetModal={() => setIsAddAssetModalOpen(true)}
          onSignIn={handleSignIn}
          onSignOut={handleSignOut}
          isSignedIn={isSignedIn}
          userEmail={googleUser?.email}
        />
        
        <div className="fixed top-4 left-1/2 -translate-x-1/2 z-50 w-[90%] max-w-xl space-y-3 pointer-events-none">
          {updateAvailable && (
            <div className="bg-blue-600 text-white px-4 py-3 rounded-lg shadow-lg flex justify-between items-center pointer-events-auto" role="alert">
              <span className="block sm:inline">새 버전이 배포되었습니다.</span>
              <div className="flex items-center gap-2">
                <button
                  className="ml-2 bg-white/20 hover:bg-white/30 text-white px-3 py-1 rounded transition"
                  onClick={() => {
                    const baseUrl = window.location.href.split('?')[0];
                    window.location.replace(`${baseUrl}?_ts=${Date.now()}`);
                  }}
                  aria-label="업데이트 적용"
                >
                  업데이트 적용
                </button>
                <button
                  className="ml-2 text-white/80 hover:text-white transition"
                  onClick={() => setUpdateAvailable(false)}
                  aria-label="닫기"
                >
                  ✕
                </button>
              </div>
            </div>
          )}
          {successMessage && (
            <div className="bg-success/90 text-white px-4 py-3 rounded-lg shadow-lg flex justify-between items-center pointer-events-auto" role="alert">
              <span className="block sm:inline">{successMessage}</span>
              <button
                className="ml-4 text-white/80 hover:text-white transition"
                onClick={() => setSuccessMessage(null)}
                aria-label="닫기"
              >
                ✕
              </button>
            </div>
          )}
          
          {error && (
            <div className="bg-danger/90 text-white px-4 py-3 rounded-lg shadow-lg flex justify-between items-center pointer-events-auto" role="alert">
              <span className="block sm:inline">{error}</span>
              <button
                className="ml-4 text-white/80 hover:text-white transition"
                onClick={() => setError(null)}
                aria-label="닫기"
              >
                ✕
              </button>
            </div>
          )}
        </div>

        {isSignedIn ? (
          <>
            <div className="border-b border-gray-700">
              <nav className="-mb-px flex space-x-8" aria-label="Tabs">
                <TabButton tabId="dashboard" onClick={() => handleTabChange('dashboard')}>대시보드</TabButton>
                <TabButton tabId="portfolio" onClick={() => handleTabChange('portfolio')}>포트폴리오 상세</TabButton>
                <TabButton tabId="analytics" onClick={() => handleTabChange('analytics')}>수익 통계</TabButton>
                <TabButton tabId="watchlist" onClick={() => handleTabChange('watchlist')}>관심종목</TabButton>
              </nav>
            </div>

            <main className="mt-8">
              {activeTab === 'dashboard' && (
                <div className="space-y-6">
                  <div className="bg-gray-800 p-4 rounded-lg shadow-lg flex items-center justify-between flex-wrap gap-4">
                      <div className="flex items-center gap-4" title="대시보드에 표시될 자산의 종류를 선택합니다.">
                          <label htmlFor="dashboard-filter" className="text-sm font-medium text-gray-300">
                              자산 구분 필터:
                          </label>
                          <div className="relative">
                              <select
                                  id="dashboard-filter"
                                  value={dashboardFilterCategory}
                                  onChange={(e) => setDashboardFilterCategory(e.target.value as AssetCategory | 'ALL')}
                                  className="bg-gray-700 border border-gray-600 rounded-md py-2 pl-3 pr-8 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent appearance-none"
                              >
                                  <option value="ALL">전체 포트폴리오</option>
                                  {categoryOptions.map((cat) => (
                                      <option key={cat} value={cat}>{cat}</option>
                                  ))}
                              </select>
                              <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-400">
                                  <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                              </div>
                          </div>
                      </div>
                      <StatCard 
                          title="매도 알림 발생" 
                          value={`${alertCount}개`}
                          tooltip="설정된 하락률 기준을 초과한 자산의 수입니다. 클릭하여 필터링된 목록을 확인하세요."
                          onClick={() => {
                              handleTabChange('portfolio');
                              setFilterAlerts(true);
                          }}
                          isAlert={alertCount > 0}
                          size="small"
                      />
                  </div>
                  <ExchangeRateInput 
                    rates={exchangeRates} 
                    onRatesChange={handleExchangeRatesChange} 
                    showWarning={showExchangeRateWarning} 
                  />
                   <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6 mb-6">
                    <StatCard title="총 자산 (원화)" value={formatCurrencyKRW(dashboardTotalValue)} tooltip="선택된 자산의 현재 평가금액 총합입니다." />
                    <StatCard title="투자 원금" value={formatCurrencyKRW(dashboardTotalPurchaseValue)} tooltip="선택된 자산의 총 매수금액 합계입니다." />
                    <StatCard title="총 손익 (원화)" value={formatCurrencyKRW(dashboardTotalGainLoss)} isProfit={dashboardTotalGainLoss >= 0} tooltip="총 평가금액에서 총 매수금액을 뺀 금액입니다."/>
                    <StatCard title="총 수익률" value={`${dashboardTotalReturn.toFixed(2)}%`} isProfit={dashboardTotalReturn >= 0} tooltip="총 손익을 총 매수금액으로 나눈 백분율입니다."/>
                  </div>
                  {soldAssetsStats.soldCount > 0 && (
                    <div className="bg-gray-800 p-6 rounded-lg shadow-lg mb-6">
                      <h3 className="text-xl font-bold text-white mb-4">매도 통계</h3>
                      <div className="grid grid-cols-2 sm:grid-cols-4 gap-4">
                        <StatCard title="매도 횟수" value={soldAssetsStats.soldCount.toString()} tooltip="총 매도 거래 횟수입니다." size="small" />
                        <StatCard title="매도 금액" value={formatCurrencyKRW(soldAssetsStats.totalSoldAmount)} tooltip="매도된 종목의 총 매도금액입니다." size="small" />
                        <StatCard title="매도 수익" value={formatCurrencyKRW(soldAssetsStats.totalSoldProfit)} isProfit={soldAssetsStats.totalSoldProfit >= 0} tooltip="매도금액에서 매수금액을 뺀 수익입니다." size="small" />
                        <StatCard title="매도 수익률" value={`${soldAssetsStats.soldReturn.toFixed(2)}%`} isProfit={soldAssetsStats.soldReturn >= 0} tooltip="매도 수익을 매수금액으로 나눈 백분율입니다." size="small" />
                      </div>
                    </div>
                  )}
                  <ProfitLossChart history={portfolioHistory} assetsToDisplay={dashboardFilteredAssets} title={profitLossChartTitle} />
                  <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div className="lg:col-span-1">
                      <AllocationChart assets={assets} exchangeRates={exchangeRates} />
                    </div>
                    <div className="lg:col-span-1">
                       <CategorySummaryTable 
                        assets={assets} 
                        totalPortfolioValue={totalValue} 
                        exchangeRates={exchangeRates} 
                       />
                    </div>
                  </div>
                  <TopBottomAssets assets={assets} />
                </div>
              )}

              {activeTab === 'portfolio' && (
                <div className="space-y-6">
                   <SellAlertControl value={sellAlertDropRate} onChange={setSellAlertDropRate} />
                    <PortfolioTable
                      assets={filteredAssets}
                      history={portfolioHistory}
                      onRefreshAll={() => handleRefreshAllPrices(false)}
                      onRefreshSelected={handleRefreshSelectedPrices}
                      onRefreshOne={handleRefreshOnePrice}
                      onEdit={handleEditAsset}
                      onSell={handleSellAsset}
                      isLoading={isLoading}
                      sellAlertDropRate={sellAlertDropRate}
                      filterCategory={filterCategory}
                      onFilterChange={setFilterCategory}
                      filterAlerts={filterAlerts}
                      onFilterAlertsChange={setFilterAlerts}
                      searchQuery={searchQuery}
                      onSearchChange={setSearchQuery}
                      onAddSelectedToWatchlist={handleAddAssetsToWatchlist}
                      failedIds={failedAssetIds}
                      exchangeRates={exchangeRates}
                    />
                </div>
              )}

              {activeTab === 'analytics' && (
                <SellAnalyticsPage assets={assets} sellHistory={sellHistory} />
              )}
              {activeTab === 'watchlist' && (
                <WatchlistPage
                  watchlist={watchlist}
                  onAdd={(item) => handleAddWatchItem(item)}
                  onUpdate={(item) => handleUpdateWatchItem(item)}
                  onDelete={(id) => handleDeleteWatchItem(id)}
                  onToggleMonitoring={(id, enabled) => handleToggleWatchMonitoring(id, enabled)}
                  onRefreshAll={handleRefreshWatchlistPrices}
                  isLoading={isWatchlistLoading}
                  onBulkDelete={handleBulkDeleteWatchItems}
                />
              )}
            </main>
            
            <EditAssetModal
              asset={editingAsset}
              isOpen={!!editingAsset}
              onClose={handleCloseEditModal}
              onSave={handleUpdateAsset}
              onDelete={handleDeleteAsset}
              isLoading={isLoading}
            />
            <SellAssetModal
              asset={sellingAsset}
              isOpen={!!sellingAsset}
              onClose={handleCloseSellModal}
              onSell={handleConfirmSell}
              isLoading={isLoading}
            />
             <BulkUploadModal
              isOpen={isBulkUploadModalOpen}
              onClose={() => setIsBulkUploadModalOpen(false)}
              onFileUpload={handleCsvFileUpload}
            />
            <AddNewAssetModal 
              isOpen={isAddAssetModalOpen}
              onClose={() => setIsAddAssetModalOpen(false)}
              onAddAsset={handleAddAsset}
              isLoading={isLoading}
              assets={assets}
            />

            <button
              onClick={() => setIsAssistantOpen(true)}
              className="fixed bottom-8 right-8 bg-primary hover:bg-primary-dark text-white rounded-full p-4 shadow-lg transition-transform transform hover:scale-110 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-primary"
              title="포트폴리오 어시스턴트 열기"
              aria-label="Open portfolio assistant"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" viewBox="0 0 24 24" fill="currentColor">
                <path d="M14 12c0 .552-.448 1-1 1s-1-.448-1-1 .448-1 1-1 1 .448 1 1zm-1-3.5c-2.481 0-4.5 2.019-4.5 4.5s2.019 4.5 4.5 4.5 4.5-2.019 4.5-4.5-2.019-4.5-4.5-4.5zm0-3.5c-4.411 0-8 3.589-8 8s3.589 8 8 8 8-3.589 8-8-3.589-8-8-8zm-5.5 8c0-3.033 2.468-5.5 5.5-5.5s5.5 2.467 5.5 5.5-2.468 5.5-5.5 5.5-5.5-2.467-5.5-5.5zm11.5 0c0 .828-.672 1.5-1.5 1.5s-1.5-.672-1.5-1.5.672-1.5 1.5-1.5 1.5.672 1.5 1.5z"/>
              </svg>
            </button>

            <PortfolioAssistant
              isOpen={isAssistantOpen}
              onClose={() => setIsAssistantOpen(false)}
              assets={assets}
            />
          </>
        ) : (
          <div className="mt-12 bg-gray-800 border border-gray-700 rounded-lg p-8 text-center text-gray-200">
            <h2 className="text-2xl font-semibold mb-4">Google Drive 로그인 필요</h2>
            <p className="text-gray-400">
              포트폴리오 데이터는 Google Drive에만 저장됩니다. 상단의 로그인 버튼을 눌러 계정에 연결한 뒤 이용해주세요.
            </p>
          </div>
        )}
      </div>

    </div>
  );
};

export default App;
</file>

</files>
