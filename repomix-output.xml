This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/workflows/deploy.yml
.gitignore
.trae/documents/API 응답 파싱 오류 진단_보강 계획.md
.trae/documents/fetchBatchAssetPrices 청크 처리 및 부분 성공 보장 개선.md
.trae/documents/Fix Infinite Loop in Data Loading Logic.md
.trae/documents/Fix JSON Import Flow in App.md
.trae/documents/PortfolioProvider Context 리팩토링.md
.trae/documents/README 검증 및 불일치 해결 계획.md
.trae/documents/Refactor App.tsx into Modular Hooks and Layouts.md
.trae/documents/usePortfolioData 계산 로직 분리.md
App.tsx
components/AddAssetForm.tsx
components/AddNewAssetModal.tsx
components/AllocationChart.tsx
components/AssetTrendChart.tsx
components/BulkUploadModal.tsx
components/CategorySummaryTable.tsx
components/common/Toggle.tsx
components/DataConflictModal.tsx
components/EditAssetModal.tsx
components/ExchangeRateInput.tsx
components/Header.tsx
components/layouts/AnalyticsView.tsx
components/layouts/DashboardView.tsx
components/layouts/PortfolioView.tsx
components/layouts/WatchlistView.tsx
components/portfolio-table/PortfolioTableRow.tsx
components/portfolio-table/types.ts
components/portfolio-table/usePortfolioData.ts
components/portfolio-table/utils.ts
components/PortfolioAssistant.tsx
components/PortfolioModal.tsx
components/PortfolioTable.tsx
components/ProfitLossChart.tsx
components/RebalancingTable.tsx
components/RegionAllocationChart.tsx
components/SellAlertControl.tsx
components/SellAnalyticsPage.tsx
components/SellAssetModal.tsx
components/StatCard.tsx
components/TopBottomAssets.tsx
components/WatchlistPage.tsx
contexts/PortfolioContext.tsx
hooks/useAssetActions.ts
hooks/useGoogleDriveSync.ts
hooks/useMarketData.ts
hooks/useOnClickOutside.ts
hooks/usePortfolioData.ts
index.css
index.html
index.tsx
initialData.ts
package.json
postcss.config.js
public/metadata.json
README.md
RULES.md
services/geminiService.ts
services/googleDriveService.ts
services/priceService.ts
services/upbitService.ts
tailwind.config.ts
tsconfig.json
types.ts
utils/migrateData.ts
utils/portfolioCalculations.ts
vite-env.d.ts
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?


.env
.env.local
</file>

<file path=".trae/documents/API 응답 파싱 오류 진단_보강 계획.md">
## 원인 설명
- 콘솔의 `API Error Details: Error: 시세 서버 응답 처리 실패:`는 클라이언트가 HTTP 응답을 받았지만 JSON 파싱(`res.json()`)에 실패했음을 의미합니다.
- 코드 출처: `services/priceService.ts:60–66`에서 JSON 파싱 실패 시 `Error('시세 서버 응답 처리 실패: ' + text)`를 던집니다. 이 에러가 청크별 `catch`에서 로깅됩니다(`API Error Details:`).
- 상태코드가 200(성공)이어도 본문이 JSON이 아니거나 손상/부분 전송되면 발생합니다. 서버가 HTML/텍스트 에러 페이지를 200으로 반환하거나, 대용량 응답 중 스트림이 중간에 끊겨도 같은 증상이 나타납니다.

## 즉시 진단 방법
1. 브라우저 Network 탭에서 실패한 요청 선택.
2. `Status`, `Content-Type`, `Response` 본문 확인:
   - `Status=200`인데 `Content-Type=text/html` 또는 `text/plain`이고 본문이 JSON이 아니면 서버 포맷 문제.
   - 본문이 빈 문자열/잘린 JSON이면 스트리밍/타임아웃/메모리 제약 의심.
3. 서버 로그(Cloud Run)에서 해당 요청 시간대 에러 메시지 확인.

## 코드 측 개선(클라이언트)
1. `fetchStocksBatch` 파싱 로깅 강화:
   - 파싱 실패 시 `status`, `content-type`, `content-length`(가능 시), 본문 앞부분(최대 N자) 로깅.
2. 파싱 재시도/후퇴:
   - 파싱 실패 시 1회 재시도(지연 1s). 연속 실패 시 에러 유지.
3. 청크 메타정보 로깅:
   - `chunkIndex`, `chunkSize`, `tickers` 일부 샘플 로깅해 문제가 난 청크 식별.
4. 선택: 문제 청크 자동 분할(예: 20→10) 후 재시도. 재시도 후에도 실패하면 해당 하위 청크만 실패 처리.

## 서버 측 제안(Cloud Run)
- 항상 `application/json`과 유효 JSON을 반환하도록 보장.
- 에러 시 적절한 4xx/5xx 상태코드 사용(현재 메시지는 파싱 오류이므로 200 가능성 높음).
- 대량 응답의 페이로드 크기/타임아웃 설정 점검.

## 검증 계획
- 70+ 종목 업데이트 실행.
- 실패 청크에서 진단 로그로 상태/본문 유형 확인.
- 재시도/후퇴로 부분 성공률이 개선되는지 확인.
- UI의 성공/실패 카운트가 부분 성공을 반영하는지 검사.
</file>

<file path=".trae/documents/fetchBatchAssetPrices 청크 처리 및 부분 성공 보장 개선.md">
## 문제 요약
- 대량(70+개) 종목을 한 번에 요청하며 `services/priceService.ts:95`의 `fetchBatchAssetPrices`가 단일 요청으로 처리합니다.
- 서버 타임아웃/네트워크 오류 시 전체 `try-catch`가 발동해 모든 종목을 기본값으로 대체되어, UI에서는 모든 종목 실패로 표시됩니다(`App.tsx:347`).

## 현재 구현 관찰
- 단일 `POST`로 모든 `assets`를 전송(`services/priceService.ts:101–112`).
- 전체 `try-catch`에서 실패 시 모든 자산을 `isMocked: true`로 채웁니다(`services/priceService.ts:163–173`).
- 성공 케이스에서는 누락된 종목만 기본값으로 보충합니다(`services/priceService.ts:152–162`).

## 변경 목표
1. 대량 요청을 20개 단위 청크로 분할해 순차 요청.
2. 청크 사이 500ms 지연으로 서버 부하 완화.
3. 각 청크 실패 시 에러 로그에 상세 정보(`console.error('API Error Details:', e)`)를 남기고, 다른 청크의 성공 데이터는 유지.
4. 전체 처리 후 누락된 종목만 기본값으로 채워 최종 `resultMap` 반환.

## 구현 계획
- 상수 추가: `CHUNK_SIZE = 20`, `CHUNK_DELAY_MS = 500`.
- 유틸 추가: `sleep(ms)` Promise 기반 지연 함수.
- `fetchBatchAssetPrices` 재구성:
  - `for (let i=0; i<assets.length; i+=CHUNK_SIZE)` 반복.
  - 각 `chunk`에 대해 기존 payload 생성 로직 재사용(암호화폐 `-USD` 부착, `normalizeExchange` 유지).
  - `try { fetchStocksBatch(payload); items normalize; resultMap.set(...) } catch(e) { console.error('API Error Details:', e); }`.
  - `await sleep(CHUNK_DELAY_MS)`로 지연.
- 글로벌 `try-catch` 제거: 기존의 전체 실패 시 전부 기본값으로 덮는 로직을 삭제.
- 루프 종료 후, `assets`를 순회하여 `resultMap`에 없는 항목만 기본값으로 보충.

## 코드 변경 포인트(라인 레퍼런스)
- `services/priceService.ts:95`의 `export async function fetchBatchAssetPrices(...)`를 청크 처리 로직으로 대체.
- 기존 `console.log('fetchBatchAssetPrices payload', payload)`는 청크별로 유지하되, 필요 시 간단히 요약 로깅.
- 실패 시 `console.error('API Error Details:', e)` 추가.
- `fetchAssetData`(`services/priceService.ts:178`)는 그대로 유지.

## 에지 케이스/보완
- 중복 티커: `Map`은 마지막 청크 값으로 덮어씁니다(현재 방식과 동일).
- 암호화폐 KRW 환산: 기존 처리(USD 환율을 App에서 곱함) 유지.
- 서버 응답 형식 다양한 경우: 기존 `items` 정규화 로직(`results`/배열/객체) 재사용.
- 네트워크 실패가 연속 발생 시: 성공한 청크만 반영되고, 실패 청크 항목만 기본값으로 채워 UI의 “부분 성공” 맞춤.

## 검증 계획
- 70+개 포트폴리오에서 업데이트 실행.
- 콘솔에서 청크당 요청/응답 로깅 확인.
- 실패 시 콘솔에 `API Error Details:`로 상세 원인 확인(네트워크/HTTP 코드 등).
- UI에서 성공/실패 카운트가 부분 성공을 반영하고, 실패 종목 목록이 일부에만 표시되는지 확인.

## 선택적 개선(별도 승인 시 적용)
- `App.tsx:347`의 per-asset 실패 로그는 유지하되, 최종 요약 메시지(`successCount/failedCount`)를 chunk 기반 장애에도 정확히 반영하는지 확인.
- 필요 시 payload/응답 로깅 양을 축소해 콘솔 스팸 방지.
</file>

<file path=".trae/documents/PortfolioProvider Context 리팩토링.md">
## 타입 설계 원칙
- any 금지: 모든 필드·액션 파라미터·반환값은 구체 타입 지정
- 기존 도메인 타입 재사용: Asset/ExchangeRates/WatchlistItem/PortfolioSnapshot 등 [types.ts](file:///c:/Users/beari/Desktop/Dev/asset-manager/types.ts) 활용
- 컨텍스트 타입과 구현 분리: 컨텍스트는 도메인 타입에만 의존, 훅 구현 시그니처에 직접 의존하지 않음
- 파생값은 읽기 전용(readonly) 및 메모이제이션 고려

## 컨텍스트 인터페이스 구성
- PortfolioData
  - assets: Asset[]
  - portfolioHistory: PortfolioSnapshot[] (별칭: PortfolioHistory)
  - sellHistory: SellRecord[] ([types.ts:L147-L153](file:///c:/Users/beari/Desktop/Dev/asset-manager/types.ts#L147-L153))
  - watchlist: WatchlistItem[] ([types.ts:L111-L129](file:///c:/Users/beari/Desktop/Dev/asset-manager/types.ts#L111-L129))
  - exchangeRates: ExchangeRates ([types.ts:L27-L30](file:///c:/Users/beari/Desktop/Dev/asset-manager/types.ts#L27-L30))
- PortfolioStatus
  - isLoading: boolean
  - failedAssetIds: string[]
  - isSignedIn: boolean
  - userEmail: string | null
  - isInitializing: boolean
  - error: string | null
  - successMessage: string | null
  - showExchangeRateWarning: boolean
- UIState
  - activeTab: 'dashboard' | 'portfolio' | 'analytics' | 'watchlist'
  - dashboardFilterCategory: Asset['category'] | 'ALL'
  - filterCategory: Asset['category'] | 'ALL'
  - filterAlerts: boolean
  - searchQuery: string
  - sellAlertDropRate: number
- ModalState
  - editingAsset: Asset | null
  - sellingAsset: Asset | null
  - bulkUploadOpen: boolean
  - addAssetOpen: boolean
  - assistantOpen: boolean
- DerivedState
  - totalValue: number
  - alertCount: number
- PortfolioActions
  - 저장/불러오기/내보내기
    - saveToDrive: () => Promise<void>
    - exportJson: () => void
    - importJson: (file: File) => Promise<void>
    - exportCsv: () => void
  - 인증
    - signIn: () => Promise<void>
    - signOut: () => Promise<void>
  - 환율/시세
    - setExchangeRates: (rates: ExchangeRates) => void
    - refreshAllPrices: () => Promise<void>
    - refreshSelectedPrices: (ids: string[]) => Promise<void>
    - refreshOnePrice: (id: string) => Promise<void>
  - 자산
    - addAsset: (asset: Asset) => Promise<void>
    - updateAsset: (asset: Asset) => Promise<void>
    - deleteAsset: (id: string) => Promise<void>
    - confirmSell: (id: string, tx: SellTransaction) => Promise<void> ([types.ts:L132-L145](file:///c:/Users/beari/Desktop/Dev/asset-manager/types.ts#L132-L145))
  - 관심종목
    - addWatchItem: (item: WatchlistItem) => Promise<void>
    - updateWatchItem: (item: WatchlistItem) => Promise<void>
    - deleteWatchItem: (id: string) => Promise<void>
    - toggleWatchMonitoring: (id: string, enabled: boolean) => Promise<void>
    - refreshWatchlistPrices: () => Promise<void>
    - bulkDeleteWatchItems: (ids: string[]) => Promise<void>
  - UI/모달
    - setActiveTab: (tab: UIState['activeTab']) => void
    - setDashboardFilterCategory: (c: UIState['dashboardFilterCategory']) => void
    - setFilterCategory: (c: UIState['filterCategory']) => void
    - setFilterAlerts: (v: boolean) => void
    - setSearchQuery: (q: string) => void
    - setSellAlertDropRate: (n: number) => void
    - openEditModal: (asset: Asset) => void
    - closeEditModal: () => void
    - openSellModal: (asset: Asset) => void
    - closeSellModal: () => void
    - openBulkUpload: () => void
    - closeBulkUpload: () => void
    - openAddAsset: () => void
    - closeAddAsset: () => void
    - openAssistant: () => void
    - closeAssistant: () => void
- PortfolioContextValue
  - data: PortfolioData
  - status: PortfolioStatus
  - ui: UIState
  - modal: ModalState
  - derived: DerivedState
  - actions: PortfolioActions

## 주석/문서화 전략
- JSDoc 사용: 각 인터페이스·필드·액션에 @description, 파라미터/반환 설명 추가
- 섹션 주석: Data/Status/UI/Modal/Derived/Actions 블록별 헤더 주석으로 책임 범위 명시
- 도메인 레퍼런스 링크: 주요 타입 출처(types.ts 라인)와 사용 컴포넌트 링크 삽입
- 이후 분리 용이성: 타입은 상단, 구현은 하단에 배치하고 export를 명확히 구분

## 의존성/순환 회피
- 컨텍스트 타입은 types.ts의 도메인 타입만 import, 훅 함수 타입에 직접 의존하지 않음
- Provider는 훅(usePortfolioData/useMarketData/useAssetActions)을 내부에서 사용해 actions를 바인딩

## 구현 단계(요약)
1) contexts/PortfolioContext.tsx 생성: 위 인터페이스와 JSDoc 주석 정의 후 Provider 구현
2) usePortfolio() 도우미 훅 추가
3) App.tsx 트리 전체를 u007fPortfolioProvideru007f로 래핑, 하위 컴포넌트에서 props 제거하고 usePortfolio()로 전환
   - 사례: [Header](file:///c:/Users/beari/Desktop/Dev/asset-manager/App.tsx#L426-L437), [DashboardView](file:///c:/Users/beari/Desktop/Dev/asset-manager/App.tsx#L490-L505), [PortfolioView](file:///c:/Users/beari/Desktop/Dev/asset-manager/App.tsx#L507-L529), [AnalyticsView](file:///c:/Users/beari/Desktop/Dev/asset-manager/App.tsx#L531-L533), [WatchlistView](file:///c:/Users/beari/Desktop/Dev/asset-manager/App.tsx#L535-L545), 모달들 [L549-L591](file:///c:/Users/beari/Desktop/Dev/asset-manager/App.tsx#L549-L591)

## 검증
- 타입체크: any 금지 여부와 JSDoc 유효성 확인
- 통합 테스트: 시세 갱신/자산 CRUD/관심종목/모달/저장/가져오기 동작
- UI 회귀: 필터/검색/경고/합계 및
</file>

<file path=".trae/documents/README 검증 및 불일치 해결 계획.md">
## Changes to Implement
1. Update `CategorySummaryTable.tsx`
- Add prop: `exchangeRates: ExchangeRates`
- Compute totals using exchange rates:
  - For each asset: `rate = currency === KRW ? 1 : exchangeRates[currency] || 0`
  - `currentValueKRW = asset.currentPrice * asset.quantity * rate`
  - `purchaseValueKRW = asset.purchasePrice * asset.quantity * rate`
- Replace the existing fallback(1450) logic with the above rate-based computation.

2. Keep `App.tsx` passing `exchangeRates` to `CategorySummaryTable`
- Already passing; validate types compile.

3. README minor phrasing
- Clarify that the return header shows status via text label(▲/▼), not a separate icon component.

## Verification
- Type check for `CategorySummaryTable` props and usages
- Ensure dashboard summary numbers match AllocationChart
- Quick run through portfolio with USD/JPY assets to confirm KRW totals update when `ExchangeRateInput` changes

## Outcome
- Documentation and implementation match: `CategorySummaryTable` uses provided `exchangeRates` consistently; README wording accurately reflects UI.
</file>

<file path=".trae/documents/usePortfolioData 계산 로직 분리.md">
## 구현 개요
- hooks/usePortfolioData.ts에서 계산/변환(mapToNewAssetStructure)과 페칭/상태 로직을 분리
- 계산 로직과 관련 의존성을 utils/portfolioCalculations.ts로 이동
- 이동된 함수는 순수 함수로 유지

## 3단계 계획
1. utils/portfolioCalculations.ts 생성
   - mapToNewAssetStructure(asset: LegacyAssetShape): Asset export
   - 함수 내부 EXCHANGE_MAP 상수 포함(현 기본값 로직 유지)
   - AssetCategory, Currency, LegacyAssetShape, Asset 등 types에서 import
2. hooks/usePortfolioData.ts 수정
   - 기존 mapToNewAssetStructure 정의 제거
   - utils/portfolioCalculations.ts에서 import해 사용
   - 훅 반환 객체에 mapToNewAssetStructure를 그대로 노출하여 외부 호환성 유지
3. 검증
   - 타입/빌드 에러 확인
   - Google Drive 로드 경로에서 runMigrationIfNeeded → mapToNewAssetStructure 정상 적용 확인
   - 자동 저장/로그아웃/초기화 등 페칭/상태 흐름 무변화 검증

## 준수 사항
- 의존성 완전 이동 또는 적절 import로 누락/에러 방지
- utils의 함수는 외부 상태에 의존하지 않는 순수 함수로 유지
</file>

<file path="components/AddAssetForm.tsx">

</file>

<file path="components/DataConflictModal.tsx">
import React from 'react';
import { Asset } from '../types';

interface ConflictAsset {
  ticker: string;
  exchange: string;
  name: string;
  localAsset: Asset;
  driveAsset: Asset;
}

interface DataConflictModalProps {
  isOpen: boolean;
  conflicts: ConflictAsset[];
  onSelectLocal: () => void;
  onSelectDrive: () => void;
}

const DataConflictModal: React.FC<DataConflictModalProps> = ({
  isOpen,
  conflicts,
  onSelectLocal,
  onSelectDrive,
}) => {
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-gray-800 rounded-lg shadow-xl max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col">
        <div className="p-6 border-b border-gray-700">
          <h2 className="text-2xl font-bold text-white mb-2">
            {conflicts.length > 0 ? '데이터 충돌 감지' : '데이터 선택'}
          </h2>
          <p className="text-gray-400 text-sm">
            {conflicts.length > 0 
              ? '로컬 데이터와 Google Drive 데이터에 동일한 종목이 서로 다른 정보로 존재합니다. 사용할 데이터를 선택해주세요.'
              : '로컬 데이터와 Google Drive 데이터가 모두 존재합니다. 사용할 데이터를 선택해주세요.'}
          </p>
        </div>

        <div className="flex-1 overflow-y-auto p-6">
          {conflicts.length > 0 ? (
            <div className="space-y-4">
              {conflicts.map((conflict, index) => (
              <div
                key={index}
                className="bg-gray-700 rounded-lg p-4 border border-gray-600"
              >
                <div className="flex items-center justify-between mb-3">
                  <div>
                    <h3 className="text-lg font-semibold text-white">
                      {conflict.name}
                    </h3>
                    <p className="text-sm text-gray-400">
                      {conflict.ticker} ({conflict.exchange})
                    </p>
                  </div>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {/* 로컬 데이터 */}
                  <div className="bg-gray-900 rounded p-3 border border-blue-500">
                    <div className="text-xs font-semibold text-blue-400 mb-2 uppercase">
                      로컬 데이터
                    </div>
                    <div className="space-y-1 text-sm">
                      <div className="flex justify-between">
                        <span className="text-gray-400">수량:</span>
                        <span className="text-white">{conflict.localAsset.quantity}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">매수가:</span>
                        <span className="text-white">
                          {conflict.localAsset.purchasePrice.toLocaleString()}
                        </span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">매수일:</span>
                        <span className="text-white">{conflict.localAsset.purchaseDate}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">현재가:</span>
                        <span className="text-white">
                          {conflict.localAsset.currentPrice.toLocaleString()}원
                        </span>
                      </div>
                    </div>
                  </div>

                  {/* Google Drive 데이터 */}
                  <div className="bg-gray-900 rounded p-3 border border-green-500">
                    <div className="text-xs font-semibold text-green-400 mb-2 uppercase">
                      Google Drive 데이터
                    </div>
                    <div className="space-y-1 text-sm">
                      <div className="flex justify-between">
                        <span className="text-gray-400">수량:</span>
                        <span className="text-white">{conflict.driveAsset.quantity}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">매수가:</span>
                        <span className="text-white">
                          {conflict.driveAsset.purchasePrice.toLocaleString()}
                        </span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">매수일:</span>
                        <span className="text-white">{conflict.driveAsset.purchaseDate}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-gray-400">현재가:</span>
                        <span className="text-white">
                          {conflict.driveAsset.currentPrice.toLocaleString()}원
                        </span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            ))}
          </div>
          ) : (
            <div className="text-center py-8">
              <p className="text-gray-400 text-lg">
                로컬 데이터와 Google Drive 데이터가 모두 존재합니다.
              </p>
              <p className="text-gray-500 text-sm mt-2">
                사용할 데이터 소스를 선택해주세요.
              </p>
            </div>
          )}
        </div>

        <div className="p-6 border-t border-gray-700 bg-gray-750">
          <div className="flex flex-col sm:flex-row gap-3 justify-end">
            <button
              onClick={onSelectLocal}
              className="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-md transition duration-300 flex items-center justify-center gap-2"
            >
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" />
              </svg>
              로컬 데이터 사용
            </button>
            <button
              onClick={onSelectDrive}
              className="px-6 py-3 bg-green-600 hover:bg-green-700 text-white font-medium rounded-md transition duration-300 flex items-center justify-center gap-2"
            >
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 15a4 4 0 004 4h9a5 5 0 10-.1-9.999 5.002 5.002 0 10-9.78 2.096A4.001 4.001 0 003 15z" />
              </svg>
              Google Drive 데이터 사용
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

export default DataConflictModal;
</file>

<file path="components/PortfolioModal.tsx">

</file>

<file path="components/RegionAllocationChart.tsx">

</file>

<file path="components/SellAlertControl.tsx">
import React from 'react';

interface SellAlertControlProps {
  value: number;
  onChange: (newValue: number) => void;
}

const SellAlertControl: React.FC<SellAlertControlProps> = ({ value, onChange }) => {
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value === '' ? 0 : parseInt(e.target.value, 10);
    if (!isNaN(newValue) && newValue >= 0) {
      onChange(newValue);
    }
  };

  return (
    <div className="bg-gray-800 p-4 rounded-lg shadow-lg mb-6 flex items-center justify-between" title="포트폴리오 전체에 적용될 기본 매도 알림 기준입니다. 개별 자산 수정 화면에서 자산별로 다른 기준을 설정할 수 있습니다.">
      <div className="flex items-center">
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-yellow-400 mr-3" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
          <path strokeLinecap="round" strokeLinejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
        </svg>
        <label htmlFor="sell-alert-rate" className="text-sm font-medium text-gray-300">
          매도 알림 하락률 설정 (%)
        </label>
      </div>
      <div className="flex items-center">
        <span className="text-gray-400 mr-2">최고가 대비</span>
        <input
          id="sell-alert-rate"
          type="number"
          value={value}
          onChange={handleInputChange}
          min="0"
          className="w-20 bg-gray-700 border border-gray-600 rounded-md py-1 px-2 text-white text-center font-bold focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition"
        />
        <span className="text-gray-400 ml-2">% 이하 하락 시 알림</span>
      </div>
    </div>
  );
};

export default SellAlertControl;
</file>

<file path="components/SellAnalyticsPage.tsx">
import React, { useEffect, useMemo, useState } from 'react';
import { Asset, Currency, SellRecord, AssetCategory, ALLOWED_CATEGORIES } from '../types';
import StatCard from './StatCard';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, BarChart, Bar } from 'recharts';

interface SellAnalyticsPageProps {
  assets: Asset[];
  sellHistory: SellRecord[];
}

type Grouping = 'daily' | 'weekly' | 'monthly' | 'quarterly';

const SellAnalyticsPage: React.FC<SellAnalyticsPageProps> = ({ assets, sellHistory }) => {
  const [grouping, setGrouping] = useState<Grouping>('monthly');
  const [startDate, setStartDate] = useState<string>('');
  const [endDate, setEndDate] = useState<string>('');
  const [search, setSearch] = useState<string>('');
  const [category, setCategory] = useState<AssetCategory | 'ALL'>('ALL');

  const [pendingStartDate, setPendingStartDate] = useState<string>('');
  const [pendingEndDate, setPendingEndDate] = useState<string>('');
  const [pendingSearch, setPendingSearch] = useState<string>('');
  const [pendingCategory, setPendingCategory] = useState<AssetCategory | 'ALL'>('ALL');

  useEffect(() => {
    const today = new Date();
    const lastYear = new Date();
    lastYear.setFullYear(today.getFullYear() - 1);
    const fmt = (d: Date) => `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
    const s = fmt(lastYear);
    const e = fmt(today);
    setStartDate(s);
    setEndDate(e);
    setPendingStartDate(s);
    setPendingEndDate(e);
  }, []);

  const allSellRecords: SellRecord[] = useMemo(() => {
    const inlineRecords: SellRecord[] = [];
    assets.forEach(a => {
      if (a.sellTransactions && a.sellTransactions.length > 0) {
        a.sellTransactions.forEach(t => {
          inlineRecords.push({
            assetId: a.id,
            ticker: a.ticker,
            name: a.name,
            category: a.category,
            ...t,
          });
        });
      }
    });
    return [...sellHistory, ...inlineRecords];
  }, [assets, sellHistory]);

  const filteredRecords = useMemo(() => {
    return allSellRecords.filter(r => {
      const d = r.sellDate;
      const inStart = !startDate || d >= startDate;
      const inEnd = !endDate || d <= endDate;
      const inSearch = !search || r.name.toLowerCase().includes(search.toLowerCase()) || r.ticker.toLowerCase().includes(search.toLowerCase());
      const inCategory = category === 'ALL' || r.category === category;
      return inStart && inEnd && inSearch && inCategory;
    });
  }, [allSellRecords, startDate, endDate, search, category]);

  const toKRWPurchaseUnit = (a: Asset, quantity: number): number => {
    if (a.currency === Currency.KRW) return a.purchasePrice * quantity;
    if (a.purchaseExchangeRate) return a.purchasePrice * a.purchaseExchangeRate * quantity;
    if (a.priceOriginal > 0) {
      const ex = a.currentPrice / a.priceOriginal;
      return a.purchasePrice * ex * quantity;
    }
    return a.purchasePrice * quantity;
  };

  const recordWithCalc = useMemo(() => {
    const assetMap = new Map(assets.map(a => [a.id, a]));
    return filteredRecords.map(r => {
      const a = assetMap.get(r.assetId);
      const purchaseKRW = a ? toKRWPurchaseUnit(a, r.sellQuantity) : 0;
      const realized = r.sellPrice * r.sellQuantity - purchaseKRW;
      const returnPct = purchaseKRW === 0 ? 0 : (realized / purchaseKRW) * 100;
      return { ...r, purchaseKRW, realized, returnPct };
    });
  }, [filteredRecords, assets]);

  const overview = useMemo(() => {
    const totalSoldAmount = recordWithCalc.reduce((s, r) => s + r.sellPrice * r.sellQuantity, 0);
    const totalPurchase = recordWithCalc.reduce((s, r) => s + r.purchaseKRW, 0);
    const totalProfit = totalSoldAmount - totalPurchase;
    const totalReturn = totalPurchase === 0 ? 0 : (totalProfit / totalPurchase) * 100;
    const soldCount = recordWithCalc.length;
    return { totalSoldAmount, totalPurchase, totalProfit, totalReturn, soldCount };
  }, [recordWithCalc]);

  const groupKey = (dateStr: string): string => {
    const d = new Date(dateStr);
    const y = d.getFullYear();
    const m = d.getMonth() + 1;
    const q = Math.floor((m - 1) / 3) + 1;
    if (grouping === 'daily') return d.toLocaleDateString('ko-KR', { month: '2-digit', day: '2-digit' });
    if (grouping === 'weekly') {
      const first = new Date(d);
      const day = first.getDay();
      const diff = first.getDate() - day + (day === 0 ? -6 : 1);
      const monday = new Date(first.setDate(diff));
      return `${monday.getFullYear()}-${String(monday.getMonth() + 1).padStart(2, '0')}-${String(monday.getDate()).padStart(2, '0')}`;
    }
    if (grouping === 'monthly') return `${y}-${String(m).padStart(2, '0')}`;
    return `${y}-Q${q}`;
  };

  const trendData = useMemo(() => {
    const map = new Map<string, { period: string; realized: number }>();
    recordWithCalc.forEach(r => {
      const k = groupKey(r.sellDate);
      const prev = map.get(k) || { period: k, realized: 0 };
      prev.realized += r.realized;
      map.set(k, prev);
    });
    return Array.from(map.values()).sort((a, b) => a.period.localeCompare(b.period));
  }, [recordWithCalc, grouping]);

  const rankingData = useMemo(() => {
    const map = new Map<string, { name: string; realized: number; returnPct: number; count: number }>();
    recordWithCalc.forEach(r => {
      const prev = map.get(r.ticker) || { name: r.name, realized: 0, returnPct: 0, count: 0 };
      prev.realized += r.realized;
      prev.returnPct += r.returnPct;
      prev.count += 1;
      map.set(r.ticker, prev);
    });
    const arr = Array.from(map.entries()).map(([ticker, v]) => ({ ticker, name: v.name, realized: v.realized, avgReturn: v.count ? v.returnPct / v.count : 0 }));
    arr.sort((a, b) => b.avgReturn - a.avgReturn);
    return arr.slice(0, 10);
  }, [recordWithCalc]);

  const histogramData = useMemo(() => {
    if (recordWithCalc.length === 0) return [];
    const values = recordWithCalc.map(r => r.realized);
    const min = Math.min(...values);
    const max = Math.max(...values);
    const bins = 10;
    const width = (max - min) / bins || 1;
    const buckets = Array.from({ length: bins }, (_, i) => ({ bucket: `${Math.round(min + i * width)}`, count: 0 }));
    values.forEach(v => {
      let idx = Math.floor((v - min) / width);
      if (idx < 0) idx = 0;
      if (idx >= bins) idx = bins - 1;
      buckets[idx].count += 1;
    });
    return buckets;
  }, [recordWithCalc]);

  const formatKRW = (num: number) => new Intl.NumberFormat('ko-KR', { style: 'currency', currency: 'KRW', maximumFractionDigits: 0 }).format(num);

  return (
    <div className="space-y-6">
      <div className="bg-gray-800 p-4 rounded-lg shadow-lg flex items-center justify-between flex-wrap gap-4">
        <div className="flex items-center gap-4 flex-wrap">
          <div className="flex items-center gap-2">
            <label className="text-sm font-medium text-gray-300">기간:</label>
            <input type="date" value={pendingStartDate} onChange={e => setPendingStartDate(e.target.value)} className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary" />
            <span className="text-gray-400">~</span>
            <input type="date" value={pendingEndDate} onChange={e => setPendingEndDate(e.target.value)} className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary" />
          </div>
          <div className="relative">
            <select value={grouping} onChange={e => setGrouping(e.target.value as Grouping)} className="bg-gray-700 border border-gray-600 rounded-md py-2 pl-3 pr-8 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary appearance-none">
              <option value="daily">일별</option>
              <option value="weekly">주별</option>
              <option value="monthly">월별</option>
              <option value="quarterly">분기별</option>
            </select>
            <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-400">
              <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
            </div>
          </div>
          <div className="relative">
            <select value={pendingCategory} onChange={e => setPendingCategory(e.target.value as AssetCategory | 'ALL')} className="bg-gray-700 border border-gray-600 rounded-md py-2 pl-3 pr-8 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary appearance-none">
              <option value="ALL">전체 카테고리</option>
              {ALLOWED_CATEGORIES.map(cat => (
                <option key={cat} value={cat}>{cat}</option>
              ))}
            </select>
            <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-400">
              <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
            </div>
          </div>
          <div className="relative">
            <input type="text" value={pendingSearch} onChange={e => setPendingSearch(e.target.value)} placeholder="종목명/티커 검색" className="bg-gray-700 border border-gray-600 rounded-md py-2 pl-10 pr-10 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary w-64" />
            <svg className="absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
          </div>
        </div>
        <div>
          <button
            onClick={() => {
              setStartDate(pendingStartDate);
              setEndDate(pendingEndDate);
              setSearch(pendingSearch);
              setCategory(pendingCategory);
            }}
            className="bg-primary hover:bg-primary-dark text-white font-medium py-2 px-4 rounded-md transition duration-300 mr-2"
            title="선택된 조건으로 데이터를 조회합니다."
          >
            검색
          </button>
          <button
            onClick={() => {
              const header = ['sellDate','name','ticker','sellQuantity','sellPriceKRW','purchaseKRW','realized','returnPct'];
              const rows = recordWithCalc.map(r => [r.sellDate, r.name, r.ticker, r.sellQuantity, Math.round(r.sellPrice * r.sellQuantity), Math.round(r.purchaseKRW), Math.round(r.realized), r.returnPct.toFixed(2)]);
              const csv = [header.join(','), ...rows.map(row => row.join(','))].join('\n');
              const blob = new Blob([`\uFEFF${csv}`], { type: 'text/csv;charset=utf-8;' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = 'sell_analytics.csv';
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            }}
            className="bg-primary hover:bg-primary-dark text-white font-medium py-2 px-4 rounded-md transition duration-300"
            title="현재 필터 기준의 매도 통계 데이터를 CSV로 내보냅니다."
          >
            CSV 내보내기
          </button>
        </div>
      </div>

      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6 mb-6">
        <StatCard title="총 매도금액" value={formatKRW(overview.totalSoldAmount)} tooltip="선택된 필터에 해당하는 매도 합계" />
        <StatCard title="매도 수익" value={formatKRW(overview.totalProfit)} isProfit={overview.totalProfit >= 0} tooltip="매도금액 - 매수원가" />
        <StatCard title="매도 수익률" value={`${overview.totalReturn.toFixed(2)}%`} isProfit={overview.totalReturn >= 0} tooltip="수익/매수원가" />
        <StatCard title="매도 횟수" value={String(overview.soldCount)} tooltip="거래 수" />
      </div>

      <div className="bg-gray-800 p-6 rounded-lg shadow-lg h-96">
        <h3 className="text-xl font-bold text-white mb-4">기간별 수익 추이</h3>
        {trendData.length > 0 ? (
          <ResponsiveContainer width="100%" height="85%">
            <LineChart data={trendData} margin={{ top: 5, right: 20, left: 20, bottom: 5 }}>
              <CartesianGrid strokeDasharray="3 3" stroke="#4A5568" />
              <XAxis dataKey="period" stroke="#A0AEC0" fontSize={12} />
              <YAxis stroke="#A0AEC0" fontSize={12} tickFormatter={(v: number) => v.toLocaleString('ko-KR')} width={80} />
              <Tooltip formatter={(v: number) => [`${formatKRW(v)}`, '실현손익']} contentStyle={{ backgroundColor: '#2D3748', border: '1px solid #4A5568', borderRadius: '0.5rem' }} labelStyle={{ color: '#E2E8F0' }} />
              <Legend wrapperStyle={{ fontSize: '12px', bottom: -10 }} />
              <Line type="monotone" dataKey="realized" name="실현손익" stroke="#FFFFFF" strokeWidth={3} dot={{ r: 4 }} activeDot={{ r: 8 }} />
            </LineChart>
          </ResponsiveContainer>
        ) : (
          <div className="flex items-center justify-center h-full">
            <p className="text-gray-500">표시할 데이터가 없습니다.</p>
          </div>
        )}
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <div className="bg-gray-800 p-6 rounded-lg shadow-lg">
          <h3 className="text-xl font-bold text-white mb-4">종목별 수익률 순위(상위 10)</h3>
          {rankingData.length > 0 ? (
            <ResponsiveContainer width="100%" height={300}>
              <BarChart data={rankingData} layout="vertical" margin={{ left: 40, right: 20 }}>
                <CartesianGrid strokeDasharray="3 3" stroke="#4A5568" />
                <XAxis type="number" stroke="#A0AEC0" fontSize={12} tickFormatter={(v: number) => `${v.toFixed(1)}%`} />
                <YAxis type="category" dataKey="name" stroke="#A0AEC0" fontSize={12} width={160} />
                <Tooltip formatter={(v: number) => [`${(v as number).toFixed(2)}%`, '평균 수익률']} contentStyle={{ backgroundColor: '#2D3748', border: '1px solid #4A5568', borderRadius: '0.5rem' }} />
                <Bar dataKey="avgReturn" name="평균 수익률" fill="#60A5FA" />
              </BarChart>
            </ResponsiveContainer>
          ) : (
            <p className="text-gray-500">표시할 데이터가 없습니다.</p>
          )}
        </div>

        <div className="bg-gray-800 p-6 rounded-lg shadow-lg">
          <h3 className="text-xl font-bold text-white mb-4">손익 분포(히스토그램)</h3>
          {histogramData.length > 0 ? (
            <ResponsiveContainer width="100%" height={300}>
              <BarChart data={histogramData}>
                <CartesianGrid strokeDasharray="3 3" stroke="#4A5568" />
                <XAxis dataKey="bucket" stroke="#A0AEC0" fontSize={12} tickFormatter={(v: string) => new Intl.NumberFormat('ko-KR').format(Number(v))} />
                <YAxis stroke="#A0AEC0" fontSize={12} />
                <Tooltip contentStyle={{ backgroundColor: '#2D3748', border: '1px solid #4A5568', borderRadius: '0.5rem' }} labelFormatter={(v) => `${v} KRW`} />
                <Bar dataKey="count" name="거래 수" fill="#34D399" />
              </BarChart>
            </ResponsiveContainer>
          ) : (
            <p className="text-gray-500">표시할 데이터가 없습니다.</p>
          )}
        </div>
      </div>
    </div>
  );
};

export default SellAnalyticsPage;
</file>

<file path="components/StatCard.tsx">
import React from 'react';

interface StatCardProps {
  title: string;
  value: string;
  isProfit?: boolean;
  tooltip?: string;
  onClick?: () => void;
  isAlert?: boolean;
  size?: 'normal' | 'small';
}

const StatCard: React.FC<StatCardProps> = ({ title, value, isProfit, tooltip, onClick, isAlert, size = 'normal' }) => {
  const valueColor = isAlert
    ? 'text-yellow-400'
    : isProfit === undefined 
    ? 'text-white' 
    : isProfit 
    ? 'text-success' 
    : 'text-danger';

  const containerClasses = `bg-gray-800 ${size === 'small' ? 'p-3' : 'p-6'} rounded-lg shadow-lg ${onClick ? 'cursor-pointer hover:bg-gray-700 transition-colors' : ''}`;
  const titleClasses = `font-medium uppercase tracking-wider ${size === 'small' ? 'text-xs' : 'text-sm'} ${isAlert ? 'text-yellow-400' : 'text-gray-400'}`;
  const valueClasses = `font-bold ${size === 'small' ? 'text-2xl mt-1' : 'text-3xl mt-2'} ${valueColor}`;


  return (
    <div className={containerClasses} title={tooltip} onClick={onClick}>
      <h3 className={titleClasses}>{title}</h3>
      <p className={valueClasses}>{value}</p>
    </div>
  );
};

export default StatCard;
</file>

<file path="index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    font-family: 'Noto Sans KR', sans-serif;
    color-scheme: dark;
  }

  body {
    @apply bg-gray-900 text-gray-200 min-h-screen;
    margin: 0;
  }

  #root {
    min-height: 100vh;
  }
}
</file>

<file path="index.tsx">
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="initialData.ts">
import { Asset, AssetCategory, Currency } from './types';

export const initialAssets: Asset[] = [
  {
    id: '1',
    category: AssetCategory.US_STOCK,
    ticker: 'AAPL',
    exchange: 'NASDAQ',
    name: 'Apple Inc.',
    quantity: 10,
    purchasePrice: 150,
    purchaseDate: '2023-01-15',
    currency: Currency.USD,
    purchaseExchangeRate: 1240.0,
    currentPrice: 295000,
    priceOriginal: 215.50,
    highestPrice: 300000,
  },
  {
    id: '2',
    category: AssetCategory.KOREAN_STOCK,
    ticker: '005930',
    exchange: 'KRX (코스피/코스닥)',
    name: '삼성전자',
    quantity: 20,
    purchasePrice: 70000,
    purchaseDate: '2023-03-22',
    currency: Currency.KRW,
    purchaseExchangeRate: 1,
    currentPrice: 78000,
    priceOriginal: 78000,
    highestPrice: 81000,
  },
  {
    id: '3',
    category: AssetCategory.CRYPTOCURRENCY,
    ticker: 'BTC',
    exchange: '주요 거래소 (종합)',
    name: '비트코인',
    quantity: 0.5,
    purchasePrice: 30000,
    purchaseDate: '2023-11-01',
    currency: Currency.USD,
    purchaseExchangeRate: 1350.0,
    currentPrice: 95000000,
    priceOriginal: 68000,
    highestPrice: 100000000,
  },
   {
    id: '4',
    category: AssetCategory.PHYSICAL_ASSET,
    ticker: 'KR7079120004',
    exchange: 'KRX 금시장',
    name: 'KRX 금현물',
    quantity: 10,
    purchasePrice: 85000,
    purchaseDate: '2024-01-10',
    currency: Currency.KRW,
    purchaseExchangeRate: 1,
    currentPrice: 110000,
    priceOriginal: 110000,
    highestPrice: 115000,
  },
];
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="public/metadata.json">
{
  "commit": "DEV-LOCAL",
  "buildTime": "2025-11-27T00:00:00Z"
}
</file>

<file path="tailwind.config.ts">
import type { Config } from 'tailwindcss';

const config: Config = {
  content: [
    './index.html',
    './index.tsx',
    './App.tsx',
    './components/**/*.{ts,tsx}',
    './pages/**/*.{ts,tsx}',
    './sections/**/*.{ts,tsx}',
  ],
  theme: {
    extend: {
      fontFamily: {
        sans: ['"Noto Sans KR"', 'sans-serif'],
      },
      colors: {
        'gray-900': '#121212',
        'gray-800': '#1E1E1E',
        'gray-700': '#2C2C2C',
        'gray-600': '#3A3A3A',
        'gray-400': '#9CA3AF',
        primary: {
          DEFAULT: '#6366F1',
          light: '#818CF8',
          dark: '#4F46E5',
        },
        success: '#10B981',
        danger: '#EF4444',
      },
    },
  },
  plugins: [],
};

export default config;
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "types": [
      "node"
    ],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true
  }
}
</file>

<file path="vite-env.d.ts">
/// <reference types="vite/client" />

interface ImportMetaEnv {
    readonly VITE_GEMINI_API_KEY: string
    readonly VITE_GOOGLE_CLIENT_ID: string
  }
  
  interface ImportMeta {
    readonly env: ImportMetaEnv
  }
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  base: '/asset-manager/', // GitHub Pages 저장소 이름에 맞게 변경하세요
      server: {
    port: 3000 // 원하는 포트로 변경 가능
      }
})
</file>

<file path=".trae/documents/Fix Infinite Loop in Data Loading Logic.md">
# Infinite Loop Fix Plan

The analysis of `useGoogleDriveSync.ts` and `usePortfolioData.ts` reveals the root cause of the infinite loop.

## Root Cause
1. **Unstable `options` dependency**:
   - `usePortfolioData.ts` passes `onError` and `onSuccessMessage` (which are state setter functions) to `useGoogleDriveSync`.
   - `useGoogleDriveSync` includes `options` in the dependency array of `loadFromGoogleDrive` (`[options]`).
   - Although state setters are stable, if `options` object itself is recreated on every render in `usePortfolioData`, it triggers `loadFromGoogleDrive` recreation.
   - However, even if `options` is stable, the main issue is `useEffect` in `usePortfolioData`.

2. **Circular Dependency in `useEffect`**:
   - `usePortfolioData.ts`:
     ```typescript
     useEffect(() => {
       if (isInitializing) return;
       if (isSignedIn) {
         setHasAutoUpdated(false);
         loadFromGoogleDrive();
       } else {
         // ...
       }
     }, [isInitializing, isSignedIn, loadFromGoogleDrive]);
     ```
   - `loadFromGoogleDrive` (in `usePortfolioData`) calls `hookLoadFromGoogleDrive` and then `setAssets`.
   - `setAssets` triggers a re-render.
   - On re-render, if `loadFromGoogleDrive` is recreated, the effect runs again.
   - `loadFromGoogleDrive` depends on `hookLoadFromGoogleDrive`.
   - `hookLoadFromGoogleDrive` (in `useGoogleDriveSync`) depends on `options`.
   - If `options` changes, `hookLoadFromGoogleDrive` changes -> `loadFromGoogleDrive` changes -> `useEffect` runs -> `setAssets` -> re-render.

3. **Infinite Migration Loop**:
   - `loadFromGoogleDrive` runs `runMigrationIfNeeded`.
   - This logs "Migration started...".
   - If this cycle repeats, you see the logs flooding.

## Fix Strategy

### 1. Stabilize `useGoogleDriveSync`
- Remove `options` from the dependency array of `loadFromGoogleDrive` and `autoSave`.
- Use `useRef` for `options` to access the latest callbacks without adding them to dependencies.

### 2. Fix `usePortfolioData.ts`
- Remove `loadFromGoogleDrive` from the `useEffect` dependency array.
- Instead, use a flag or check `isSignedIn` transition to ensure `loadFromGoogleDrive` runs only once when the user signs in.
- Alternatively, keep `loadFromGoogleDrive` in deps but ensure it's strictly stable. Given the complexity, removing it from deps and handling the trigger logic carefully is safer.

## Implementation Steps

1. **Modify `hooks/useGoogleDriveSync.ts`**:
   - Wrap `options` in a `useRef` to keep it up-to-date without triggering effect re-runs.
   - Update `handleSignIn`, `handleSignOut`, `loadFromGoogleDrive`, `autoSave` to use `optionsRef.current`.
   - Remove `options` from their dependency arrays.

2. **Modify `hooks/usePortfolioData.ts`**:
   - Refactor the `useEffect` responsible for initial loading.
   - Create a `hasLoaded` ref or state to prevent re-fetching after a successful load, OR simply ensure the effect only runs when `isSignedIn` changes from `false` to `true`.

## Verification
- Confirm the "Migration" logs stop repeating.
- Confirm the network requests stop flooding.
- Verify that data still loads correctly upon sign-in.
</file>

<file path=".trae/documents/Fix JSON Import Flow in App.md">
## 문제 진단
- UI 트리거: `Header`가 `onImport={fullImportHandler}`로 연결됨 (`components/Header.tsx`, `App.tsx:426–437`).
- 실제 처리: `App.tsx:329–374`의 `fullImportHandler`가 파일을 읽고 `JSON.parse`까지만 수행하며 상태 업데이트가 없음.
- 보조 핸들러: `handleImportAssetsFromFile`도 동일하게 파싱 후 상태 반영 로직이 미완성 (`App.tsx:263–326`).
- 매핑 유틸: `mapToNewAssetStructure`가 `hooks/usePortfolioData.ts` 내부에 존재하며 훅 반환값으로 제공되지만 `App.tsx`에서 구조분해에 포함되지 않아 사용되고 있지 않음 (`hooks/usePortfolioData.ts:65–63, 181–203`).
- 마이그레이션 유틸: `runMigrationIfNeeded`가 존재하여 불러온 데이터의 정합성을 보정 가능 (`utils/migrateData.ts`).

## 수정 계획
1. `fullImportHandler` 완성
- 파일 선택 → `JSON.parse` → `runMigrationIfNeeded(loadedData)` 적용
- 구조 추출: `assets`, `portfolioHistory`, `sellHistory`, `watchlist`, `exchangeRates`
- 자산 배열을 `mapToNewAssetStructure`로 변환
- `updateAllData(newAssets, newHistory, newSells, newWatchlist, sanitizedRates)` 호출
- 성공/에러 메시지 처리 및 자동 저장 트리거는 `updateAllData` 내부에 위임

2. 훅 반환값 확장 사용
- `usePortfolioData()` 구조분해에 `mapToNewAssetStructure`를 포함하도록 `App.tsx` 상단 구조분해 갱신 (`App.tsx:24–41`).

3. 중복 핸들러 정리
- `handleImportAssetsFromFile`를 `fullImportHandler`로 통합하거나 `fullImportHandler`만 사용하도록 유지 (현재 `Header`는 `fullImportHandler`에 연결되어 있으므로, 동작 보장 위해 `fullImportHandler`만 보완).

4. 예외 처리 강화
- `JSON.parse` 실패 → 사용자 메시지
- 예상 구조 없음/빈 배열 → 기본값으로 대체
- `exchangeRates` 유효성 보정: USD ≥ 100, JPY ≥ 1; 없으면 기본값 `{ USD:1450, JPY:9.5 }`

5. README 업데이트
- "가져오기/내보내기" 섹션에 동작 흐름과 데이터 매핑·마이그레이션 규칙, 로그인 요구사항을 명시.

## 구현 포인트
- 상태 반영: `updateAllData` 호출로 자산/히스토리/환율 일괄 반영 (`hooks/usePortfolioData.ts:163–179`).
- 매핑: `mapToNewAssetStructure`를 통해 이전 포맷 자산을 현재 스키마로 변환 (`hooks/usePortfolioData.ts:6–63`).
- 마이그레이션: `runMigrationIfNeeded`로 암호화폐 및 외화 자산 가격/통화 보정 (`utils/migrateData.ts`).

## 예상 변경 코드 (요지)
- `App.tsx:329–374` 내 `fullImportHandler`에서 파일 파싱 후 아래 순서 수행:
  - `const migrated = runMigrationIfNeeded(loadedData)`
  - `const rawAssets = Array.isArray(migrated.assets) ? migrated.assets : Array.isArray(migrated) ? migrated : []`
  - `const newAssets = rawAssets.map(mapToNewAssetStructure)`
  - `const newHistory = Array.isArray(migrated.portfolioHistory) ? migrated.portfolioHistory : []`
  - `const newSells = Array.isArray(migrated.sellHistory) ? migrated.sellHistory : []`
  - `const newWatchlist = Array.isArray(migrated.watchlist) ? migrated.watchlist : []`
  - `const rates = migrated.exchangeRates ?? { USD:1450, JPY:9.5 }` → 유효성 보정
  - `updateAllData(newAssets, newHistory, newSells, newWatchlist, rates)`
  - 성공 메시지 설정

## 검증 계획
- 로컬에서 샘플 JSON으로 테스트: (1) 전체 객체 구조, (2) 자산 배열만, (3) 잘못된 JSON
- 마이그레이션 로그 확인 (`utils/migrateData.ts`의 console.log 동작)
- 가져오기 이후 UI 반영: 대시보드/포트폴리오 탭에서 자산·환율·히스토리 내용 확인

## 리스크 및 완화
- 대형 JSON 파싱 시 UI 블록: FileReader는 비동기이므로 영향 제한적
- 예상 외 필드: 안전한 기본값 적용 및 빈 배열 처리
- 훅 반환에 `mapToNewAssetStructure` 포함으로 순환 참조 위험은 없음 (함수 레벨 반환)

이 계획대로 수정해도 될까요? 승인되면 구현을 진행하고 테스트까지 완료한 후 결과를 공유하겠습니다.
</file>

<file path=".trae/documents/Refactor App.tsx into Modular Hooks and Layouts.md">
# App.tsx Refactoring Plan

The goal is to modularize `App.tsx` into domain-specific hooks and layout components to improve maintainability while ensuring system stability.

## 1. Directory Structure Changes
- Create `src/components/layouts/`
- Create `src/hooks/usePortfolioData.ts`
- Create `src/hooks/useAssetActions.ts`
- Create `src/hooks/useMarketData.ts`

## 2. Implementation Steps

### Step 1: Create `src/hooks/usePortfolioData.ts`
This hook will act as the "Single Source of Truth" for data.
- **State Management**: `assets`, `portfolioHistory`, `sellHistory`, `watchlist`, `exchangeRates`, `isLoading`, `error`, `successMessage`.
- **Integrations**: `useGoogleDriveSync` (Auth & Sync).
- **Core Logic**: 
  - Initial data loading (`loadFromGoogleDrive`).
  - Data migration (`runMigrationIfNeeded`).
  - `saveToDrive` (Manual save).
  - `autoSave` wrapper (Triggered on data changes).

### Step 2: Create `src/hooks/useMarketData.ts`
This hook handles all external price fetching logic.
- **Dependencies**: Receives state and setters from `usePortfolioData`.
- **Logic**:
  - `handleRefreshAllPrices` (Batch update).
  - `handleRefreshSelectedPrices`.
  - `handleRefreshOnePrice`.
  - `handleRefreshWatchlistPrices`.
  - `handleExchangeRatesChange`.
- **Stability**: Ensure `autoSave` is triggered after successful price updates.

### Step 3: Create `src/hooks/useAssetActions.ts`
This hook handles user-driven asset modifications.
- **Dependencies**: Receives state and setters from `usePortfolioData`.
- **Logic**:
  - `handleAddAsset`
  - `handleEditAsset` / `handleUpdateAsset`
  - `handleDeleteAsset`
  - `handleSellAsset` / `handleConfirmSell`
  - `handleCsvFileUpload`
  - Watchlist management actions (`handleAddWatchItem`, etc.)

### Step 4: Create Layout Components
Move JSX from `App.tsx` into focused components.
- **`src/components/layouts/DashboardView.tsx`**: Charts, Stats, Summary.
- **`src/components/layouts/PortfolioView.tsx`**: `PortfolioTable`, `SellAlertControl`.
- **`src/components/layouts/AnalyticsView.tsx`**: `SellAnalyticsPage`.
- **`src/components/layouts/WatchlistView.tsx`**: `WatchlistPage`.

### Step 5: Refactor `App.tsx`
- Integrate the new hooks.
- Replace massive JSX blocks with the new layout components.
- Manage top-level routing (Tab state) and global modals (Settings, Import/Export).

## 3. Stability & Safety Checks
- **Dependency Arrays**: Carefully verify `useCallback` and `useEffect` dependencies in new hooks to prevent stale state.
- **Auto-Save**: Confirm `autoSave` is consistently called after every state mutation (CRUD, Price Update).
- **Type Safety**: Strictly define Props interfaces for new components and Hook return types.
- **No Logic Change**: This is a pure refactoring; no business logic will be altered.

## 4. Verification
- **Build Check**: Run `tsc` to ensure no type errors.
- **Runtime Check**: Verify "Add Asset", "Refresh Price", and "Switch Tabs" functionalities after refactoring.
</file>

<file path="components/AssetTrendChart.tsx">
import React, { useMemo } from 'react';
import { PortfolioSnapshot } from '../types';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';

interface AssetTrendChartProps {
  history: PortfolioSnapshot[];
  assetId: string;
  assetName: string;
  currentQuantity: number; // [추가] 역산용 현재 수량
}

const AssetTrendChart: React.FC<AssetTrendChartProps> = ({ history, assetId, assetName, currentQuantity }) => {
  const chartData = useMemo(() => {
    if (!history || history.length === 0) {
      return [];
    }

    const data = history.map(snapshot => {
      const assetSnapshot = snapshot.assets.find(a => a.id === assetId);
      
      let price = 0;
      if (assetSnapshot) {
        // 1순위: 기록된 단가 사용
        if (assetSnapshot.unitPrice !== undefined && assetSnapshot.unitPrice > 0) {
            price = assetSnapshot.unitPrice;
        } 
        // 2순위: 단가가 없으면(과거 데이터) 현재가치 / 수량으로 역산 (수량 불변 가정)
        else if (currentQuantity > 0) {
            price = assetSnapshot.currentValue / currentQuantity;
        }
      }
      
      return {
        date: new Date(snapshot.date).toLocaleDateString('ko-KR', { month: '2-digit', day: '2-digit' }),
        '현재가': Math.round(price), // 소수점 제거
      };
    }).filter(d => d['현재가'] > 0);

    return data;
  }, [history, assetId, assetName, currentQuantity]);

  const formatCurrency = (value: number) => {
    return value.toLocaleString('ko-KR', { maximumFractionDigits: 0 });
  };

  return (
    <div className="bg-gray-800 p-4 rounded-lg h-64">
      <h3 className="text-md font-bold text-white mb-4 text-center">{`"${assetName}" 현재가 추이`}</h3>
      {chartData.length > 1 ? (
        <ResponsiveContainer width="100%" height="85%">
          <LineChart data={chartData} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
            <CartesianGrid strokeDasharray="3 3" stroke="#4A5568" />
            <XAxis dataKey="date" stroke="#A0AEC0" fontSize={12} />
            <YAxis stroke="#A0AEC0" fontSize={12} tickFormatter={formatCurrency} width={80} domain={['auto', 'auto']} />
            <Tooltip
              formatter={(value: number) => [`${formatCurrency(value)} 원`, '현재가']}
              contentStyle={{ backgroundColor: '#2D3748', border: '1px solid #4A5568', borderRadius: '0.5rem' }}
              labelStyle={{ color: '#E2E8F0' }}
              itemStyle={{ fontWeight: 'bold', color: '#818CF8' }}
            />
            <Legend wrapperStyle={{fontSize: "12px", bottom: -10}} />
            <Line type="monotone" dataKey="현재가" stroke="#818CF8" strokeWidth={2} dot={{ r: 3 }} activeDot={{ r: 6 }} />
          </LineChart>
        </ResponsiveContainer>
      ) : (
        <div className="flex items-center justify-center h-full">
          <p className="text-gray-500 text-sm">추이 데이터가 부족합니다.</p>
        </div>
      )}
    </div>
  );
};

export default AssetTrendChart;
</file>

<file path="components/CategorySummaryTable.tsx">
import React, { useMemo } from 'react';
import { Asset, AssetCategory, Currency, ExchangeRates } from '../types';

interface CategorySummaryTableProps {
    assets: Asset[];
    totalPortfolioValue: number;
    exchangeRates: ExchangeRates;
}

interface SummaryData {
    category: AssetCategory;
    totalValue: number;
    totalProfitLoss: number;
    totalReturn: number;
    allocation: number;
}

const CategorySummaryTable: React.FC<CategorySummaryTableProps> = ({ assets, totalPortfolioValue, exchangeRates }) => {
    const summaryData = useMemo((): SummaryData[] => {
        const categoryMap = new Map<AssetCategory, { totalValue: number; totalPurchaseValue: number }>();

        assets.forEach(asset => {
            if (!categoryMap.has(asset.category)) {
                categoryMap.set(asset.category, { totalValue: 0, totalPurchaseValue: 0 });
            }
            const data = categoryMap.get(asset.category)!;

            // [수정] 현재가 환율 적용
            const rate = asset.currency === Currency.KRW ? 1 : (exchangeRates[asset.currency] || 0);
            const currentValueKRW = asset.currentPrice * asset.quantity * rate;
            
            data.totalValue += currentValueKRW;

            // [수정] 매수가 계산 로직 (기존 로직 유지하되 안전장치 추가)
            let purchaseValueKRW;
            if (asset.currency === Currency.KRW) {
                purchaseValueKRW = asset.purchasePrice * asset.quantity;
            } else if (asset.purchaseExchangeRate) {
                purchaseValueKRW = asset.purchasePrice * asset.purchaseExchangeRate * asset.quantity;
            } else if (asset.priceOriginal > 0) {
                const impliedRate = asset.currentPrice / asset.priceOriginal;
                purchaseValueKRW = asset.purchasePrice * impliedRate * asset.quantity;
            } else {
                purchaseValueKRW = asset.purchasePrice * asset.quantity * rate;
            }
            data.totalPurchaseValue += purchaseValueKRW;
        });

        const result: SummaryData[] = [];
        for (const [category, data] of categoryMap.entries()) {
            const totalProfitLoss = data.totalValue - data.totalPurchaseValue;
            const totalReturn = data.totalPurchaseValue === 0 ? 0 : (totalProfitLoss / data.totalPurchaseValue) * 100;
            const allocation = totalPortfolioValue > 0 ? (data.totalValue / totalPortfolioValue) * 100 : 0;
            result.push({
                category,
                totalValue: data.totalValue,
                totalProfitLoss,
                totalReturn,
                allocation,
            });
        }
        
        return result.sort((a, b) => b.totalValue - a.totalValue);

    }, [assets, totalPortfolioValue, exchangeRates]);

    const formatKRW = (num: number) => {
        return new Intl.NumberFormat('ko-KR', { style: 'currency', currency: 'KRW', maximumFractionDigits: 0 }).format(num);
    };

    const getChangeColor = (value: number) => {
        if (value > 0) return 'text-success';
        if (value < 0) return 'text-danger';
        return 'text-gray-400';
    };

    if (summaryData.length === 0) return null;

    return (
        <div className="bg-gray-800 p-6 rounded-lg shadow-lg" title="자산 종류별 요약 정보입니다.">
            <h2 className="text-xl font-bold text-white mb-4">자산군별 요약</h2>
            <div className="w-full overflow-x-auto">
                <table className="w-full text-sm text-left text-gray-400">
                    <thead className="text-xs text-gray-300 uppercase bg-gray-700">
                        <tr>
                            <th scope="col" className="px-4 py-2">자산 구분</th>
                            <th scope="col" className="px-4 py-2 text-right">평가금액</th>
                            <th scope="col" className="px-4 py-2 text-right">손익</th>
                            <th scope="col" className="px-4 py-2 text-right">수익률</th>
                            <th scope="col" className="px-4 py-2 text-right">비중</th>
                        </tr>
                    </thead>
                    <tbody>
                        {summaryData.map(item => (
                            <tr key={item.category} className="border-b border-gray-700">
                                <td className="px-4 py-3 font-medium text-white">{item.category}</td>
                                <td className="px-4 py-3 text-right">{formatKRW(item.totalValue)}</td>
                                <td className={`px-4 py-3 text-right font-medium ${getChangeColor(item.totalProfitLoss)}`}>{formatKRW(item.totalProfitLoss)}</td>
                                <td className={`px-4 py-3 text-right font-medium ${getChangeColor(item.totalReturn)}`}>{item.totalReturn.toFixed(2)}%</td>
                                <td className="px-4 py-3 text-right">{item.allocation.toFixed(2)}%</td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </div>
    );
};

export default CategorySummaryTable;
</file>

<file path="components/common/Toggle.tsx">
import React from 'react';

interface ToggleProps {
  label?: string;
  checked: boolean;
  onChange: (checked: boolean) => void;
  className?: string;
  title?: string;
}

const Toggle: React.FC<ToggleProps> = ({ label, checked, onChange, className = '', title }) => {
  return (
    <label className={`flex items-center cursor-pointer ${className}`} title={title}>
      <div className="relative">
        <input
          type="checkbox"
          className="sr-only"
          checked={checked}
          onChange={(e) => onChange(e.target.checked)}
        />
        <div className={`block ${checked ? 'bg-primary' : 'bg-gray-600'} w-10 h-6 rounded-full transition-colors duration-300 ease-in-out`}></div>
        <div className={`absolute left-1 top-1 w-4 h-4 rounded-full bg-white transition-transform duration-300 ease-in-out ${checked ? 'transform translate-x-full' : ''}`}></div>
      </div>
      {label && (
        <div className="ml-3 text-sm font-medium text-gray-300">{label}</div>
      )}
    </label>
  );
};

export default Toggle;
</file>

<file path="components/Header.tsx">
import React, { useEffect, useState } from 'react';

interface HeaderProps {
  onSave: () => void;
  onImport: () => void;
  onExport: () => void;
  onExportToCsv: () => void;
  onOpenBulkUploadModal: () => void;
  onOpenAddAssetModal: () => void;
  onSignIn?: () => void;
  onSignOut?: () => void;
  isSignedIn?: boolean;
  userEmail?: string | null;
}

const Header: React.FC<HeaderProps> = ({ 
  onSave, 
  onImport, 
  onExport, 
  onExportToCsv, 
  onOpenBulkUploadModal, 
  onOpenAddAssetModal,
  onSignIn,
  onSignOut,
  isSignedIn = false,
  userEmail,
}) => {
  const [showAdvancedMenu, setShowAdvancedMenu] = useState(false);

  useEffect(() => {
    if (!isSignedIn) {
      setShowAdvancedMenu(false);
    }
  }, [isSignedIn]);

  return (
    <header className="mb-8">
      <div className="flex justify-between items-start sm:items-center flex-col sm:flex-row">
        <div>
          <h1 className="text-4xl font-bold text-white tracking-tight" title="나의 자산 포트폴리오를 관리하는 대시보드입니다.">
            KIM'S 퀸트자산관리
          </h1>
          <p className="text-gray-400 mt-2" title="계량적 투자 전략을 기반으로 자산을 분석하고 추적합니다.">
            퀀트 투자를 위한 포트폴리오 대시보드
          </p>
        </div>
        <div className="flex items-center justify-end flex-wrap gap-2 mt-4 sm:mt-0">
          {isSignedIn ? (
            <div className="flex items-center gap-2">
              <span className="text-sm text-gray-400" title={`Google 계정으로 로그인됨: ${userEmail}`}>
                {userEmail}
              </span>
              <button
                onClick={onSignOut}
                className="bg-gray-700 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-md transition duration-300"
                title="Google 계정에서 로그아웃합니다."
              >
                로그아웃
              </button>
            </div>
          ) : (
            <button
              onClick={onSignIn}
              className="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition duration-300 flex items-center gap-2"
              title="Google 계정으로 로그인하여 Google Drive에 저장합니다."
            >
              <svg className="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4"/>
                <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853"/>
                <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05"/>
                <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335"/>
              </svg>
              로그인
            </button>
          )}
          {isSignedIn && (
            <>
              <button
                onClick={onOpenAddAssetModal}
                className="bg-primary hover:bg-primary-dark text-white font-bold py-2 px-4 rounded-md transition duration-300"
                title="새로운 자산을 포트폴리오에 추가합니다."
              >
                신규 자산 추가
              </button>
              <button
                onClick={onSave}
                className="bg-emerald-600 hover:bg-emerald-500 text-white font-semibold py-2 px-4 rounded-md transition duration-300"
                title="현재 포트폴리오를 Google Drive에 즉시 저장합니다."
              >
                즉시 저장
              </button>
              
              {/* 고급 기능 드롭다운 메뉴 */}
              <div className="relative">
                <button
                  onClick={() => setShowAdvancedMenu(!showAdvancedMenu)}
                  className="bg-gray-700 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded-md transition duration-300 flex items-center gap-1"
                  title="백업 및 일괄 등록 기능 메뉴"
                >
                  고급 기능
                  <svg className={`w-4 h-4 transition-transform ${showAdvancedMenu ? 'rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                  </svg>
                </button>
                
                {showAdvancedMenu && (
                  <div className="absolute right-0 mt-2 w-64 bg-gray-800 border border-gray-600 rounded-md shadow-lg z-50">
                    <div className="p-2">
                      <p className="text-xs text-gray-400 mb-2 px-2">
                        Google Drive에 저장된 데이터를 손쉽게 백업하거나 일괄 등록할 수 있습니다.
                      </p>
                      <div className="space-y-1">
                        <button
                          onClick={() => {
                            onOpenBulkUploadModal();
                            setShowAdvancedMenu(false);
                          }}
                          className="w-full text-left px-3 py-2 text-sm text-gray-300 hover:bg-gray-700 rounded transition"
                          title="CSV 파일로 여러 자산을 한 번에 등록합니다."
                        >
                          <div className="font-medium">일괄 등록</div>
                          <div className="text-xs text-gray-500">CSV 파일로 여러 자산을 한 번에 등록</div>
                        </button>
                        <button
                          onClick={() => {
                            onImport();
                            setShowAdvancedMenu(false);
                          }}
                          className="w-full text-left px-3 py-2 text-sm text-gray-300 hover:bg-gray-700 rounded transition"
                          title="JSON 파일에서 포트폴리오를 불러옵니다. (현재 데이터 덮어쓰기)"
                        >
                          <div className="font-medium">가져오기</div>
                          <div className="text-xs text-gray-500">JSON 파일에서 포트폴리오 불러오기</div>
                        </button>
                        <button
                          onClick={() => {
                            onExport();
                            setShowAdvancedMenu(false);
                          }}
                          className="w-full text-left px-3 py-2 text-sm text-gray-300 hover:bg-gray-700 rounded transition"
                          title="현재 포트폴리오를 JSON 파일로 백업합니다."
                        >
                          <div className="font-medium">내보내기</div>
                          <div className="text-xs text-gray-500">현재 포트폴리오를 JSON 파일로 백업</div>
                        </button>
                    <button
                      onClick={() => {
                        onSave();
                        setShowAdvancedMenu(false);
                      }}
                      className="w-full text-left px-3 py-2 text-sm text-gray-300 hover:bg-gray-700 rounded transition"
                      title="현재 데이터를 Google Drive에 즉시 저장합니다."
                    >
                      <div className="font-medium">Google Drive 저장</div>
                      <div className="text-xs text-gray-500">자동 저장 대기 없이 즉시 저장</div>
                    </button>
                        <button
                          onClick={() => {
                            onExportToCsv();
                            setShowAdvancedMenu(false);
                          }}
                          className="w-full text-left px-3 py-2 text-sm text-gray-300 hover:bg-gray-700 rounded transition"
                          title="현재 포트폴리오를 CSV 파일로 내보냅니다."
                        >
                          <div className="font-medium">CSV로 내보내기</div>
                          <div className="text-xs text-gray-500">현재 포트폴리오를 CSV 파일로 내보내기</div>
                        </button>
                      </div>
                    </div>
                  </div>
                )}
              </div>
              
              {/* 메뉴 외부 클릭 시 닫기 */}
              {showAdvancedMenu && (
                <div 
                  className="fixed inset-0 z-40" 
                  onClick={() => setShowAdvancedMenu(false)}
                />
              )}
            </>
          )}
        </div>
      </div>
    </header>
  );
};

export default Header;
</file>

<file path="components/portfolio-table/utils.ts">
import { Currency, CURRENCY_SYMBOLS, ExchangeRates } from '../../types';

export const getValueInKRW = (
  value: number, 
  currency: Currency, 
  exchangeRates: ExchangeRates
): number => {
  switch (currency) {
    case Currency.USD: return value * (exchangeRates.USD || 0);
    case Currency.JPY: return value * (exchangeRates.JPY || 0);
    case Currency.KRW: default: return value;
  }
};

export const formatNumber = (num: number) => new Intl.NumberFormat('ko-KR', { maximumFractionDigits: 0 }).format(num);

export const formatKRW = (num: number) => new Intl.NumberFormat('ko-KR', { style: 'currency', currency: 'KRW', maximumFractionDigits: 0 }).format(num);

export const formatOriginalCurrency = (num: number, currency: Currency) => {
  const symbol = CURRENCY_SYMBOLS[currency];
  if (currency === Currency.KRW || currency === Currency.JPY) {
       return `${symbol}${formatNumber(num)}`;
  }
  return `${symbol}${new Intl.NumberFormat('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 2 }).format(num)}`;
};

export const formatProfitLoss = (num: number, currency: Currency) => {
  const sign = num >= 0 ? '+' : '';
  if (currency === Currency.KRW) {
    return `${sign}${formatKRW(num)}`;
  }
  return `${sign}${formatOriginalCurrency(num, currency)}`;
};

export const getChangeColor = (value: number) => (value > 0 ? 'text-success' : value < 0 ? 'text-danger' : 'text-gray-400');
</file>

<file path="components/RebalancingTable.tsx">
import React, { useMemo, useState, useEffect } from 'react';
import { Asset, AssetCategory, ExchangeRates, Currency } from '../types';

interface RebalancingTableProps {
  assets: Asset[];
  exchangeRates: ExchangeRates;
}

interface CategoryData {
  category: AssetCategory;
  currentValue: number;
  currentWeight: number;
  targetWeight: number;
  targetValue: number;
  difference: number;
}

const RebalancingTable: React.FC<RebalancingTableProps> = ({ assets, exchangeRates }) => {
  // --- 1. Calculate Current Values & Weights ---
  const { categoryValues, totalCurrentValue } = useMemo(() => {
    const values: Record<string, number> = {};
    let total = 0;

    assets.forEach((asset) => {
      const rate = asset.currency === Currency.KRW ? 1 : (exchangeRates[asset.currency] || 0);
      const val = asset.currentPrice * asset.quantity * rate;
      values[asset.category] = (values[asset.category] || 0) + val;
      total += val;
    });

    return { categoryValues: values, totalCurrentValue: total };
  }, [assets, exchangeRates]);

  // --- 2. State ---
  // Initialize targetTotalAmount with current total value
  const [targetTotalAmount, setTargetTotalAmount] = useState<number>(0);
  
  // Initialize targetWeights with current weights
  const [targetWeights, setTargetWeights] = useState<Record<string, number>>({});

  // Effect to update state when data loads or changes significantly (optional, but good for UX)
  // We only set initial values if they are not set yet (or maybe we want to reset? Let's stick to init)
  useEffect(() => {
    if (totalCurrentValue > 0 && targetTotalAmount === 0) {
        setTargetTotalAmount(totalCurrentValue);
        
        const initialWeights: Record<string, number> = {};
        Object.keys(categoryValues).forEach(cat => {
            initialWeights[cat] = (categoryValues[cat] / totalCurrentValue) * 100;
        });
        setTargetWeights(prev => {
            // Only update if empty to preserve user input during re-renders
             if (Object.keys(prev).length === 0) return initialWeights;
             return prev;
        });
    }
  }, [totalCurrentValue, categoryValues, targetTotalAmount]);


  // --- 3. Calculate Table Data ---
  const tableData: CategoryData[] = useMemo(() => {
    // Get all unique categories from assets + any keys in targetWeights
    const categories = Array.from(new Set([
        ...Object.keys(categoryValues),
        ...Object.keys(targetWeights)
    ])) as AssetCategory[];

    return categories.map(category => {
        const currentValue = categoryValues[category] || 0;
        const currentWeight = totalCurrentValue > 0 ? (currentValue / totalCurrentValue) * 100 : 0;
        const targetWeight = targetWeights[category] || 0;
        const targetValue = (targetTotalAmount * targetWeight) / 100;
        const difference = targetValue - currentValue;

        return {
            category,
            currentValue,
            currentWeight,
            targetWeight,
            targetValue,
            difference
        };
    }).sort((a, b) => b.currentValue - a.currentValue); // Sort by current value desc
  }, [categoryValues, totalCurrentValue, targetTotalAmount, targetWeights]);

  // Calculate totals for footer
  const totalTargetWeight = tableData.reduce((sum, item) => sum + item.targetWeight, 0);
  const totalTargetValue = tableData.reduce((sum, item) => sum + item.targetValue, 0);
  const totalDifference = tableData.reduce((sum, item) => sum + item.difference, 0);


  // --- Handlers ---
  const handleWeightChange = (category: string, value: string) => {
    const numVal = parseFloat(value);
    setTargetWeights(prev => ({
        ...prev,
        [category]: isNaN(numVal) ? 0 : numVal
    }));
  };

  const handleTotalAmountChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      // Remove commas for parsing
      const rawValue = e.target.value.replace(/,/g, '');
      const numVal = parseFloat(rawValue);
      setTargetTotalAmount(isNaN(numVal) ? 0 : numVal);
  };

  // --- Helpers ---
  const formatKRW = (num: number) => {
    return new Intl.NumberFormat('ko-KR', { style: 'currency', currency: 'KRW', maximumFractionDigits: 0 }).format(num);
  };
  
  const formatNumber = (num: number) => {
      return new Intl.NumberFormat('ko-KR').format(num);
  }

  const getDiffColor = (val: number) => {
      if (val > 0) return 'text-red-400'; // Buying needed (usually red/positive in stock apps? or maybe just distinct color)
      // Actually, standard: Red for Buy (+), Blue for Sell (-) in KR logic often, but let's stick to Green/Red logic if used elsewhere.
      // In DashboardView: Profit is text-success (Green?), Loss is text-danger (Red?).
      // Let's use text-red-400 for Buy (+) and text-blue-400 for Sell (-) to match typical Korean MTS style if applicable, 
      // or just Green for Positive (Buy) and Red for Negative (Sell)?
      // The prompt says: "+면 매수, -면 매도". 
      // Usually + (Buy) means we need to spend money. - (Sell) means we get money.
      // Let's use: Positive (Buy) -> Red (Active/Action), Negative (Sell) -> Blue (Passive/Release). 
      // Or stick to: Positive -> Success color, Negative -> Danger color. 
      // Let's check CategorySummaryTable: Profit > 0 is text-success (likely green), Loss < 0 is text-danger (likely red).
      // Here: Positive diff means "Buy". Negative diff means "Sell".
      if (val > 0) return 'text-red-400 font-bold'; // Buy
      if (val < 0) return 'text-blue-400 font-bold'; // Sell
      return 'text-gray-400';
  };

  return (
    <div className="bg-gray-800 p-6 rounded-lg shadow-lg">
      <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 gap-4">
        <h2 className="text-xl font-bold text-white">포트폴리오 리밸런싱 (배분표)</h2>
        <div className="flex items-center gap-2">
            <label htmlFor="targetTotal" className="text-sm font-medium text-gray-300 whitespace-nowrap">
                목표 총 자산 (KRW):
            </label>
            <input
                id="targetTotal"
                type="text"
                value={formatNumber(targetTotalAmount)}
                onChange={handleTotalAmountChange}
                className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-right focus:outline-none focus:ring-2 focus:ring-blue-500 w-40 sm:w-56"
            />
        </div>
      </div>

      <div className="overflow-x-auto">
        <table className="w-full text-sm text-left text-gray-400">
            <thead className="text-xs text-gray-300 uppercase bg-gray-700">
                <tr>
                    <th className="px-4 py-3">자산군</th>
                    <th className="px-4 py-3 text-right">현재금액</th>
                    <th className="px-4 py-3 text-right">현재비중</th>
                    <th className="px-4 py-3 text-right bg-gray-600 bg-opacity-30 border-b-2 border-blue-500">목표비중 (%)</th>
                    <th className="px-4 py-3 text-right">목표금액</th>
                    <th className="px-4 py-3 text-right">매수/매도 필요액</th>
                </tr>
            </thead>
            <tbody>
                {tableData.map((row) => (
                    <tr key={row.category} className="border-b border-gray-700 hover:bg-gray-750">
                        <td className="px-4 py-3 font-medium text-white">{row.category}</td>
                        <td className="px-4 py-3 text-right">{formatKRW(row.currentValue)}</td>
                        <td className="px-4 py-3 text-right">{row.currentWeight.toFixed(2)}%</td>
                        <td className="px-4 py-3 text-right">
                            <input
                                type="number"
                                min="0"
                                max="100"
                                step="0.1"
                                value={row.targetWeight}
                                onChange={(e) => handleWeightChange(row.category, e.target.value)}
                                className="bg-gray-700 border border-gray-600 rounded px-2 py-1 text-right text-white w-20 focus:outline-none focus:ring-1 focus:ring-blue-500"
                            />
                        </td>
                        <td className="px-4 py-3 text-right text-gray-300">{formatKRW(row.targetValue)}</td>
                        <td className={`px-4 py-3 text-right ${getDiffColor(row.difference)}`}>
                            {row.difference > 0 ? '+' : ''}{formatKRW(row.difference)}
                        </td>
                    </tr>
                ))}
                
                {/* Total Row */}
                <tr className="bg-gray-750 font-bold border-t-2 border-gray-600">
                    <td className="px-4 py-3 text-white">합계</td>
                    <td className="px-4 py-3 text-right">{formatKRW(totalCurrentValue)}</td>
                    <td className="px-4 py-3 text-right">100.00%</td>
                    <td className={`px-4 py-3 text-right ${Math.abs(totalTargetWeight - 100) > 0.1 ? 'text-yellow-400' : 'text-green-400'}`}>
                        {totalTargetWeight.toFixed(2)}%
                    </td>
                    <td className="px-4 py-3 text-right">{formatKRW(totalTargetValue)}</td>
                    <td className="px-4 py-3 text-right text-white">
                        {/* The total difference should mathematically be (Target Total - Current Total) */}
                        {formatKRW(totalDifference)}
                    </td>
                </tr>
            </tbody>
        </table>
      </div>
      <div className="mt-4 text-xs text-gray-400 text-right">
        * 목표 비중 합계가 100%가 되도록 설정해주세요.
        <br />
        * 매수/매도 필요액이 (+)인 경우 매수, (-)인 경우 매도가 필요함을 의미합니다.
      </div>
    </div>
  );
};

export default RebalancingTable;
</file>

<file path="components/TopBottomAssets.tsx">
import React, { useMemo } from 'react';
import { Asset, Currency } from '../types';

interface TopBottomAssetsProps {
    assets: Asset[];
}

interface EnrichedAsset extends Asset {
    metrics: {
        returnPercentage: number;
        profitLoss: number;
    }
}

const TopBottomAssets: React.FC<TopBottomAssetsProps> = ({ assets }) => {
    const enrichedAssets = useMemo((): EnrichedAsset[] => {
        return assets.map(asset => {
            const currentValue = asset.currentPrice * asset.quantity;
            
            let purchaseValueKRW;
            if (asset.currency === Currency.KRW) {
                purchaseValueKRW = asset.purchasePrice * asset.quantity;
            } else if (asset.purchaseExchangeRate) {
                purchaseValueKRW = asset.purchasePrice * asset.purchaseExchangeRate * asset.quantity;
            } else if (asset.priceOriginal > 0) {
                const exchangeRate = asset.currentPrice / asset.priceOriginal;
                purchaseValueKRW = asset.purchasePrice * exchangeRate * asset.quantity;
            } else {
                purchaseValueKRW = asset.purchasePrice * asset.quantity;
            }

            const profitLoss = currentValue - purchaseValueKRW;
            const returnPercentage = purchaseValueKRW === 0 ? 0 : (profitLoss / purchaseValueKRW) * 100;
            
            return {
                ...asset,
                metrics: {
                    returnPercentage,
                    profitLoss,
                }
            };
        });
    }, [assets]);

    const sortedAssets = useMemo(() => {
        return [...enrichedAssets].sort((a, b) => a.metrics.returnPercentage - b.metrics.returnPercentage);
    }, [enrichedAssets]);

    const bottomAssets = sortedAssets.slice(0, 5);
    const topAssets = sortedAssets.slice(-5).reverse();

    const formatKRW = (num: number) => {
        return new Intl.NumberFormat('ko-KR', { style: 'currency', currency: 'KRW', maximumFractionDigits: 0 }).format(num);
    };

    const getChangeColor = (value: number) => {
        if (value > 0) return 'text-success';
        if (value < 0) return 'text-danger';
        return 'text-gray-400';
    };

    const AssetListItem: React.FC<{asset: EnrichedAsset}> = ({ asset }) => (
        <li className="flex justify-between items-center py-2 border-b border-gray-700/50 last:border-b-0">
            <div className="flex-1 overflow-hidden">
                <p className="text-white font-medium truncate" title={(asset.customName?.trim() || asset.name)}>{(asset.customName?.trim() || asset.name)}</p>
                <p className="text-xs text-gray-500">{formatKRW(asset.metrics.profitLoss)}</p>
            </div>
            <div className={`text-right font-bold ml-4 ${getChangeColor(asset.metrics.returnPercentage)}`}>
                {asset.metrics.returnPercentage.toFixed(2)}%
            </div>
        </li>
    );

    if (assets.length === 0) {
        return null;
    }

    return (
        <div className="bg-gray-800 p-6 rounded-lg shadow-lg" title="수익률 기준 상위 및 하위 5개 자산 현황입니다.">
            <h2 className="text-xl font-bold text-white mb-4">자산별 성과 요약</h2>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-x-16 gap-y-6">
                <div>
                    <h3 className="text-lg font-semibold text-success mb-2">수익률 TOP 5</h3>
                    {topAssets.length > 0 ? (
                        <ul className="space-y-1">
                            {topAssets.map(asset => <AssetListItem key={asset.id} asset={asset} />)}
                        </ul>
                    ) : <p className="text-gray-500 text-sm">데이터가 없습니다.</p>}
                </div>
                <div>
                    <h3 className="text-lg font-semibold text-danger mb-2">수익률 BOTTOM 5</h3>
                    {bottomAssets.length > 0 ? (
                        <ul className="space-y-1">
                            {bottomAssets.map(asset => <AssetListItem key={asset.id} asset={asset} />)}
                        </ul>
                    ) : <p className="text-gray-500 text-sm">데이터가 없습니다.</p>}
                </div>
            </div>
        </div>
    );
};

export default TopBottomAssets;
</file>

<file path="contexts/PortfolioContext.tsx">
import React, { createContext, useContext, useMemo, useState, useCallback, useEffect } from 'react';
import {
  Asset,
  AssetCategory,
  Currency,
  ExchangeRates,
  PortfolioSnapshot,
  WatchlistItem,
  SellRecord,
  SellTransaction,
} from '../types';
import { usePortfolioData } from '../hooks/usePortfolioData';
import { useMarketData } from '../hooks/useMarketData';
import { useAssetActions } from '../hooks/useAssetActions';

/**
 * @description 포트폴리오 히스토리 스냅샷 배열 타입 별칭
 * @see types.ts: PortfolioSnapshot
 */
export type PortfolioHistory = PortfolioSnapshot[];

/**
 * @description 컨텍스트가 노출하는 핵심 데이터 집합
 */
export interface PortfolioData {
  assets: Asset[];
  portfolioHistory: PortfolioHistory;
  sellHistory: SellRecord[];
  watchlist: WatchlistItem[];
  exchangeRates: ExchangeRates;
}

/**
 * @description 컨텍스트가 노출하는 운영/인증/로딩 상태 집합
 */
export interface PortfolioStatus {
  isLoading: boolean;
  failedAssetIds: Set<string>;
  isSignedIn: boolean;
  userEmail: string | null;
  isInitializing: boolean;
  error: string | null;
  successMessage: string | null;
  showExchangeRateWarning: boolean;
}

/**
 * @description UI 상태(탭/필터/검색/알림 기준)
 */
export interface UIState {
  activeTab: 'dashboard' | 'portfolio' | 'analytics' | 'watchlist';
  dashboardFilterCategory: AssetCategory | 'ALL';
  filterCategory: AssetCategory | 'ALL';
  filterAlerts: boolean;
  searchQuery: string;
  sellAlertDropRate: number;
}

/**
 * @description 모달 및 선택 자산 상태
 */
export interface ModalState {
  editingAsset: Asset | null;
  sellingAsset: Asset | null;
  bulkUploadOpen: boolean;
  addAssetOpen: boolean;
  assistantOpen: boolean;
}

/**
 * @description 파생/계산 값 집합
 */
export interface DerivedState {
  totalValue: number;
  alertCount: number;
}

/**
 * @description 컨텍스트에서 제공하는 액션 집합(도메인/시세/관심종목/UI/모달)
 */
export interface PortfolioActions {
  // 저장/내보내기/가져오기
  saveToDrive: () => Promise<void>;
  exportJson: (fileName?: string) => Promise<void>;
  importJsonPrompt: () => void;
  exportCsv: () => Promise<void>;

  // 인증
  signIn: () => Promise<void>;
  signOut: () => Promise<void>;

  // 환율/시세
  setExchangeRates: (rates: ExchangeRates) => void;
  refreshAllPrices: (force?: boolean) => Promise<void>;
  refreshSelectedPrices: (ids: string[]) => Promise<void>;
  refreshOnePrice: (id: string) => Promise<void>;
  refreshWatchlistPrices: () => Promise<void>;

  // 자산
  addAsset: (asset: Asset) => Promise<void>;
  updateAsset: (asset: Asset) => Promise<void>;
  deleteAsset: (id: string) => void;
  confirmSell: (id: string, sellDate: string, sellPrice: number, sellQuantity: number, currency: Currency) => Promise<void>;
  addSelectedToWatchlist: (assets: Asset[]) => void;

  // 관심종목
  addWatchItem: (item: Omit<WatchlistItem, 'id' | 'currentPrice' | 'priceOriginal' | 'currency' | 'yesterdayPrice' | 'highestPrice' | 'lastSignalAt' | 'lastSignalType'>) => void;
  updateWatchItem: (item: WatchlistItem) => void;
  deleteWatchItem: (id: string) => void;
  toggleWatchMonitoring: (id: string, enabled: boolean) => void;
  bulkDeleteWatchItems: (ids: string[]) => void;

  // 메시지
  clearError: () => void;
  clearSuccessMessage: () => void;

  // 파일 업로드
  uploadCsv: (file: File) => Promise<import('../types').BulkUploadResult>;

  // UI/모달
  setActiveTab: (tab: UIState['activeTab']) => void;
  setDashboardFilterCategory: (c: UIState['dashboardFilterCategory']) => void;
  setFilterCategory: (c: UIState['filterCategory']) => void;
  setFilterAlerts: (v: boolean) => void;
  setSearchQuery: (q: string) => void;
  setSellAlertDropRate: (n: number) => void;
  openEditModal: (asset: Asset) => void;
  closeEditModal: () => void;
  openSellModal: (asset: Asset) => void;
  closeSellModal: () => void;
  openBulkUpload: () => void;
  closeBulkUpload: () => void;
  openAddAsset: () => void;
  closeAddAsset: () => void;
  openAssistant: () => void;
  closeAssistant: () => void;
}

/**
 * @description 포트폴리오 컨텍스트 전체 값
 */
export interface PortfolioContextValue {
  data: PortfolioData;
  status: PortfolioStatus;
  ui: UIState;
  modal: ModalState;
  derived: DerivedState;
  actions: PortfolioActions;
}

const PortfolioContext = createContext<PortfolioContextValue | null>(null);

/**
 * @description 포트폴리오 컨텍스트 제공자. 내부에서 기존 훅을 사용해 상태/액션을 구성합니다.
 */
export const PortfolioProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  // 핵심 데이터/인증/저장 훅
  const {
    assets, setAssets,
    portfolioHistory, setPortfolioHistory,
    sellHistory, setSellHistory,
    watchlist, setWatchlist,
    exchangeRates, setExchangeRates,
    isSignedIn, googleUser,
    isLoading: isAuthLoading,
    error, setError,
    successMessage, setSuccessMessage,
    hasAutoUpdated,
    handleSignIn,
    handleSignOut,
    triggerAutoSave,
    updateAllData,
  } = usePortfolioData();

  // 시세/환율 훅
  const {
    isLoading: isMarketLoading,
    failedAssetIds,
    handleExchangeRatesChange,
    handleRefreshAllPrices,
    handleRefreshSelectedPrices,
    handleRefreshOnePrice,
    handleRefreshWatchlistPrices,
  } = useMarketData({
    assets, setAssets,
    watchlist, setWatchlist,
    exchangeRates, setExchangeRates,
    portfolioHistory, sellHistory,
    triggerAutoSave,
    setError,
    setSuccessMessage,
  });

  // 자산/관심종목 액션 훅
  const {
    isLoading: isActionLoading,
    editingAsset, setEditingAsset,
    sellingAsset, setSellingAsset,
    handleAddAsset,
    handleDeleteAsset,
    handleUpdateAsset,
    handleConfirmSell,
    handleCsvFileUpload,
    handleAddWatchItem,
    handleUpdateWatchItem,
    handleDeleteWatchItem,
    handleBulkDeleteWatchItems,
    handleAddAssetsToWatchlist,
    handleToggleWatchMonitoring,
  } = useAssetActions({
    assets, setAssets,
    watchlist, setWatchlist,
    portfolioHistory,
    sellHistory, setSellHistory,
    exchangeRates,
    isSignedIn,
    triggerAutoSave,
    setError,
    setSuccessMessage,
  });

  // UI 상태
  const [activeTab, setActiveTab] = useState<UIState['activeTab']>('dashboard');
  const [dashboardFilterCategory, setDashboardFilterCategory] = useState<AssetCategory | 'ALL'>('ALL');
  const [filterCategory, setFilterCategory] = useState<AssetCategory | 'ALL'>('ALL');
  const [sellAlertDropRate, setSellAlertDropRate] = useState<number>(15);
  const [filterAlerts, setFilterAlerts] = useState(false);
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [isBulkUploadModalOpen, setIsBulkUploadModalOpen] = useState<boolean>(false);
  const [isAddAssetModalOpen, setIsAddAssetModalOpen] = useState<boolean>(false);
  const [isAssistantOpen, setIsAssistantOpen] = useState<boolean>(false);

  const isLoading = isAuthLoading || isMarketLoading || isActionLoading;
  const isInitializing = false;

  // 파생 값
  const showExchangeRateWarning = useMemo(() => {
    const hasUSD = assets.some(a => a.currency === Currency.USD);
    const hasJPY = assets.some(a => a.currency === Currency.JPY);
    return (hasUSD && (!exchangeRates.USD || exchangeRates.USD < 100)) || (hasJPY && (!exchangeRates.JPY || exchangeRates.JPY < 1));
  }, [assets, exchangeRates]);

  const alertCount = useMemo(() => {
    return assets.filter(asset => {
      if (asset.highestPrice === 0) return false;
      const dropFromHigh = ((asset.currentPrice - asset.highestPrice) / asset.highestPrice) * 100;
      const alertRate = asset.sellAlertDropRate ?? sellAlertDropRate;
      return dropFromHigh <= -alertRate;
    }).length;
  }, [assets, sellAlertDropRate]);

  const totalValue = useMemo(() => {
    return assets.reduce((acc, asset) => {
      const rate = asset.currency === Currency.KRW ? 1 : (exchangeRates[asset.currency] || 0);
      const v = asset.currentPrice * asset.quantity * rate;
      return acc + v;
    }, 0);
  }, [assets, exchangeRates]);

  // 포트폴리오 히스토리 스냅샷 업데이트
  useEffect(() => {
    const updatePortfolioHistory = () => {
      if (assets.length === 0) return;
      const today = new Date().toISOString().slice(0, 10);
      const newAssetSnapshots = assets.map(asset => {
        const rate = asset.currency === Currency.KRW ? 1 : (exchangeRates[asset.currency] || 0);
        const currentValueKRW = asset.currentPrice * asset.quantity * rate;
        let purchaseValueKRW: number;
        if (asset.currency === Currency.KRW) {
          purchaseValueKRW = asset.purchasePrice * asset.quantity;
        } else if (asset.purchaseExchangeRate) {
          purchaseValueKRW = asset.purchasePrice * asset.purchaseExchangeRate * asset.quantity;
        } else if (asset.priceOriginal > 0) {
          const exchangeRate = asset.currentPrice / asset.priceOriginal;
          purchaseValueKRW = asset.purchasePrice * exchangeRate * asset.quantity;
        } else {
          purchaseValueKRW = asset.purchasePrice * asset.quantity;
        }
        const unitPriceKRW = asset.currentPrice * rate;
        return {
          id: asset.id,
          name: (asset.customName?.trim() || asset.name),
          currentValue: currentValueKRW,
          purchaseValue: purchaseValueKRW,
          unitPrice: unitPriceKRW,
        };
      });
      const newSnapshot = { date: today, assets: newAssetSnapshots };
      setPortfolioHistory(prevHistory => {
        const todayIndex = prevHistory.findIndex(snap => snap.date === today);
        let updatedHistory;
        if (todayIndex > -1) {
          updatedHistory = [...prevHistory];
          updatedHistory[todayIndex] = newSnapshot;
        } else {
          updatedHistory = [...prevHistory, newSnapshot];
        }
        if (updatedHistory.length > 365) {
          updatedHistory = updatedHistory.slice(updatedHistory.length - 365);
        }
        return updatedHistory;
      });
    };
    updatePortfolioHistory();
  }, [assets, exchangeRates, setPortfolioHistory]);

  // 액션 구현
  const saveToDrive = useCallback(async () => {
    triggerAutoSave(assets, portfolioHistory, sellHistory, watchlist, exchangeRates);
    setSuccessMessage('저장 요청되었습니다.');
    setTimeout(() => setSuccessMessage(null), 3000);
  }, [assets, portfolioHistory, sellHistory, watchlist, exchangeRates, triggerAutoSave, setSuccessMessage]);

  const exportJson = useCallback(async (fileName: string = 'portfolio.json') => {
    if (!isSignedIn) {
      setError('Google Drive 로그인 후 내보내기 기능을 사용할 수 있습니다.');
      setTimeout(() => setError(null), 3000);
      return;
    }
    const exportData = {
      assets,
      portfolioHistory,
      sellHistory,
      exchangeRates,
      watchlist,
      lastUpdateDate: new Date().toISOString().slice(0, 10),
    };
    const portfolioJSON = JSON.stringify(exportData, null, 2);
    const blob = new Blob([portfolioJSON], { type: 'application/json' });
    try {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      setSuccessMessage(`'${fileName}' 파일로 내보내기가 완료되었습니다.`);
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (e) {
      setError('파일 내보내기에 실패했습니다.');
      setTimeout(() => setError(null), 3000);
    }
  }, [assets, portfolioHistory, sellHistory, watchlist, exchangeRates, isSignedIn, setError, setSuccessMessage]);

  const importJsonPrompt = useCallback(() => {
    if (!isSignedIn) {
      setError('Google Drive 로그인 후 가져오기 기능을 사용할 수 있습니다.');
      setTimeout(() => setError(null), 3000);
      return;
    }
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json,application/json';
    input.onchange = (event) => {
      const file = (event.target as HTMLInputElement).files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const contents = e.target?.result as string;
          const loadedData = JSON.parse(contents);
          let loadedAssets: Asset[] = [];
          let loadedHistory: PortfolioHistory = [];
          let loadedSellHistory: SellRecord[] = [];
          let loadedWatchlist: WatchlistItem[] = [];
          let loadedRates: ExchangeRates | undefined = undefined;
          if (Array.isArray(loadedData)) {
            loadedAssets = loadedData as Asset[];
          } else if (loadedData && typeof loadedData === 'object') {
            loadedAssets = Array.isArray(loadedData.assets) ? loadedData.assets : [];
            loadedHistory = Array.isArray(loadedData.portfolioHistory) ? loadedData.portfolioHistory : [];
            loadedSellHistory = Array.isArray(loadedData.sellHistory) ? loadedData.sellHistory : [];
            loadedWatchlist = Array.isArray(loadedData.watchlist) ? loadedData.watchlist : [];
            loadedRates = loadedData.exchangeRates;
          }
          setAssets(loadedAssets);
          setPortfolioHistory(loadedHistory);
          setSellHistory(loadedSellHistory);
          setWatchlist(loadedWatchlist);
          if (loadedRates) setExchangeRates(loadedRates);
          setSuccessMessage('파일에서 데이터를 불러왔습니다.');
          setTimeout(() => setSuccessMessage(null), 3000);
        } catch (err) {
          setError('파일 파싱 실패');
          setTimeout(() => setError(null), 3000);
        }
      };
      reader.readAsText(file);
    };
    input.click();
  }, [isSignedIn, setError, setSuccessMessage, setAssets, setPortfolioHistory, setSellHistory, setWatchlist, setExchangeRates]);

  const exportCsv = useCallback(async () => {
    if (!isSignedIn) {
      setError('Google Drive 로그인 후 내보내기 기능을 사용할 수 있습니다.');
      setTimeout(() => setError(null), 3000);
      return;
    }
    if (assets.length === 0) {
      alert('내보낼 데이터가 없습니다.');
      return;
    }
    try {
      const header = [
        '종목명', '티커', '거래소', '자산구분', '보유수량',
        '매수단가(자국통화)', '매수환율', '총매수금액(원화)',
        '현재단가(원화)', '현재평가금액(원화)', '총손익(원화)', '수익률(%)'
      ];
      const rows = assets.map(asset => {
        const rate = asset.currency === Currency.KRW ? 1 : (exchangeRates[asset.currency] || 0);
        const currentValueKRW = asset.currentPrice * asset.quantity * rate;
        const purchaseValueKRW = asset.currency === Currency.KRW
          ? asset.purchasePrice * asset.quantity
          : (asset.purchaseExchangeRate
              ? asset.purchasePrice * asset.purchaseExchangeRate * asset.quantity
              : asset.purchasePrice * rate * asset.quantity);
        const gainLossKRW = currentValueKRW - purchaseValueKRW;
        const returnPct = purchaseValueKRW === 0 ? 0 : (gainLossKRW / purchaseValueKRW) * 100;
        return [
          (asset.customName?.trim() || asset.name),
          asset.ticker,
          asset.exchange,
          asset.category,
          asset.quantity,
          asset.purchasePrice,
          asset.purchaseExchangeRate ?? '',
          Math.round(purchaseValueKRW),
          Math.round(asset.currentPrice * rate),
          Math.round(currentValueKRW),
          Math.round(gainLossKRW),
          returnPct.toFixed(2),
        ].join(',');
      });
      const content = [header.join(','), ...rows].join('\n');
      const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'portfolio.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      setSuccessMessage('CSV 내보내기 완료');
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (e) {
      setError('CSV 내보내기 실패');
      setTimeout(() => setError(null), 3000);
    }
  }, [assets, exchangeRates, isSignedIn, setError, setSuccessMessage]);

  const handleTabChange = useCallback((tab: UIState['activeTab']) => {
    if (tab !== 'portfolio') {
      setFilterAlerts(false);
    }
    setActiveTab(tab);
  }, []);

  const value: PortfolioContextValue = {
    data: {
      assets,
      portfolioHistory,
      sellHistory,
      watchlist,
      exchangeRates,
    },
    status: {
      isLoading,
      failedAssetIds,
      isSignedIn,
      userEmail: googleUser?.email ?? null,
      isInitializing,
      error,
      successMessage,
      showExchangeRateWarning,
    },
    ui: {
      activeTab,
      dashboardFilterCategory,
      filterCategory,
      filterAlerts,
      searchQuery,
      sellAlertDropRate,
    },
    modal: {
      editingAsset,
      sellingAsset,
      bulkUploadOpen: isBulkUploadModalOpen,
      addAssetOpen: isAddAssetModalOpen,
      assistantOpen: isAssistantOpen,
    },
    derived: {
      totalValue,
      alertCount,
    },
    actions: {
      saveToDrive,
      exportJson,
      importJsonPrompt,
      exportCsv,
      signIn: async () => { await handleSignIn(); },
      signOut: async () => { handleSignOut(); },
      setExchangeRates: handleExchangeRatesChange,
      refreshAllPrices: async (force?: boolean) => handleRefreshAllPrices(!!force),
      refreshSelectedPrices: handleRefreshSelectedPrices,
      refreshOnePrice: handleRefreshOnePrice,
      refreshWatchlistPrices: handleRefreshWatchlistPrices,
      addAsset: handleAddAsset,
      updateAsset: handleUpdateAsset,
      deleteAsset: handleDeleteAsset,
      confirmSell: handleConfirmSell,
      addSelectedToWatchlist: handleAddAssetsToWatchlist,
      addWatchItem: handleAddWatchItem,
      updateWatchItem: handleUpdateWatchItem,
      deleteWatchItem: handleDeleteWatchItem,
      toggleWatchMonitoring: handleToggleWatchMonitoring,
      bulkDeleteWatchItems: handleBulkDeleteWatchItems,
      uploadCsv: handleCsvFileUpload,
      clearError: () => setError(null),
      clearSuccessMessage: () => setSuccessMessage(null),
      setActiveTab: handleTabChange,
      setDashboardFilterCategory,
      setFilterCategory,
      setFilterAlerts,
      setSearchQuery,
      setSellAlertDropRate,
      openEditModal: (asset: Asset) => setEditingAsset(asset),
      closeEditModal: () => setEditingAsset(null),
      openSellModal: (asset: Asset) => setSellingAsset(asset),
      closeSellModal: () => setSellingAsset(null),
      openBulkUpload: () => setIsBulkUploadModalOpen(true),
      closeBulkUpload: () => setIsBulkUploadModalOpen(false),
      openAddAsset: () => setIsAddAssetModalOpen(true),
      closeAddAsset: () => setIsAddAssetModalOpen(false),
      openAssistant: () => setIsAssistantOpen(true),
      closeAssistant: () => setIsAssistantOpen(false),
    },
  };

  return <PortfolioContext.Provider value={value}>{children}</PortfolioContext.Provider>;
};

/**
 * @description 컨텍스트 접근 훅. Provider 밖에서 호출 시 에러를 던집니다.
 */
export const usePortfolio = (): PortfolioContextValue => {
  const ctx = useContext(PortfolioContext);
  if (!ctx) {
    throw new Error('usePortfolio must be used within a PortfolioProvider');
  }
  return ctx;
};
</file>

<file path="hooks/useOnClickOutside.ts">
import { useEffect } from 'react';

export function useOnClickOutside<T extends HTMLElement>(
  ref: React.RefObject<T>,
  handler: () => void,
  active: boolean = true
) {
  useEffect(() => {
    if (!active) return;
    const listener = (event: MouseEvent | TouchEvent) => {
      const el = ref.current;
      if (!el) return;
      const target = event.target as Node | null;
      if (target && el.contains(target)) return;
      handler();
    };
    document.addEventListener('mousedown', listener, true);
    document.addEventListener('touchstart', listener, true);
    return () => {
      document.removeEventListener('mousedown', listener, true);
      document.removeEventListener('touchstart', listener, true);
    };
  }, [ref, handler, active]);
}
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KIM'S 퀸트자산관리</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
</head>
  <body class="bg-gray-900 text-gray-200">
    <div id="root"></div>
  <script type="module" src="/index.tsx"></script>
</body>
</html>
</file>

<file path="package.json">
{
  "name": "자산-관리-시트",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "deploy": "npm run build && gh-pages -d dist"
  },
  "dependencies": {
    "@google/genai": "^1.29.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.555.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-markdown": "^9.1.0",
    "recharts": "^3.4.1",
    "remark-gfm": "^4.0.1",
    "tailwind-merge": "^3.4.0"
  },
  "devDependencies": {
    "@types/node": "^22.14.0",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.22",
    "gh-pages": "^6.3.0",
    "postcss": "^8.5.6",
    "rehype-raw": "^7.0.0",
    "tailwindcss": "^3.4.13",
    "typescript": "~5.8.2",
    "vite": "^6.4.1"
  }
}
</file>

<file path="RULES.md">
# 프로젝트 개발 원칙 (RULES.md)

## 1. 프로젝트 정체성 및 기술 스택
- **목표:** 개인 투자용 퀀트 자산 관리 시스템 (주식, 코인, 실물자산 통합)
- **Frontend:** React 19.2+, TypeScript, Vite, Tailwind CSS
- **Data Source:**
  - 주식: Google Cloud Run (Python) + FinanceDataReader
  - 코인: Upbit API
  - 데이터 저장소: Google Drive (JSON 동기화)
- **State Management:** Context API (PortfolioContext)

## 2. 아키텍처 및 코드 작성 원칙 (절대 준수)

### [구조 분리 원칙]
1. **UI와 로직의 분리:**
   - `App.tsx` 등 UI 컴포넌트는 화면 표시에만 집중한다.
   - 데이터 처리 및 비즈니스 로직은 반드시 `hooks/` 또는 `utils/`로 분리한다.
   - 복잡한 계산 로직(수익률, 환율 변환 등)은 `utils/portfolioCalculations.ts`에 작성하고 순수 함수(Pure Function)로 유지한다.

2. **상태 관리 (Context API):**
   - 3단계 이상의 Props Drilling은 금지한다.
   - 전역 데이터(자산 목록, 환율, 설정 등)는 `PortfolioContext`를 통해 접근한다.

3. **타입 안전성 (TypeScript):**
   - **`any` 타입 사용을 엄격히 금지한다.**
   - 모든 데이터 구조는 `types.ts`에 정의된 interface와 enum(`AssetCategory` 등)을 사용한다.
   - 컴포넌트 Props는 반드시 타입을 명시한다.

### [외부 연동 및 에러 처리 원칙]
1. **API 연동:**
   - 외부 API(Cloud Run, Upbit) 호출 로직은 `hooks/useMarketData.ts` 등 전용 훅 내에서만 수행한다.
   - API 실패 시 UI가 멈추지 않도록 `try-catch`와 `fallback` 데이터를 반드시 구현한다. (부분 성공 허용)

2. **Google Drive 동기화:**
   - 데이터 저장(`hooks/usePortfolioData.ts`) 시에는 로컬 상태와 구글 드라이브 간의 정합성을 최우선으로 한다.

## 3. 작업 워크플로우 (AI 지침)

1. **영향도 분석 우선:**
   - 코드를 수정하기 전에, 해당 파일이 어디서 참조되고 있는지(`grep` 등 활용) 먼저 파악하고 사용자에게 보고한다.
   - 특히 `types.ts`나 `utils/`를 수정할 때는 프로젝트 전체에 미칠 영향을 분석해야 한다.

2. **기존 코드 보존:**
   - 잘 작동하는 기존 기능(특히 로그인, 자동저장)을 훼손하지 않는다.
   - 리팩토링 시 기존 함수의 입출력(Input/Output) 호환성을 유지한다.

3. **문서화:**
   - 새로운 파일이나 중요 로직이 추가되면 `README.md`의 관련 섹션도 함께 업데이트할 것을 제안한다.
</file>

<file path="services/googleDriveService.ts">
// Google Drive API 서비스
// Google Identity Services를 사용한 OAuth 인증 및 Drive API 연동

export interface GoogleUser {
  email: string;
  name: string;
  picture?: string;
}

export interface DriveFile {
  id: string;
  name: string;
  mimeType: string;
  createdTime: string;
  modifiedTime: string;
}

const DRIVE_FOLDER_ID = '10O5cGNd9QVoAAxR8NdojqI9AD7wj0Q_g';

class GoogleDriveService {
  private accessToken: string | null = null;
  private user: GoogleUser | null = null;
  private clientId: string | null = null;
  private tokenClient: google.accounts.oauth2.TokenClient | null = null;
  private isInitialized = false;
  private folderId: string | null = DRIVE_FOLDER_ID;

  // Google Identity Services 초기화
  async initialize(clientId: string): Promise<void> {
    if (this.isInitialized) return;
    
    this.clientId = clientId;
    
    // Google API 스크립트 로드
    await this.loadGoogleScripts();
    
    // 저장된 토큰 확인
    const savedToken = localStorage.getItem('google_drive_access_token');
    const savedUser = localStorage.getItem('google_drive_user');
    const savedTokenExpiry = localStorage.getItem('google_drive_token_expiry');
    
    if (savedToken && savedUser) {
      this.accessToken = savedToken;
      this.user = JSON.parse(savedUser);
      
      // 토큰 만료 시간 확인
      const now = Date.now();
      const expiryTime = savedTokenExpiry ? parseInt(savedTokenExpiry, 10) : 0;
      
      // 토큰이 만료되지 않았고 유효한 경우
      if (expiryTime > now && await this.validateToken()) {
        this.isInitialized = true;
        // 만료 5분 전에 자동 갱신 스케줄
        const timeUntilExpiry = expiryTime - now;
        const refreshTime = Math.max(0, timeUntilExpiry - 5 * 60 * 1000); // 5분 전
        setTimeout(() => {
          this.refreshTokenSilently();
        }, refreshTime);
        return;
      } else {
        // 토큰이 만료된 경우 - 자동 갱신 시도
        if (savedTokenExpiry && expiryTime > now - 60 * 60 * 1000) { // 1시간 이내 만료된 경우만
          try {
            await this.refreshTokenSilently();
            if (this.accessToken) {
              this.isInitialized = true;
              return;
            }
          } catch (error) {
            console.log('Silent token refresh failed, user needs to sign in again');
          }
        }
        // 토큰이 만료된 경우
        this.accessToken = null;
        this.user = null;
        localStorage.removeItem('google_drive_access_token');
        localStorage.removeItem('google_drive_user');
        localStorage.removeItem('google_drive_token_expiry');
      }
    }
    
    this.isInitialized = true;
  }

  private loadGoogleScripts(): Promise<void> {
    return new Promise((resolve, reject) => {
      // Google Identity Services 스크립트 로드
      if (window.google?.accounts) {
        resolve();
        return;
      }

      const script = document.createElement('script');
      script.src = 'https://accounts.google.com/gsi/client';
      script.async = true;
      script.defer = true;
      script.onload = () => {
        // Google API 클라이언트 라이브러리 로드
        const apiScript = document.createElement('script');
        apiScript.src = 'https://apis.google.com/js/api.js';
        apiScript.async = true;
        apiScript.defer = true;
        apiScript.onload = () => {
          window.gapi.load('client', () => {
            window.gapi.client.init({
              discoveryDocs: [
                'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest',
                'https://www.googleapis.com/discovery/v1/apis/oauth2/v2/rest'
              ],
            }).then(() => {
              resolve();
            }).catch(reject);
          });
        };
        apiScript.onerror = reject;
        document.head.appendChild(apiScript);
      };
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }

  // Google 로그인
  async signIn(): Promise<GoogleUser> {
    if (!this.clientId) {
      throw new Error('Google Drive service not initialized. Please provide client ID.');
    }
    return new Promise((resolve, reject) => {
      console.log('=== Google Sign In 시작 ===');
      console.log('Client ID:', this.clientId);
      console.log('Requested scope:', 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile openid');
      
      this.tokenClient = window.google.accounts.oauth2.initTokenClient({
        client_id: this.clientId!,
        scope: 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile openid',
        callback: async (response: google.accounts.oauth2.TokenResponse) => {
          console.log('=== OAuth Callback 실행됨 ===');
          console.log('Response:', response);
          
          if (response.error) {
            console.error('OAuth error:', response.error);
            reject(new Error(response.error));
            return;
          }
    
          this.accessToken = response.access_token;
          console.log('Access token received');
          console.log('Received scope:', response.scope);
          console.log('Scope includes userinfo.email:', response.scope?.includes('userinfo.email'));
          console.log('Scope includes userinfo.profile:', response.scope?.includes('userinfo.profile'));
          
          // 토큰 만료 시간 저장 (기본 1시간, expires_in이 있으면 사용)
          const expiresIn = response.expires_in ? response.expires_in * 1000 : 3600 * 1000;
          const expiryTime = Date.now() + expiresIn;
          localStorage.setItem('google_drive_token_expiry', expiryTime.toString());
          
          // 사용자 정보 가져오기
          try {
            const userInfo = await this.getUserInfo();
            this.user = userInfo;
            localStorage.setItem('google_drive_access_token', this.accessToken);
            localStorage.setItem('google_drive_user', JSON.stringify(userInfo));
            
            // 만료 5분 전에 자동 갱신 스케줄
            const refreshTime = Math.max(0, expiresIn - 5 * 60 * 1000); // 5분 전
            setTimeout(() => {
              this.refreshTokenSilently();
            }, refreshTime);
            
            resolve(userInfo);
          } catch (error: unknown) {
            console.error('Failed to get user info:', error);
            if (error instanceof Error) {
              console.error('Error details:', error.message, error.stack);
            }
            // 토큰은 받았지만 사용자 정보를 가져오지 못한 경우, 토큰을 저장하지 않음
            this.accessToken = null;
            reject(error);
          }
        },
      });
    
      console.log('Requesting access token with prompt: consent');
      this.tokenClient.requestAccessToken({ prompt: 'consent' });
    });
  }

  // 사용자 정보 가져오기
  private async getUserInfo(): Promise<GoogleUser> {
    if (!this.accessToken) {
      throw new Error('Not authenticated');
    }

    try {
      // 방법 1: OAuth2 userinfo API 시도
      const response = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
        headers: {
          Authorization: `Bearer ${this.accessToken}`,
        },
      });

      if (response.ok) {
        const data = await response.json();
        
        if (data.email) {
          return {
            email: data.email,
            name: data.name || data.email.split('@')[0],
            picture: data.picture,
          };
        }
      }

      // 방법 2: Google API 클라이언트 사용 (대안)
      if (window.gapi?.client && window.gapi.client.setToken) {
        try {
          // 토큰 설정
          window.gapi.client.setToken({ access_token: this.accessToken });
          await window.gapi.client.load('oauth2', 'v2');
          const userInfo = await window.gapi.client.oauth2.userinfo.get();
          if (userInfo.result && userInfo.result.email) {
            return {
              email: userInfo.result.email,
              name: userInfo.result.name || userInfo.result.email.split('@')[0],
              picture: userInfo.result.picture,
            };
          }
        } catch (gapiError) {
          console.error('GAPI userinfo error:', gapiError);
        }
      }

      // 두 방법 모두 실패한 경우
      const errorText = await response.text().catch(() => 'Unknown error');
      console.error('User info API error:', response.status, errorText);
      
      // 더 자세한 에러 메시지
      if (response.status === 401) {
        throw new Error('인증 실패: Google Cloud Console의 OAuth 동의 화면에서 userinfo.email과 userinfo.profile scope를 추가했는지 확인하세요.');
      } else if (response.status === 403) {
        throw new Error('권한 없음: 사용자 정보에 접근할 권한이 없습니다. scope 설정을 확인하세요.');
      } else {
        throw new Error(`사용자 정보를 가져올 수 없습니다 (${response.status}): ${errorText}`);
      }
    } catch (error: unknown) {
      console.error('getUserInfo error:', error);
      throw error;
    }
  }

  // 토큰 자동 갱신 (조용히)
  private async refreshTokenSilently(): Promise<void> {
    if (!this.clientId || !this.user) return;
    
    try {
      this.tokenClient = window.google.accounts.oauth2.initTokenClient({
        client_id: this.clientId!,
        scope: 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile openid',
        callback: async (response: google.accounts.oauth2.TokenResponse) => {
          if (response.error) {
            console.log('Token refresh failed:', response.error);
            return;
          }
          
          this.accessToken = response.access_token;
          const expiresIn = response.expires_in ? response.expires_in * 1000 : 3600 * 1000;
          const expiryTime = Date.now() + expiresIn;
          localStorage.setItem('google_drive_access_token', this.accessToken);
          localStorage.setItem('google_drive_token_expiry', expiryTime.toString());
          
          // 다음 갱신 스케줄
          const refreshTime = Math.max(0, expiresIn - 5 * 60 * 1000);
          setTimeout(() => {
            this.refreshTokenSilently();
          }, refreshTime);
        },
      });
      
      // prompt: 'none'으로 조용히 갱신 시도
      this.tokenClient.requestAccessToken({ prompt: 'none' });
    } catch (error) {
      console.log('Silent token refresh error:', error);
    }
  }

  // 로그아웃
  signOut(): void {
    if (this.accessToken) {
      window.google.accounts.oauth2.revoke(this.accessToken, () => {
        this.accessToken = null;
        this.user = null;
        localStorage.removeItem('google_drive_access_token');
        localStorage.removeItem('google_drive_user');
        localStorage.removeItem('google_drive_token_expiry');
      });
    }
  }

  // 로그인 상태 확인
  isSignedIn(): boolean {
    return this.accessToken !== null && this.user !== null;
  }

  // 현재 사용자 정보
  getCurrentUser(): GoogleUser | null {
    return this.user;
  }

  // 토큰 유효성 검사
  private async validateToken(): Promise<boolean> {
    if (!this.accessToken) return false;

    try {
      const response = await fetch('https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=' + this.accessToken);
      return response.ok;
    } catch {
      return false;
    }
  }

  // 파일 목록 가져오기
  async listFiles(): Promise<DriveFile[]> {
    if (!this.accessToken) {
      throw new Error('Not authenticated');
    }

    let query = "name = 'portfolio.json' and trashed = false";
    if (this.folderId) {
      query += ` and '${this.folderId}' in parents`;
    }

    const searchParams = new URLSearchParams({
      q: query,
      spaces: 'drive',
      fields: 'files(id,name),nextPageToken',
      pageSize: '10',
    });

    const response = await fetch(
      `https://www.googleapis.com/drive/v3/files?${searchParams.toString()}`,
      {
        headers: {
          Authorization: `Bearer ${this.accessToken}`,
        },
      }
    );

    if (!response.ok) {
      const errorText = await response.text().catch(() => 'Unknown error');
      console.error('Drive list files error', response.status, errorText);
      throw new Error(`Failed to list files (${response.status})`);
    }

    const data = await response.json();
    return data.files || [];
  }

  // 파일 저장 (생성 또는 업데이트)
  async saveFile(content: string, fileName: string = 'portfolio.json'): Promise<void> {
    if (!this.accessToken) {
      throw new Error('Not authenticated');
    }

    // 기존 파일 확인
    const files = await this.listFiles();
    const existingFile = files.find(f => f.name === fileName);

    const fileContent = new Blob([content], { type: 'application/json' });
    const baseMetadata = {
      name: fileName,
      mimeType: 'application/json',
    };

    if (existingFile) {
      // 파일 업데이트
      const form = new FormData();
      form.append('metadata', new Blob([JSON.stringify(baseMetadata)], { type: 'application/json' }));
      form.append('file', fileContent);

      const response = await fetch(
        `https://www.googleapis.com/upload/drive/v3/files/${existingFile.id}?uploadType=multipart`,
        {
          method: 'PATCH',
          headers: {
            Authorization: `Bearer ${this.accessToken}`,
          },
          body: form,
        }
      );

      if (!response.ok) {
        throw new Error('Failed to update file');
      }
    } else {
      // 새 파일 생성
      const metadata: { name: string; mimeType: string; parents?: string[] } = { ...baseMetadata };
      if (this.folderId) {
        metadata.parents = [this.folderId];
      }
      const form = new FormData();
      form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
      form.append('file', fileContent);

      const response = await fetch(
        'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart',
        {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${this.accessToken}`,
          },
          body: form,
        }
      );

      if (!response.ok) {
        throw new Error('Failed to create file');
      }
    }
  }

  // 파일 불러오기
  async loadFile(fileName: string = 'portfolio.json'): Promise<string | null> {
    if (!this.accessToken) {
      throw new Error('Not authenticated');
    }

    const files = await this.listFiles();
    const file = files.find(f => f.name === fileName);

    if (!file) {
      return null;
    }

    const response = await fetch(
      `https://www.googleapis.com/drive/v3/files/${file.id}?alt=media`,
      {
        headers: {
          Authorization: `Bearer ${this.accessToken}`,
        },
      }
    );

    if (!response.ok) {
      const errorText = await response.text().catch(() => 'Unknown error');
      console.error('Drive load file error', response.status, errorText);
      throw new Error(`Failed to load file (${response.status})`);
    }

    return await response.text();
  }
}

// 싱글톤 인스턴스
export const googleDriveService = new GoogleDriveService();

// 타입 선언
declare global {
  interface Window {
    google: {
      accounts: {
        oauth2: {
          initTokenClient: (config: {
            client_id: string;
            scope: string;
            callback: (response: google.accounts.oauth2.TokenResponse) => void;
          }) => google.accounts.oauth2.TokenClient;
          revoke: (token: string, callback: () => void) => void;
        };
      };
    };
    gapi: {
      load: (api: string, callback: () => void) => void;
      client: {
        init: (config: {
          discoveryDocs: string[];
        }) => Promise<void>;
        setToken: (token: { access_token: string }) => void;
        load: (apiName: string, version: string) => Promise<void>;
        oauth2: {
          userinfo: {
            get: () => Promise<{ result: { email?: string; name?: string; picture?: string } }>;
          };
        };
      };
    };
  }

  namespace google {
    namespace accounts {
      namespace oauth2 {
        interface TokenClient {
          requestAccessToken: (options?: { prompt?: string }) => void;
        }
        interface TokenResponse {
          access_token: string;
          expires_in: number;
          scope: string;
          token_type: string;
          error?: string;
        }
      }
    }
  }
}
</file>

<file path="utils/portfolioCalculations.ts">
import { AssetCategory, Currency, LegacyAssetShape, Asset } from '../types';

const DEFAULT_EXCHANGE_MAP: { [key in AssetCategory]?: string[] } = {
  [AssetCategory.KOREAN_STOCK]: ['KRX', 'KONEX'],
  [AssetCategory.US_STOCK]: ['NASDAQ', 'NYSE', 'AMEX'],
  [AssetCategory.OTHER_FOREIGN_STOCK]: ['TSE', 'HKEX', 'LSE'],
  [AssetCategory.CRYPTOCURRENCY]: ['Upbit', 'Bithumb', 'Binance'],
  [AssetCategory.KOREAN_BOND]: ['KRX'],
  [AssetCategory.US_BOND]: ['US Bond'],
  [AssetCategory.PHYSICAL_ASSET]: ['Gold', 'Silver'],
  [AssetCategory.CASH]: ['KRW', 'USD', 'JPY'],
};

export const mapToNewAssetStructure = (asset: LegacyAssetShape): Asset => {
  let newAsset = { ...asset };

  if (!newAsset.exchange) newAsset.exchange = DEFAULT_EXCHANGE_MAP[newAsset.category as AssetCategory]?.[0] || '';
  if (!newAsset.currency) {
    newAsset.currency = Currency.KRW;
    newAsset.priceOriginal = newAsset.currentPrice;
  }
  if (!newAsset.purchaseExchangeRate) {
    newAsset.purchaseExchangeRate = newAsset.currency === Currency.KRW ? 1 : undefined;
  }

  const oldCategory = newAsset.category;
  if (['주식', 'ETF'].includes(oldCategory)) {
    if (newAsset.exchange?.startsWith('KRX')) {
      newAsset.category = AssetCategory.KOREAN_STOCK;
    } else if (['NASDAQ', 'NYSE', 'AMEX'].includes(newAsset.exchange)) {
      newAsset.category = AssetCategory.US_STOCK;
    } else {
      newAsset.category = AssetCategory.OTHER_FOREIGN_STOCK;
    }
  } else if (['KRX금현물', '금', '실물자산'].includes(oldCategory)) {
    newAsset.category = AssetCategory.PHYSICAL_ASSET;
  } else {
    const categoryMap: { [key: string]: AssetCategory } = {
      '국내주식': AssetCategory.KOREAN_STOCK,
      '해외주식': AssetCategory.US_STOCK,
      '국내국채': AssetCategory.KOREAN_BOND,
      '해외국채': AssetCategory.US_BOND,
    };
    if (categoryMap[oldCategory]) {
      newAsset.category = categoryMap[oldCategory];
    }
  }

  if (!Object.values(AssetCategory).includes(newAsset.category as AssetCategory)) {
    newAsset.category = AssetCategory.OTHER_FOREIGN_STOCK;
  }

  const { region, ...cleaned } = newAsset as any;
  return cleaned as Asset;
};
</file>

<file path=".github/workflows/deploy.yml">
name: Deploy to GitHub Pages

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      # [핵심 수정] 환경 변수를 파일(.env)로 직접 생성하여 빌드에 주입 (가장 확실한 방법)
      - name: Create .env file
        run: |
          echo "VITE_GEMINI_API_KEY=${{ secrets.VITE_GEMINI_API_KEY }}" >> .env
          echo "VITE_GOOGLE_CLIENT_ID=${{ secrets.VITE_GOOGLE_CLIENT_ID }}" >> .env

      - name: Build
        run: npm run build

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: './dist'

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
</file>

<file path="components/AllocationChart.tsx">
import React, { useMemo } from 'react';
import { Asset, AssetCategory, ExchangeRates, Currency } from '../types';
import { PieChart, Pie, Cell, Tooltip, ResponsiveContainer } from 'recharts';

interface AllocationChartProps {
  assets: Asset[];
  exchangeRates: ExchangeRates;
}

const COLORS = ['#6366F1', '#10B981', '#F59E0B', '#EF4444', '#3B82F6', '#8B5CF6', '#EC4899', '#F97316', '#84CC16'];

interface ChartData {
  name: AssetCategory;
  value: number;
}

interface CustomTooltipProps {
  active?: boolean;
  payload?: Array<{ dataKey?: string; value?: number; payload?: ChartData }>;
  totalValue: number;
}

const CustomTooltip: React.FC<CustomTooltipProps> = ({ active, payload, totalValue }) => {
  if (active && payload && payload.length) {
    const { name, value } = payload[0].payload;
    const percent = totalValue > 0 ? (value / totalValue) * 100 : 0;
    return (
      <div className="bg-gray-700 p-3 rounded-md border border-gray-600 shadow-lg">
        <p className="font-bold text-white">{name}</p>
        <p className="text-sm text-gray-300">
          금액: {value.toLocaleString('ko-KR', { style: 'currency', currency: 'KRW', maximumFractionDigits: 0 })}
        </p>
         <p className="text-sm text-gray-300">
          비중: {percent.toFixed(2)}%
        </p>
      </div>
    );
  }
  return null;
};

const AllocationChart: React.FC<AllocationChartProps> = ({ assets, exchangeRates }) => {
  const chartData = useMemo(() => {
    const categoryTotals = new Map<AssetCategory, number>();
    assets.forEach(asset => {
      // [수정] 환율 적용하여 원화 가치로 변환
      const rate = asset.currency === Currency.KRW ? 1 : (exchangeRates[asset.currency] || 0);
      const value = asset.currentPrice * asset.quantity * rate;
      
      categoryTotals.set(asset.category, (categoryTotals.get(asset.category) || 0) + value);
    });
    return Array.from(categoryTotals.entries()).map(([name, value]) => ({ name, value }));
  }, [assets, exchangeRates]);

  const totalValue = useMemo(() => chartData.reduce((sum, entry) => sum + entry.value, 0), [chartData]);

  return (
    <div className="bg-gray-800 p-6 rounded-lg shadow-lg h-96" title="자산 종류별 비중을 원형 차트로 보여줍니다.">
      <h2 className="text-xl font-bold text-white mb-4">자산 종류별 배분</h2>
      {assets.length > 0 ? (
        <ResponsiveContainer width="100%" height="100%">
          <PieChart margin={{ top: 20, right: 30, bottom: 20, left: 30 }}>
            <Pie
              data={chartData}
              cx="50%"
              cy="50%"
              labelLine={true}
              label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
              outerRadius={80}
              fill="#8884d8"
              dataKey="value"
              nameKey="name"
            >
              {chartData.map((entry, index) => (
                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
              ))}
            </Pie>
            <Tooltip content={<CustomTooltip totalValue={totalValue} />} />
          </PieChart>
        </ResponsiveContainer>
      ) : (
        <div className="flex items-center justify-center h-full">
            <p className="text-gray-500">표시할 데이터가 없습니다.</p>
        </div>
      )}
    </div>
  );
};

export default AllocationChart;
</file>

<file path="components/BulkUploadModal.tsx">
import React, { useState, useRef, useCallback } from 'react';
import { AssetCategory, Currency, EXCHANGE_MAP, BulkUploadResult, ALLOWED_CATEGORIES } from '../types';
import { usePortfolio } from '../contexts/PortfolioContext';

const BulkUploadModal: React.FC = () => {
  const { modal, actions } = usePortfolio();
  const isOpen = modal.bulkUploadOpen;
  const onClose = actions.closeBulkUpload;
  const onFileUpload = actions.uploadCsv;
  const [view, setView] = useState<'instructions' | 'loading' | 'results'>('instructions');
  const [result, setResult] = useState<BulkUploadResult | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const resetModal = useCallback(() => {
    setView('instructions');
    setResult(null);
    onClose();
  }, [onClose]);

  const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    setView('loading');
    try {
      const uploadResult = await onFileUpload(file);
      setResult(uploadResult);
      setView('results');
    } catch (e: unknown) {
       const reason = e instanceof Error ? e.message : '알 수 없는 오류';
       setResult({ successCount: 0, failedCount: 0, errors: [{ ticker: '파일 처리 오류', reason }] });
       setView('results');
    }
    
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const handleUploadClick = () => {
    fileInputRef.current?.click();
  };

  const handleDownloadTemplate = () => {
    const csvHeader = "ticker,exchange,quantity,purchasePrice,purchaseDate,category,currency\n";
    const csvExample = `AAPL,NASDAQ,10,150,2023-01-15,${AssetCategory.US_STOCK},${Currency.USD}\n005930,"KRX (코스피/코스닥)",20,70000,2023-03-22,${AssetCategory.KOREAN_STOCK},${Currency.KRW}\n`;
    const csvContent = csvHeader + csvExample;
    const blob = new Blob([`\uFEFF${csvContent}`], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'portfolio_template.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };
  
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-50" onClick={resetModal} role="dialog" aria-modal="true">
      <div className="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-3xl" onClick={(e) => e.stopPropagation()}>
        {view === 'instructions' && (
          <div>
            <h2 className="text-2xl font-bold text-white mb-4">CSV 일괄 등록</h2>
            <p className="text-gray-400 mb-4">CSV 파일을 사용하여 여러 자산을 한 번에 등록할 수 있습니다. 아래 형식을 준수해주세요.</p>
            <div className="bg-gray-900 p-4 rounded-md mb-4">
              <p className="text-sm text-gray-300 font-mono">ticker,exchange,quantity,purchasePrice,purchaseDate,category,currency</p>
              <p className="text-sm text-gray-500 font-mono mt-2">AAPL,NASDAQ,10,150.00,2023-01-15,미국주식,USD</p>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <div className="text-sm text-gray-400 space-y-2">
                    <p><strong className="text-gray-200">필수 헤더:</strong> <code>ticker, exchange, quantity, purchasePrice, purchaseDate, category, currency</code> 순서로 작성해야 합니다.</p>
                    <p><strong className="text-gray-200">category 값:</strong> <code>{ALLOWED_CATEGORIES.join(', ')}</code> 중 하나여야 합니다.</p>
                    <p><strong className="text-gray-200">currency 값:</strong> <code>{Object.values(Currency).join(', ')}</code> 중 하나여야 합니다.</p>
                </div>
                <div className="text-sm">
                    <strong className="text-gray-200">사용 가능한 Exchange 값:</strong>
                    <div className="max-h-32 overflow-y-auto bg-gray-900 p-2 mt-1 rounded-md text-gray-400 text-xs">
                        {Object.entries(EXCHANGE_MAP).map(([category, exchanges]) => (
                            <div key={category} className="mb-1">
                                <span className="font-semibold text-gray-300">{category}:</span>
                                <span className="font-mono ml-2">{exchanges.join(', ')}</span>
                            </div>
                        ))}
                    </div>
                </div>
            </div>

            <input type="file" ref={fileInputRef} onChange={handleFileSelect} accept=".csv,text/csv" className="hidden" />
            <div className="flex justify-between items-center mt-8">
              <button onClick={handleDownloadTemplate} className="text-primary hover:text-primary-light transition font-medium">양식 다운로드</button>
              <div className="flex gap-4">
                 <button onClick={resetModal} className="bg-gray-600 hover:bg-gray-500 text-white font-medium py-2 px-4 rounded-md transition duration-300">취소</button>
                 <button onClick={handleUploadClick} className="bg-primary hover:bg-primary-dark text-white font-bold py-2 px-4 rounded-md transition duration-300">파일 선택하여 업로드</button>
              </div>
            </div>
          </div>
        )}
        {view === 'loading' && (
          <div className="flex flex-col items-center justify-center p-8 h-64">
            <svg className="animate-spin h-10 w-10 text-white mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p className="text-xl text-white">자산 정보를 처리 중입니다...</p>
            <p className="text-gray-400 mt-2">등록할 자산 수에 따라 몇 분 정도 소요될 수 있습니다.</p>
          </div>
        )}
        {view === 'results' && result && (
          <div>
            <h2 className="text-2xl font-bold text-white mb-4">일괄 등록 결과</h2>
            <div className="flex gap-4 mb-4 text-center">
               <div className="bg-success/20 text-success p-4 rounded-lg flex-1">
                    <p className="text-sm">성공</p>
                    <p className="text-3xl font-bold">{result.successCount}</p>
               </div>
               <div className="bg-danger/20 text-danger p-4 rounded-lg flex-1">
                    <p className="text-sm">실패</p>
                    <p className="text-3xl font-bold">{result.failedCount}</p>
               </div>
            </div>
            {result.errors.length > 0 && (
                <div className="mt-4">
                    <h3 className="text-lg font-semibold text-white mb-2">실패 내역</h3>
                    <div className="max-h-48 overflow-y-auto bg-gray-900 p-3 rounded-md">
                        <ul className="space-y-2 text-sm">
                            {result.errors.map((err, index) => (
                                <li key={index} className="flex justify-between items-center p-2 rounded bg-gray-700">
                                    <span className="font-mono text-red-400 font-semibold">{err.ticker}</span>
                                    <span className="text-gray-300 text-right">{err.reason}</span>
                                </li>
                            ))}
                        </ul>
                    </div>
                </div>
            )}
            <div className="mt-8 flex justify-end">
                 <button onClick={resetModal} className="bg-primary hover:bg-primary-dark text-white font-bold py-2 px-4 rounded-md transition duration-300">확인</button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default BulkUploadModal;
</file>

<file path="components/ExchangeRateInput.tsx">
import React from 'react';
import { ExchangeRates } from '../types';

interface Props {
  rates: ExchangeRates;
  onRatesChange: (rates: ExchangeRates) => void;
  showWarning?: boolean;
  className?: string;
}

const ExchangeRateInput: React.FC<Props> = ({ rates, onRatesChange, showWarning, className = '' }) => {
  return (
    <div className={className}>
      <div className="flex items-center gap-6 flex-wrap">
        <div className="flex items-center gap-2">
          <label className="text-sm text-gray-300">USD→KRW</label>
          <input
            type="number"
            step="0.01"
            value={rates.USD || 0}
            onChange={(e) => onRatesChange({ ...rates, USD: parseFloat(e.target.value) || 0 })}
            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm w-28"
            placeholder="예: 1400"
          />
        </div>
        <div className="flex items-center gap-2">
          <label className="text-sm text-gray-300">JPY→KRW</label>
          <input
            type="number"
            step="0.01"
            value={rates.JPY || 0}
            onChange={(e) => onRatesChange({ ...rates, JPY: parseFloat(e.target.value) || 0 })}
            className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm w-28"
            placeholder="예: 9.5"
          />
        </div>
        {showWarning && (
          <div className="text-yellow-400 text-sm">
            환율을 입력하세요. 미입력 시 원화 환산 값이 0으로 표시됩니다.
          </div>
        )}
      </div>
    </div>
  );
};

export default ExchangeRateInput;
</file>

<file path="components/layouts/AnalyticsView.tsx">
import React from 'react';
import { usePortfolio } from '../../contexts/PortfolioContext';
import SellAnalyticsPage from '../SellAnalyticsPage';

const AnalyticsView: React.FC = () => {
  const { data } = usePortfolio();
  const assets = data.assets;
  const sellHistory = data.sellHistory;
  return (
    <SellAnalyticsPage assets={assets} sellHistory={sellHistory} />
  );
};

export default AnalyticsView;
</file>

<file path="components/layouts/PortfolioView.tsx">
import React, { useMemo } from 'react';
import { Asset } from '../../types';
import PortfolioTable from '../PortfolioTable';
import SellAlertControl from '../SellAlertControl';
import { usePortfolio } from '../../contexts/PortfolioContext';

const PortfolioView: React.FC = () => {
  const { data, ui, actions, status } = usePortfolio();
  const assets = data.assets;
  const portfolioHistory = data.portfolioHistory;
  const exchangeRates = data.exchangeRates;
  const filterCategory = ui.filterCategory;
  const filterAlerts = ui.filterAlerts;
  const searchQuery = ui.searchQuery;
  const sellAlertDropRate = ui.sellAlertDropRate;
  const filteredAssets = useMemo(() => {
    let filtered = assets;
    if (filterCategory !== 'ALL') {
      filtered = filtered.filter(asset => asset.category === filterCategory);
    }
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase().trim();
      filtered = filtered.filter(asset => 
        ((asset.customName?.toLowerCase() || asset.name.toLowerCase()).includes(query)) ||
        asset.ticker.toLowerCase().includes(query) ||
        (asset.memo && asset.memo.toLowerCase().includes(query))
      );
    }
    return filtered;
  }, [assets, filterCategory, searchQuery]);

  return (
    <div className="space-y-6">
       <SellAlertControl value={sellAlertDropRate} onChange={actions.setSellAlertDropRate} />
        <PortfolioTable
          assets={filteredAssets}
          history={portfolioHistory}
          onRefreshAll={() => actions.refreshAllPrices(false)}
          onRefreshSelected={actions.refreshSelectedPrices}
          onRefreshOne={actions.refreshOnePrice}
          onEdit={actions.openEditModal}
          onSell={actions.openSellModal}
          isLoading={status.isLoading}
          sellAlertDropRate={sellAlertDropRate}
          filterCategory={filterCategory}
          onFilterChange={actions.setFilterCategory}
          filterAlerts={filterAlerts}
          onFilterAlertsChange={actions.setFilterAlerts}
          searchQuery={searchQuery}
          onSearchChange={actions.setSearchQuery}
          onAddSelectedToWatchlist={(assets: Asset[]) => actions.addSelectedToWatchlist(assets)}
          failedIds={new Set(status.failedAssetIds)}
          exchangeRates={exchangeRates}
        />
    </div>
  );
};

export default PortfolioView;
</file>

<file path="components/layouts/WatchlistView.tsx">
import React from 'react';
import { WatchlistItem } from '../../types';
import { usePortfolio } from '../../contexts/PortfolioContext';
import WatchlistPage from '../WatchlistPage';

const WatchlistView: React.FC = () => {
  const { data, status, actions } = usePortfolio();
  const watchlist = data.watchlist;
  const isLoading = status.isLoading;
  return (
    <WatchlistPage
      watchlist={watchlist}
      onAdd={actions.addWatchItem}
      onUpdate={actions.updateWatchItem}
      onDelete={actions.deleteWatchItem}
      onToggleMonitoring={actions.toggleWatchMonitoring}
      onRefreshAll={actions.refreshWatchlistPrices}
      isLoading={isLoading}
      onBulkDelete={actions.bulkDeleteWatchItems}
    />
  );
};

export default WatchlistView;
</file>

<file path="components/portfolio-table/PortfolioTableRow.tsx">
import React, { Fragment, useRef, useState } from 'react';
import { Asset, Currency, PortfolioSnapshot } from '../../types';
import { EnrichedAsset } from './types';
import AssetTrendChart from '../AssetTrendChart';
import { MoreHorizontal } from 'lucide-react';
import { useOnClickOutside } from '../../hooks/useOnClickOutside';
import { formatNumber, formatOriginalCurrency, formatKRW, formatProfitLoss, getChangeColor } from './utils';

interface PortfolioTableRowProps {
  asset: EnrichedAsset;
  history: PortfolioSnapshot[];
  selectedIds: Set<string>;
  onSelect: (id: string, checked: boolean) => void;
  showHiddenColumns: boolean;
  sellAlertDropRate: number;
  onEdit: (asset: Asset) => void;
  onSell?: (asset: Asset) => void;
  filterAlerts: boolean;
}

const ChartBarIcon: React.FC = () => (
  <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
  </svg>
);

const PortfolioTableRow: React.FC<PortfolioTableRowProps> = ({
  asset,
  history,
  selectedIds,
  onSelect,
  showHiddenColumns,
  sellAlertDropRate,
  onEdit,
  onSell,
  filterAlerts
}) => {
  const [expandedAssetId, setExpandedAssetId] = useState<string | null>(null);
  const [openMenuId, setOpenMenuId] = useState<string | null>(null);
  const menuRef = useRef<HTMLDivElement | null>(null);

  useOnClickOutside(menuRef, () => setOpenMenuId(null), !!openMenuId);

  const handleToggleExpand = (assetId: string) => {
    setExpandedAssetId(prevId => (prevId === assetId ? null : assetId));
  };

  const { purchaseValue, currentValue, purchaseValueKRW, currentValueKRW, returnPercentage, allocation, dropFromHigh, profitLoss, profitLossKRW, diffFromHigh, yesterdayChange, diffFromYesterday } = asset.metrics;
  const alertRate = asset.sellAlertDropRate ?? sellAlertDropRate;
  const isAlertTriggered = dropFromHigh <= -alertRate;
  const isNonKRW = asset.currency !== Currency.KRW;
  const investmentColor = getChangeColor(returnPercentage);

  return (
    <Fragment>
      <tr className={`border-b border-gray-700 transition-colors duration-200 hover:bg-gray-700/50`}>
        <td className="px-4 py-4 text-center">
          <input type="checkbox" checked={selectedIds.has(asset.id)} onChange={(e) => onSelect(asset.id, e.target.checked)} />
        </td>
        <td className="px-4 py-4 font-medium text-white break-words">
          <div className="flex flex-col">
             <div className="flex items-center gap-2">
               <a 
                 href={`https://www.google.com/search?q=${encodeURIComponent(asset.ticker + ' 주가')}`}
                 target="_blank" 
                 rel="noopener noreferrer"
                 className="font-bold hover:underline text-primary-light cursor-pointer"
               >
                 {(asset.customName?.trim() || asset.name)}
               </a>
               {isAlertTriggered && <span className="text-xs" title="알림 조건 도달">⚠️</span>}
             </div>
            <span className="text-xs text-gray-500 break-all">{asset.ticker} | {asset.exchange}</span>
          </div>
        </td>
        {showHiddenColumns && <td className="px-4 py-4 text-right">{formatNumber(asset.quantity)}</td>}
        {showHiddenColumns && (
          <td className="px-4 py-4 text-right">
            <div>{formatOriginalCurrency(asset.purchasePrice, asset.currency)}</div>
            {isNonKRW && <div className="text-xs text-gray-500">≈ {formatKRW(asset.metrics.purchasePriceKRW)}</div>}
          </td>
        )}
        <td className="px-4 py-4 text-right">
          <div className="font-semibold text-white">{formatOriginalCurrency(asset.currentPrice, asset.currency)}</div>
          {isNonKRW && <div className="text-xs text-gray-500">≈ {formatKRW(asset.metrics.currentPriceKRW)}</div>}
        </td>
        <td className={`px-4 py-4 font-medium text-right ${getChangeColor(returnPercentage)}`}>
          <div>{returnPercentage.toFixed(2)}%</div>
          <div className="text-xs opacity-80">{formatProfitLoss(profitLoss, asset.currency)}</div>
        </td>
        <td className="px-4 py-4 text-right">
          <div className={investmentColor}>{formatOriginalCurrency(purchaseValue, asset.currency)}</div>
          {isNonKRW && <div className="text-xs text-gray-500">≈ {formatKRW(purchaseValueKRW)}</div>}
        </td>
        <td className="px-4 py-4 text-right">
          <div className="font-semibold text-white">{formatOriginalCurrency(currentValue, asset.currency)}</div>
          {isNonKRW && <div className="text-xs text-gray-500">≈ {formatKRW(currentValueKRW)}</div>}
        </td>
        {showHiddenColumns && <td className="px-4 py-4 text-center">{asset.purchaseDate}</td>}
        {showHiddenColumns && <td className="px-4 py-4 text-right">{allocation.toFixed(2)}%</td>}
        <td className={`px-4 py-4 font-medium text-right ${getChangeColor(dropFromHigh)}`}>
            <div>{dropFromHigh.toFixed(2)}%</div>
            <div className="text-xs opacity-80">{formatProfitLoss(diffFromHigh, asset.currency)}</div>
        </td>
        <td className={`px-4 py-4 font-medium text-right ${getChangeColor(yesterdayChange)}`}>
          <div>{yesterdayChange.toFixed(2)}%</div>
          <div className="text-xs opacity-80">{formatProfitLoss(diffFromYesterday, Currency.KRW)}</div>
        </td>
        <td className="px-4 py-4 text-center relative">
          <div className="flex items-center justify-center gap-1">
            <button onClick={() => handleToggleExpand(asset.id)} className="p-2 text-gray-300 hover:text-white" title="차트">
                <ChartBarIcon />
            </button>
            <button onClick={() => setOpenMenuId(openMenuId === asset.id ? null : asset.id)} className="p-2 text-gray-300 hover:text-white">
                <MoreHorizontal className="h-5 w-5" />
            </button>
          </div>
          {openMenuId === asset.id && (
            <div ref={menuRef} className="absolute right-0 mt-2 w-44 bg-gray-800 border border-gray-700 rounded-md shadow-lg z-30 text-sm">
               <button onClick={() => { setOpenMenuId(null); onEdit(asset); }} className="block w-full text-left px-3 py-2 hover:bg-gray-700 text-white">수정</button>
               {onSell && <button onClick={() => { setOpenMenuId(null); onSell(asset); }} className="block w-full text-left px-3 py-2 text-red-400 hover:bg-gray-700">매도</button>}
               <button onClick={() => { setOpenMenuId(null); handleToggleExpand(asset.id); }} className="block w-full text-left px-3 py-2 text-gray-200 hover:bg-gray-700">차트 보기</button>
            </div>
          )}
        </td>
      </tr>
      {expandedAssetId === asset.id && (
        <tr className="bg-gray-900/50">
          <td colSpan={showHiddenColumns ? 13 : 9} className="p-0 sm:p-2">
            <AssetTrendChart
              history={history}
              assetId={asset.id}
              assetName={(asset.customName?.trim() || asset.name)}
              // @ts-ignore: AssetTrendChart가 currentQuantity를 prop으로 받도록 수정되었는지 확인 필요
              currentQuantity={asset.quantity} 
            />
          </td>
        </tr>
      )}
    </Fragment>
  );
};

export default PortfolioTableRow;
</file>

<file path="components/portfolio-table/types.ts">
import { Asset, AssetCategory, PortfolioSnapshot, ExchangeRates } from '../../types';

export interface PortfolioTableProps {
  assets: Asset[];
  history: PortfolioSnapshot[];
  onRefreshAll: () => void;
  onRefreshSelected?: (ids: string[]) => void | Promise<void>;
  onRefreshOne?: (id: string) => void | Promise<void>;
  onEdit: (asset: Asset) => void;
  onSell?: (asset: Asset) => void;
  isLoading: boolean;
  sellAlertDropRate: number;
  filterCategory: AssetCategory | 'ALL';
  onFilterChange: (category: AssetCategory | 'ALL') => void;
  filterAlerts: boolean;
  onFilterAlertsChange: (isActive: boolean) => void;
  searchQuery?: string;
  onSearchChange?: (query: string) => void;
  onAddSelectedToWatchlist?: (assets: Asset[]) => void;
  failedIds?: Set<string>;
  exchangeRates: ExchangeRates;
}

export type SortKey = 'name' | 'purchaseDate' | 'quantity' | 'purchasePrice' | 'currentPrice' | 'returnPercentage' | 'dropFromHigh' | 'yesterdayChange' | 'purchaseValue' | 'currentValue' | 'allocation' | 'profitLoss' | 'profitLossKRW';
export type SortDirection = 'ascending' | 'descending';

export interface AssetMetrics {
  purchasePrice: number;
  currentPrice: number;
  currentPriceKRW: number;
  purchasePriceKRW: number;
  purchaseValue: number;
  currentValue: number;
  purchaseValueKRW: number;
  currentValueKRW: number;
  returnPercentage: number;
  allocation: number;
  dropFromHigh: number;
  profitLoss: number;
  profitLossKRW: number;
  diffFromHigh: number;
  yesterdayChange: number;
  diffFromYesterday: number;
}

export interface EnrichedAsset extends Asset {
  metrics: AssetMetrics;
}
</file>

<file path="hooks/useAssetActions.ts">
import { useCallback, useState } from 'react';
import { Asset, AssetCategory, BulkUploadResult, Currency, ExchangeRates, NewAssetForm, PortfolioSnapshot, SellRecord, WatchlistItem, ALLOWED_CATEGORIES, normalizeExchange } from '../types';
import { fetchAssetData as fetchAssetDataNew, fetchExchangeRate, fetchExchangeRateJPY } from '../services/priceService';
import { fetchHistoricalExchangeRate, fetchCurrentExchangeRate } from '../services/geminiService';

interface UseAssetActionsProps {
  assets: Asset[];
  setAssets: React.Dispatch<React.SetStateAction<Asset[]>>;
  watchlist: WatchlistItem[];
  setWatchlist: React.Dispatch<React.SetStateAction<WatchlistItem[]>>;
  portfolioHistory: PortfolioSnapshot[];
  sellHistory: SellRecord[];
  setSellHistory: React.Dispatch<React.SetStateAction<SellRecord[]>>;
  exchangeRates: ExchangeRates;
  isSignedIn: boolean;
  triggerAutoSave: (assets: Asset[], history: PortfolioSnapshot[], sells: SellRecord[], watchlist: WatchlistItem[], rates: ExchangeRates) => void;
  setError: (msg: string | null) => void;
  setSuccessMessage: (msg: string | null) => void;
}

export const useAssetActions = ({
  assets,
  setAssets,
  watchlist,
  setWatchlist,
  portfolioHistory,
  sellHistory,
  setSellHistory,
  exchangeRates,
  isSignedIn,
  triggerAutoSave,
  setError,
  setSuccessMessage
}: UseAssetActionsProps) => {
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [editingAsset, setEditingAsset] = useState<Asset | null>(null);
  const [sellingAsset, setSellingAsset] = useState<Asset | null>(null);

  // 자산 추가
  const handleAddAsset = useCallback(async (newAssetData: NewAssetForm) => {
    if (!isSignedIn) {
      setError('Google Drive 로그인 후 자산을 추가할 수 있습니다.');
      setTimeout(() => setError(null), 3000);
      return;
    }
    setIsLoading(true);
    setError(null);
    try {
      let newAsset: Omit<Asset, 'id'>;
      if (newAssetData.category === AssetCategory.CASH) {
        const [purchaseExchangeRate, currentExchangeRate] = await Promise.all([
          fetchHistoricalExchangeRate(newAssetData.purchaseDate, newAssetData.currency, Currency.KRW),
          (newAssetData.currency === Currency.USD 
            ? fetchExchangeRate() 
            : newAssetData.currency === Currency.JPY 
              ? fetchExchangeRateJPY() 
              : fetchCurrentExchangeRate(newAssetData.currency, Currency.KRW))
        ]);

        newAsset = {
          ...newAssetData,
          ticker: newAssetData.currency,
          name: `현금 (${newAssetData.currency})`,
          currentPrice: currentExchangeRate * newAssetData.purchasePrice,
          priceOriginal: newAssetData.purchasePrice,
          highestPrice: currentExchangeRate * newAssetData.purchasePrice,
          purchaseExchangeRate,
        };
      } else {
        const d = await fetchAssetDataNew({ ticker: newAssetData.ticker, exchange: newAssetData.exchange, category: newAssetData.category, currency: newAssetData.currency });
        const purchaseExchangeRate = await fetchHistoricalExchangeRate(newAssetData.purchaseDate, newAssetData.currency, Currency.KRW);
        const currentPrice = newAssetData.currency === Currency.KRW ? d.priceKRW : d.priceOriginal;
        newAsset = {
          ...newAssetData,
          name: d.name,
          currentPrice,
          priceOriginal: d.priceOriginal,
          highestPrice: currentPrice,
          purchaseExchangeRate,
          currency: d.currency || newAssetData.currency,
        };
      }
      
      const finalNewAsset: Asset = {
        id: new Date().getTime().toString(),
        ...newAsset
      };

      setAssets(prevAssets => {
        const newAssets = [...prevAssets, finalNewAsset];
        triggerAutoSave(newAssets, portfolioHistory, sellHistory, watchlist, exchangeRates);
        return newAssets;
      });
      setSuccessMessage(`${finalNewAsset.name} 자산이 추가되었습니다.`);
      setTimeout(() => setSuccessMessage(null), 3000);
    } catch (e) {
      console.error(e);
      setError('자산 정보를 가져오는 데 실패했습니다. 티커, 거래소, 날짜를 확인해주세요.');
      setTimeout(() => setError(null), 3000);
    } finally {
      setIsLoading(false);
    }
  }, [isSignedIn, portfolioHistory, sellHistory, watchlist, exchangeRates, triggerAutoSave, setAssets, setError, setSuccessMessage]);

  // 자산 삭제
  const handleDeleteAsset = useCallback((assetId: string) => {
    if (!isSignedIn) {
      setError('Google Drive 로그인 후 자산을 삭제할 수 있습니다.');
      setTimeout(() => setError(null), 3000);
      return;
    }
    setAssets(prevAssets => {
      const updated = prevAssets.filter(asset => asset.id !== assetId);
      triggerAutoSave(updated, portfolioHistory, sellHistory, watchlist, exchangeRates);
      return updated;
    });
    setEditingAsset(null);
  }, [isSignedIn, portfolioHistory, sellHistory, watchlist, exchangeRates, triggerAutoSave, setAssets, setError]);

  // 자산 수정
  const handleUpdateAsset = useCallback(async (updatedAsset: Asset) => {
    if (!isSignedIn) {
      setError('Google Drive 로그인 후 자산을 수정할 수 있습니다.');
      setTimeout(() => setError(null), 3000);
      return;
    }
    const originalAsset = assets.find(a => a.id === updatedAsset.id);
    if (!originalAsset) return;

    setIsLoading(true);
    setError(null);

    try {
      let finalAsset = { ...updatedAsset };
      
      if (updatedAsset.category === AssetCategory.CASH) {
          const dateOrCurrencyChanged = originalAsset.purchaseDate !== updatedAsset.purchaseDate ||
                                      originalAsset.currency !== updatedAsset.currency;

          if (dateOrCurrencyChanged) {
                const [purchaseExchangeRate, currentExchangeRate] = await Promise.all([
                  fetchHistoricalExchangeRate(updatedAsset.purchaseDate, updatedAsset.currency, Currency.KRW),
                  (updatedAsset.currency === Currency.USD 
                    ? fetchExchangeRate() 
                    : updatedAsset.currency === Currency.JPY 
                      ? fetchExchangeRateJPY() 
                      : fetchCurrentExchangeRate(updatedAsset.currency, Currency.KRW))
                ]);
                finalAsset = {
                    ...finalAsset,
                    ticker: updatedAsset.currency,
                    name: `현금 (${updatedAsset.currency})`,
                    purchaseExchangeRate,
                    currentPrice: currentExchangeRate * finalAsset.priceOriginal,
                    highestPrice: Math.max(originalAsset.highestPrice, currentExchangeRate * finalAsset.priceOriginal),
                };
          }
      } else {
          const infoChanged = originalAsset.ticker.toUpperCase() !== updatedAsset.ticker.toUpperCase() ||
                              originalAsset.exchange !== updatedAsset.exchange;
          
          const dateOrCurrencyChanged = originalAsset.purchaseDate !== updatedAsset.purchaseDate ||
                                        originalAsset.currency !== updatedAsset.currency;

          if (infoChanged) {
            const d = await fetchAssetDataNew({ ticker: updatedAsset.ticker, exchange: updatedAsset.exchange, category: updatedAsset.category, currency: updatedAsset.currency });
            const newCurrentPrice = finalAsset.currency === Currency.KRW ? d.priceKRW : d.priceOriginal;
            finalAsset = {
              ...finalAsset,
              name: d.name,
              currentPrice: newCurrentPrice,
              priceOriginal: d.priceOriginal,
              currency: d.currency || finalAsset.currency,
              highestPrice: Math.max(finalAsset.highestPrice, newCurrentPrice),
            };
          }
          
          if (infoChanged || dateOrCurrencyChanged) {
            const purchaseExchangeRate = await fetchHistoricalExchangeRate(finalAsset.purchaseDate, finalAsset.currency, Currency.KRW);
            finalAsset.purchaseExchangeRate = purchaseExchangeRate;
          }
      }

      setAssets(prevAssets => {
        const updated = prevAssets.map(asset => 
          asset.id === updatedAsset.id ? finalAsset : asset
        );
          triggerAutoSave(updated, portfolioHistory, sellHistory, watchlist, exchangeRates);
        return updated;
      });
      setEditingAsset(null);
    } catch (e) {
      console.error(e);
      setError('자산 정보 업데이트에 실패했습니다. 입력값을 확인해주세요.');
      setTimeout(() => setError(null), 3000);
    } finally {
      setIsLoading(false);
    }
  }, [isSignedIn, assets, portfolioHistory, sellHistory, watchlist, exchangeRates, triggerAutoSave, setAssets, setError]);

  // 자산 매도
  const handleConfirmSell = useCallback(async (
    assetId: string,
    sellDate: string,
    sellPrice: number,
    sellQuantity: number,
    currency: Currency
  ) => {
    if (!isSignedIn) {
      setError('Google Drive 로그인 후 매도할 수 있습니다.');
      setTimeout(() => setError(null), 3000);
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      const updatedAssets = assets.map(a => {
        if (a.id === assetId) {
          const sellTransaction = {
            id: `${assetId}-${Date.now()}`,
            sellDate,
            sellPrice,
            sellQuantity,
            currency,
          };

          const updatedAsset: Asset = {
            ...a,
            quantity: a.quantity - sellQuantity,
            sellTransactions: [...(a.sellTransactions || []), sellTransaction],
          };

          const record: SellRecord = {
            assetId: a.id,
            ticker: a.ticker,
            name: a.name,
            category: a.category,
            ...sellTransaction,
          };
          setSellHistory(prev => [...prev, record]);

          return updatedAsset.quantity <= 0 ? null : updatedAsset;
        }
        return a;
      }).filter((a): a is Asset => a !== null);

      setAssets(updatedAssets);
      setSellingAsset(null);
      setSuccessMessage('매도가 완료되었습니다.');
      setTimeout(() => setSuccessMessage(null), 3000);
      
      triggerAutoSave(updatedAssets, portfolioHistory, sellHistory, watchlist, exchangeRates);
    } catch (error) {
      console.error('Failed to sell asset:', error);
      setError('매도 처리 중 오류가 발생했습니다.');
      setTimeout(() => setError(null), 3000);
    } finally {
      setIsLoading(false);
    }
  }, [isSignedIn, assets, portfolioHistory, sellHistory, watchlist, exchangeRates, triggerAutoSave, setAssets, setSellHistory, setError, setSuccessMessage]);

  // CSV 업로드
  const handleCsvFileUpload = useCallback(async (file: File): Promise<BulkUploadResult> => {
    if (!isSignedIn) {
      return {
        successCount: 0,
        failedCount: 0,
        errors: [{ ticker: '권한 없음', reason: 'Google Drive 로그인 후 이용해주세요.' }]
      };
    }
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = async (e) => {
            let successCount = 0;
            let failedCount = 0;
            const errors: { ticker: string; reason: string }[] = [];
            const lines = (e.target?.result as string).split('\n').filter(line => line.trim() !== '');

            try {
                if (lines.length < 2) throw new Error('CSV 파일에 헤더와 데이터가 포함되어야 합니다.');
                
                const headerLine = lines[0].trim().replace(/\uFEFF/g, '');
                const header = headerLine.split(',').map(h => h.trim());
                
                const expectedHeaders = [
                  ['ticker', 'exchange', 'quantity', 'purchasePrice', 'purchaseDate', 'category', 'currency', 'sellAlertDropRate'],
                  ['ticker', 'exchange', 'quantity', 'purchasePrice', 'purchaseDate', 'category', 'currency']
                ];

                const headerMatch = expectedHeaders.find(h => JSON.stringify(h) === JSON.stringify(header));

                if (!headerMatch) {
                    throw new Error(`잘못된 헤더입니다. 예상 헤더: ${expectedHeaders[1].join(',')}`);
                }
                const hasSellAlertRate = headerMatch.length === 8;
                
                const rows = lines.slice(1);
                const newAssetForms: (NewAssetForm & { sellAlertDropRate?: number } | { error: string, ticker: string })[] = rows.map((row, index) => {
                    const values = row.trim().split(',');
                    if (values.length < 7 || values.length > 8) {
                        return { error: `${headerMatch.length}개의 값이 필요합니다.`, ticker: `행 ${index + 2}` };
                    }
                    const [ticker, exchange, quantityStr, priceStr, dateStr, categoryStr, currencyStr, sellAlertDropRateStr] = values.map(v => v.trim());
                    
                    if (!ticker) return { error: '티커가 비어있습니다.', ticker: `행 ${index + 2}` };
                    if (!exchange) return { error: '거래소가 비어있습니다.', ticker: `행 ${index + 2}` };
                    if (isNaN(parseFloat(quantityStr)) || parseFloat(quantityStr) <= 0) return { error: '수량이 유효한 숫자가 아닙니다.', ticker };
                    if (isNaN(parseFloat(priceStr)) || parseFloat(priceStr) < 0) return { error: '매수가가 유효한 숫자가 아닙니다.', ticker };
                    if (!/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) return { error: '날짜 형식이 YYYY-MM-DD가 아닙니다.', ticker };
                    if (!ALLOWED_CATEGORIES.includes(categoryStr as AssetCategory)) return { error: '유효하지 않은 자산 구분입니다.', ticker };
                    if (!Object.values(Currency).includes(currencyStr as Currency)) return { error: '유효하지 않은 통화입니다.', ticker };
                    
                    const form: NewAssetForm & { sellAlertDropRate?: number } = {
                        ticker,
                        exchange,
                        quantity: parseFloat(quantityStr),
                        purchasePrice: parseFloat(priceStr),
                        purchaseDate: dateStr,
                        category: categoryStr as AssetCategory,
                        currency: currencyStr as Currency,
                    };

                    if (hasSellAlertRate && sellAlertDropRateStr) {
                      const rate = parseFloat(sellAlertDropRateStr);
                      if (!isNaN(rate) && rate > 0) {
                        form.sellAlertDropRate = rate;
                      }
                    }

                    return form;
                });

                const validForms = newAssetForms.filter(f => !('error' in f)) as (NewAssetForm & { sellAlertDropRate?: number })[];
                const invalidForms = newAssetForms.filter(f => 'error' in f) as { error: string, ticker: string }[];

                invalidForms.forEach(form => {
                    errors.push({ ticker: form.ticker, reason: form.error });
                });
                
                if (validForms.length > 0) {
                    const newAssets: Asset[] = [];
                    for (const form of validForms) {
                        try {
                           let newAsset: Omit<Asset, 'id'>;
                              const d = await fetchAssetDataNew({ ticker: form.ticker, exchange: form.exchange, category: form.category, currency: form.currency });
                              const purchaseExchangeRate = await fetchHistoricalExchangeRate(form.purchaseDate, form.currency, Currency.KRW);
                              {
                                  const currentPrice = form.currency === Currency.KRW ? d.priceKRW : d.priceOriginal;
                                  newAsset = {
                                      ...form,
                                      name: d.name,
                                      currentPrice,
                                      priceOriginal: d.priceOriginal,
                                      currency: d.currency || form.currency,
                                      highestPrice: currentPrice,
                                      purchaseExchangeRate,
                                  };
                              }
                            
                            const finalNewAsset: Asset = {
                                id: `${new Date().getTime()}-${form.ticker}`,
                                ...newAsset
                            };

                            if (form.sellAlertDropRate) {
                              finalNewAsset.sellAlertDropRate = form.sellAlertDropRate;
                            }
                            newAssets.push(finalNewAsset);
                        } catch (error: unknown) {
                            errors.push({
                                ticker: form.ticker,
                                reason: error instanceof Error ? error.message : '데이터 조회 실패',
                            });
                        }
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    
                    setAssets(prev => {
                        const updated = [...prev, ...newAssets];
                        triggerAutoSave(updated, portfolioHistory, sellHistory, watchlist, exchangeRates);
                        return updated;
                    });
                    successCount = newAssets.length;
                }
                
                failedCount = errors.length;
                resolve({ successCount, failedCount, errors });

            } catch (err: unknown) {
                resolve({ successCount: 0, failedCount: lines.length > 1 ? lines.length - 1 : 0, errors: [{ ticker: '파일 전체', reason: err instanceof Error ? err.message : '파일 처리 실패' }] });
            }
        };

        reader.onerror = () => {
             resolve({ successCount: 0, failedCount: 0, errors: [{ ticker: '파일 읽기 오류', reason: '파일을 읽는 데 실패했습니다.' }] });
        };
        
        reader.readAsText(file);
    });
  }, [isSignedIn, portfolioHistory, sellHistory, watchlist, exchangeRates, triggerAutoSave, setAssets]);

  // 관심종목 추가
  const handleAddWatchItem = useCallback((payload: Omit<WatchlistItem, 'id' | 'currentPrice' | 'priceOriginal' | 'currency' | 'yesterdayPrice' | 'highestPrice' | 'lastSignalAt' | 'lastSignalType'>) => {
    const id = `${Date.now()}`;
    const item: WatchlistItem = { ...payload, id } as WatchlistItem;
    setWatchlist(prev => {
      const exists = prev.some(w => w.ticker.toUpperCase() === item.ticker.toUpperCase() && normalizeExchange(w.exchange) === normalizeExchange(item.exchange));
      const next = exists ? prev : [...prev, item];
      triggerAutoSave(assets, portfolioHistory, sellHistory, next, exchangeRates);
      return next;
    });
  }, [assets, portfolioHistory, sellHistory, exchangeRates, triggerAutoSave, setWatchlist]);

  // 관심종목 수정
  const handleUpdateWatchItem = useCallback((item: WatchlistItem) => {
    setWatchlist(prev => {
      const next = prev.map(w => (w.id === item.id ? item : w));
      triggerAutoSave(assets, portfolioHistory, sellHistory, next, exchangeRates);
      return next;
    });
  }, [assets, portfolioHistory, sellHistory, exchangeRates, triggerAutoSave, setWatchlist]);

  // 관심종목 삭제
  const handleDeleteWatchItem = useCallback((id: string) => {
    setWatchlist(prev => {
      const next = prev.filter(w => w.id !== id);
      triggerAutoSave(assets, portfolioHistory, sellHistory, next, exchangeRates);
      return next;
    });
  }, [assets, portfolioHistory, sellHistory, exchangeRates, triggerAutoSave, setWatchlist]);

  // 관심종목 일괄 삭제
  const handleBulkDeleteWatchItems = useCallback((ids: string[]) => {
    setWatchlist(prev => {
      const remove = new Set(ids);
      const next = prev.filter(w => !remove.has(w.id));
      triggerAutoSave(assets, portfolioHistory, sellHistory, next, exchangeRates);
      return next;
    });
  }, [assets, portfolioHistory, sellHistory, exchangeRates, triggerAutoSave, setWatchlist]);

  // 포트폴리오에서 관심종목으로 추가
  const handleAddAssetsToWatchlist = useCallback((selectedAssets: Asset[]) => {
    if (selectedAssets.length === 0) return;
    setWatchlist(prev => {
      const next = [...prev];
      selectedAssets.forEach(a => {
        const exists = next.some(w => w.ticker.toUpperCase() === a.ticker.toUpperCase() && normalizeExchange(w.exchange) === normalizeExchange(a.exchange));
        if (!exists) {
          next.push({
            id: `${Date.now()}-${a.id}`,
            ticker: a.ticker,
            exchange: a.exchange,
            name: a.customName?.trim() || a.name,
            category: a.category,
            monitoringEnabled: true,
          });
        }
      });
      triggerAutoSave(assets, portfolioHistory, sellHistory, next, exchangeRates);
      return next;
    });
  }, [assets, portfolioHistory, sellHistory, exchangeRates, triggerAutoSave, setWatchlist]);

  // 관심종목 모니터링 토글
  const handleToggleWatchMonitoring = useCallback((id: string, enabled: boolean) => {
    setWatchlist(prev => prev.map(w => (w.id === id ? { ...w, monitoringEnabled: enabled } : w)));
  }, [setWatchlist]);

  return {
    isLoading,
    editingAsset,
    setEditingAsset,
    sellingAsset,
    setSellingAsset,
    handleAddAsset,
    handleDeleteAsset,
    handleUpdateAsset,
    handleConfirmSell,
    handleCsvFileUpload,
    handleAddWatchItem,
    handleUpdateWatchItem,
    handleDeleteWatchItem,
    handleBulkDeleteWatchItems,
    handleAddAssetsToWatchlist,
    handleToggleWatchMonitoring
  };
};
</file>

<file path="hooks/useGoogleDriveSync.ts">
import { useCallback, useEffect, useRef, useState } from 'react';
import { googleDriveService, GoogleUser } from '../services/googleDriveService';
import { Asset, PortfolioSnapshot, SellRecord, WatchlistItem, ExchangeRates } from '../types';

interface UseGoogleDriveSyncOptions {
  onError?: (msg: string) => void;
  onSuccessMessage?: (msg: string) => void;
}

interface LoadedData {
  assets: Asset[];
  portfolioHistory: PortfolioSnapshot[];
  sellHistory: SellRecord[];
  watchlist: WatchlistItem[];
  exchangeRates?: ExchangeRates;
}

export function useGoogleDriveSync(options: UseGoogleDriveSyncOptions = {}) {
  const [isSignedIn, setIsSignedIn] = useState<boolean>(false);
  const [googleUser, setGoogleUser] = useState<GoogleUser | null>(null);
  const [isInitializing, setIsInitializing] = useState<boolean>(true);
  const timeoutIdRef = useRef<NodeJS.Timeout | null>(null);
  const isSavingRef = useRef<boolean>(false);
  const lastSavedDataRef = useRef<string | null>(null);
  
  // options를 ref로 관리하여 의존성 제거
  const optionsRef = useRef(options);
  useEffect(() => {
    optionsRef.current = options;
  });

  useEffect(() => {
    const init = async () => {
      try {
        const clientId = import.meta.env.VITE_GOOGLE_CLIENT_ID;
        if (clientId) {
          await googleDriveService.initialize(clientId);
          if (googleDriveService.isSignedIn()) {
            setIsSignedIn(true);
            setGoogleUser(googleDriveService.getCurrentUser());
          }
        }
      } catch (e) {
      } finally {
        setIsInitializing(false);
      }
    };
    init();
  }, []);

  const handleSignIn = useCallback(async (): Promise<GoogleUser> => {
    const clientId = import.meta.env.VITE_GOOGLE_CLIENT_ID;
    if (!clientId) {
      optionsRef.current.onError?.('Google Client ID가 설정되지 않았습니다. .env 파일에 VITE_GOOGLE_CLIENT_ID를 추가해주세요.');
      throw new Error('Missing Google Client ID');
    }
    await googleDriveService.initialize(clientId);
    const user = await googleDriveService.signIn();
    setIsSignedIn(true);
    setGoogleUser(user);
    optionsRef.current.onSuccessMessage?.(`${user.email} 계정으로 로그인되었습니다.`);
    return user;
  }, []);

  const handleSignOut = useCallback(() => {
    googleDriveService.signOut();
    setIsSignedIn(false);
    setGoogleUser(null);
    optionsRef.current.onSuccessMessage?.('로그아웃되었습니다. Google Drive 로그인 후 다시 이용해주세요.');
  }, []);

  const loadFromGoogleDrive = useCallback(async (): Promise<LoadedData | null> => {
    const fileContent = await googleDriveService.loadFile();
    if (!fileContent) {
      optionsRef.current.onSuccessMessage?.('Google Drive에 저장된 포트폴리오가 없습니다. 자산을 추가해주세요.');
      return {
        assets: [],
        portfolioHistory: [],
        sellHistory: [],
        watchlist: [],
      };
    }
    const data = JSON.parse(fileContent);
    const assets = Array.isArray(data.assets) ? data.assets as Asset[] : [];
    const portfolioHistory = Array.isArray(data.portfolioHistory) ? data.portfolioHistory as PortfolioSnapshot[] : [];
    const sellHistory = Array.isArray(data.sellHistory) ? data.sellHistory as SellRecord[] : [];
    const watchlist = Array.isArray(data.watchlist) ? data.watchlist as WatchlistItem[] : [];
    const exchangeRates = data.exchangeRates as ExchangeRates | undefined;
    optionsRef.current.onSuccessMessage?.('Google Drive에서 포트폴리오를 불러왔습니다.');
    return { assets, portfolioHistory, sellHistory, watchlist, exchangeRates };
  }, []);

  const autoSave = useCallback(async (assetsToSave: Asset[], history: PortfolioSnapshot[], sells: SellRecord[], watchlist: WatchlistItem[], exchangeRates?: ExchangeRates) => {
    if (!isSignedIn) {
      optionsRef.current.onError?.('Google Drive 로그인 후 저장할 수 있습니다.');
      return;
    }
    if (timeoutIdRef.current) {
      clearTimeout(timeoutIdRef.current);
    }
    timeoutIdRef.current = setTimeout(async () => {
      if (isSavingRef.current) return;
      const exportData = {
        assets: assetsToSave,
        portfolioHistory: history,
        sellHistory: sells,
        watchlist,
        exchangeRates,
        lastUpdateDate: new Date().toISOString().slice(0, 10),
      };
      const portfolioJSON = JSON.stringify(exportData, null, 2);
      if (lastSavedDataRef.current === portfolioJSON) {
        return;
      }
      isSavingRef.current = true;
      try {
        optionsRef.current.onSuccessMessage?.('저장 중...');
        await googleDriveService.saveFile(portfolioJSON);
        lastSavedDataRef.current = portfolioJSON;
        optionsRef.current.onSuccessMessage?.('Google Drive에 자동 저장되었습니다.');
      } catch (error) {
        optionsRef.current.onError?.('자동 저장에 실패했습니다.');
      } finally {
        isSavingRef.current = false;
      }
    }, 2000);
  }, [isSignedIn]);

  return {
    isSignedIn,
    googleUser,
    isInitializing,
    handleSignIn,
    handleSignOut,
    loadFromGoogleDrive,
    autoSave,
  };
}
</file>

<file path="components/PortfolioAssistant.tsx">
import React, { useState, useRef, useEffect, useMemo } from 'react';
import { Asset } from '../types';
import { askPortfolioQuestion } from '../services/geminiService';
import ReactMarkdown, { type Components } from 'react-markdown';
import remarkGfm from 'remark-gfm';
import rehypeRaw from 'rehype-raw';
import { usePortfolio } from '../contexts/PortfolioContext';


interface PortfolioAssistantProps {}

interface Message {
    role: 'user' | 'model';
    content: string;
}

const ASSISTANT_HISTORY_KEY = 'quant-assistant-history';

const PortfolioAssistant: React.FC<PortfolioAssistantProps> = () => {
    const { modal, actions, data } = usePortfolio();
    const isOpen = modal.assistantOpen;
    const onClose = actions.closeAssistant;
    const assets = data.assets;
    const [messages, setMessages] = useState<Message[]>(() => {
        try {
            const savedHistory = localStorage.getItem(ASSISTANT_HISTORY_KEY);
            return savedHistory ? JSON.parse(savedHistory) : [];
        } catch (error) {
            console.error("Failed to load assistant history:", error);
            return [];
        }
    });

    const [input, setInput] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const messagesEndRef = useRef<HTMLDivElement>(null);
    const inputRef = useRef<HTMLInputElement>(null);

    const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    };

    useEffect(scrollToBottom, [messages, isLoading]);
    
    useEffect(() => {
      if (isOpen) {
        setTimeout(() => inputRef.current?.focus(), 100);
      }
    }, [isOpen]);

    useEffect(() => {
        try {
            localStorage.setItem(ASSISTANT_HISTORY_KEY, JSON.stringify(messages));
        } catch (error) {
            console.error("Failed to save assistant history:", error);
        }
    }, [messages]);


    const handleSend = async () => {
        if (!input.trim() || isLoading) return;

        const userMessage: Message = { role: 'user', content: input };
        setMessages(prev => [...prev, userMessage]);
        setInput('');
        setIsLoading(true);

        try {
            const modelResponse = await askPortfolioQuestion(assets, input);
            const assistantMessage: Message = { role: 'model', content: modelResponse };
            setMessages(prev => [...prev, assistantMessage]);
        } catch (error) {
            console.error("Error asking portfolio question:", error);
            const errorMessage: Message = { role: 'model', content: "죄송합니다, 답변을 생성하는 중에 오류가 발생했습니다. 잠시 후 다시 시도해주세요." };
            setMessages(prev => [...prev, errorMessage]);
        } finally {
            setIsLoading(false);
        }
    };
    
    const examplePrompts = [
        "레이달리오의 사계절 포트폴리오 전략에 따라 내 자산 분배를 분석해줘.",
        "보유 종목 중 원자재 관련 주식이 있어?",
        "가장 수익률이 높은 자산은 뭐야?",
        "내 포트폴리오의 전반적인 위험도를 평가해줘."
    ];
    
    const handleExampleClick = (prompt: string) => {
        setInput(prompt);
        inputRef.current?.focus();
    };

    const handleClearHistory = () => {
        if (window.confirm('대화 기록을 정말 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.')) {
            setMessages([]);
            localStorage.removeItem(ASSISTANT_HISTORY_KEY);
        }
    };

    // 자산 데이터 캐싱 (속도 개선)
    const assetsSnapshot = useMemo(() => {
        return JSON.stringify(assets.map(asset => ({
            name: asset.customName ?? asset.name,
            category: asset.category,
            quantity: asset.quantity,
            purchase_price_original: asset.purchasePrice,
            current_price_krw: asset.currentPrice,
            currency: asset.currency,
            current_value_krw: asset.currentPrice * asset.quantity,
        })));
    }, [assets]);

    const markdownComponents: Components = {
        table: ({...props}) => <table className="table-auto w-full my-4 text-sm border-collapse border border-gray-600" {...props} />,
        thead: ({...props}) => <thead className="bg-gray-700/50" {...props} />,
        th: ({...props}) => <th className="border border-gray-600 px-3 py-2 text-left font-semibold text-gray-200" {...props} />,
        td: ({...props}) => <td className="border border-gray-600 px-3 py-2" {...props} />,
        p: ({...props}) => <p className="mb-2 last:mb-0" {...props} />,
        ul: ({...props}) => <ul className="list-disc list-inside mb-2 pl-4" {...props} />,
        ol: ({...props}) => <ol className="list-decimal list-inside mb-2 pl-4" {...props} />,
        li: ({...props}) => <li className="mb-1" {...props} />,
        h3: ({...props}) => <h3 className="text-lg font-bold mt-4 mb-2 text-primary-light" {...props} />,
        strong: ({...props}) => <strong className="font-bold text-white" {...props} />,
        code: (props) => ((props as { inline?: boolean }).inline)
          ? <code className="bg-gray-900 text-yellow-300 px-1.5 py-1 rounded text-sm font-mono" {...props} />
          : <pre className="bg-gray-900 p-3 rounded-md overflow-x-auto my-2 text-sm"><code className="font-mono" {...props} /></pre>,
        img: ({...props}) => (
            <img 
                {...props} 
                className="max-w-full rounded my-2" 
                loading="lazy"
                alt={props.alt || '이미지'}
                onError={(e: React.SyntheticEvent<HTMLImageElement>) => {
                    (e.target as HTMLImageElement).style.display = 'none';
                }}
            />
        )
    };

    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-50" onClick={onClose}>
            <div className="bg-gray-800 rounded-lg shadow-xl w-full max-w-2xl h-[80vh] flex flex-col" onClick={(e) => e.stopPropagation()}>
                <header className="flex justify-between items-center p-4 border-b border-gray-700">
                    <div className="flex items-center gap-3">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-primary" viewBox="0 0 24 24" fill="currentColor">
                           <path d="M14 12c0 .552-.448 1-1 1s-1-.448-1-1 .448-1 1-1 1 .448 1 1zm-1-3.5c-2.481 0-4.5 2.019-4.5 4.5s2.019 4.5 4.5 4.5 4.5-2.019 4.5-4.5-2.019-4.5-4.5-4.5zm0-3.5c-4.411 0-8 3.589-8 8s3.589 8 8 8 8-3.589 8-8-3.589-8-8-8zm-5.5 8c0-3.033 2.468-5.5 5.5-5.5s5.5 2.467 5.5 5.5-2.468 5.5-5.5 5.5-5.5-2.467-5.5-5.5zm11.5 0c0 .828-.672 1.5-1.5 1.5s-1.5-.672-1.5-1.5.672-1.5 1.5-1.5 1.5.672 1.5 1.5z"/>
                        </svg>
                        <h2 className="text-xl font-bold text-white">포트폴리오 어시스턴트</h2>
                    </div>
                    <div className="flex items-center gap-2">
                        <button onClick={handleClearHistory} title="대화 기록 초기화" className="text-gray-400 hover:text-white transition p-2">
                           <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                              <path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                        </button>
                        <button onClick={onClose} title="닫기" className="text-gray-400 hover:text-white transition p-2">
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                    </div>
                </header>
                <main className="flex-1 p-4 overflow-y-auto space-y-4">
                    {messages.length === 0 && !isLoading ? (
                        <div className="text-center p-8">
                             <h3 className="text-lg font-semibold text-white mb-4">무엇을 도와드릴까요?</h3>
                             <p className="text-gray-400 mb-6">포트폴리오에 대해 궁금한 점을 질문해보세요.</p>
                             <div className="grid grid-cols-1 md:grid-cols-2 gap-3 text-left">
                                {examplePrompts.map(prompt => (
                                    <button 
                                        key={prompt}
                                        onClick={() => handleExampleClick(prompt)}
                                        className="bg-gray-700 hover:bg-gray-600 text-gray-300 p-3 rounded-lg text-sm transition text-left"
                                    >
                                        {prompt}
                                    </button>
                                ))}
                             </div>
                        </div>
                    ) : (
                        messages.map((msg, index) => (
                            <div key={index} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                                <div className={`max-w-xl lg:max-w-2xl px-4 py-3 rounded-lg ${msg.role === 'user' ? 'bg-primary text-white' : 'bg-gray-700 text-gray-200'}`}>
                                     {msg.role === 'model' ? (
                                        <ReactMarkdown 
                                            remarkPlugins={[remarkGfm]} 
                                            rehypePlugins={[rehypeRaw]}
                                            components={markdownComponents}
                                        >
                                            {msg.content}
                                        </ReactMarkdown>
                                    ) : (
                                        <p className="whitespace-pre-wrap">{msg.content}</p>
                                    )}
                                </div>
                            </div>
                        ))
                    )}
                     {isLoading && (
                        <div className="flex justify-start">
                            <div className="bg-gray-700 text-gray-200 px-4 py-3 rounded-lg">
                                <div className="flex items-center space-x-2">
                                    <span className="w-2 h-2 bg-gray-400 rounded-full animate-pulse [animation-delay:-0.3s]"></span>
                                    <span className="w-2 h-2 bg-gray-400 rounded-full animate-pulse [animation-delay:-0.15s]"></span>
                                    <span className="w-2 h-2 bg-gray-400 rounded-full animate-pulse"></span>
                                </div>
                            </div>
                        </div>
                    )}
                    <div ref={messagesEndRef} />
                </main>
                <footer className="p-4 border-t border-gray-700">
                    <div className="flex items-center bg-gray-700 rounded-lg">
                        <input
                            ref={inputRef}
                            type="text"
                            value={input}
                            onChange={(e) => setInput(e.target.value)}
                            onKeyDown={(e) => e.key === 'Enter' && handleSend()}
                            placeholder="포트폴리오에 대해 질문하세요..."
                            className="w-full bg-transparent p-3 text-white placeholder-gray-400 focus:outline-none"
                            disabled={isLoading}
                        />
                        <button onClick={handleSend} disabled={isLoading || !input.trim()} className="p-3 text-gray-400 hover:text-white disabled:text-gray-600 disabled:cursor-not-allowed transition">
                           <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 10l7-7m0 0l7 7m-7-7v18" transform="rotate(90 12 12)" />
                            </svg>
                        </button>
                    </div>
                </footer>
            </div>
        </div>
    );
};

export default PortfolioAssistant;
</file>

<file path="components/ProfitLossChart.tsx">
import React, { useMemo } from 'react';
import { Asset, PortfolioSnapshot } from '../types';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';

interface ProfitLossChartProps {
  history: PortfolioSnapshot[];
  assetsToDisplay: Asset[];
  title: string;
}

const ProfitLossChart: React.FC<ProfitLossChartProps> = ({ history, assetsToDisplay, title }) => {
  const chartData = useMemo(() => {
    if (!history || history.length === 0) {
      return [];
    }
    
    const assetIdsToDisplay = new Set(assetsToDisplay.map(a => a.id));

    const data = history.map(snapshot => {
      const dateEntry: Record<string, number | string> = {
        date: new Date(snapshot.date).toLocaleDateString('ko-KR', { month: '2-digit', day: '2-digit' }),
      };
      
      const relevantAssets = snapshot.assets.filter(asset => assetIdsToDisplay.has(asset.id));

      let totalPurchase = 0;
      let totalCurrent = 0;
      relevantAssets.forEach(asset => {
        totalPurchase += asset.purchaseValue;
        totalCurrent += asset.currentValue;
      });
      const totalProfitLoss = totalCurrent - totalPurchase;
      const totalReturn = totalPurchase === 0 ? 0 : (totalProfitLoss / totalPurchase) * 100;
      dateEntry['투자 원금'] = totalPurchase;
      dateEntry['총 평가액'] = totalCurrent;
      dateEntry['손익'] = totalProfitLoss;
      dateEntry['수익률'] = totalReturn;
      return dateEntry;
    });

    return data;
  }, [history, assetsToDisplay]);

  const formatCurrency = (value: number) => {
    return value.toLocaleString('ko-KR', { maximumFractionDigits: 0 });
  };
  const formatPercent = (value: number) => `${(Number(value) || 0).toFixed(2)}%`;
  
  const CustomTooltip = ({ active, payload, label }: { active?: boolean; payload?: Array<{ dataKey?: string; value?: number }>; label?: string }) => {
    if (!active || !payload || payload.length === 0) return null;
    const datum = (payload ?? []).reduce<Record<string, number>>((acc, p) => {
      const key = (p as any).dataKey as string;
      const val = (p as any).value as number;
      if (key) acc[key] = val;
      return acc;
    }, {});
    const principal = datum['투자 원금'];
    const total = datum['총 평가액'];
    const profit = datum['손익'];
    const returnPct = datum['수익률'];
    return (
      <div style={{ backgroundColor: '#2D3748', border: '1px solid #4A5568', borderRadius: '0.5rem', padding: '0.5rem 0.75rem' }}>
        <div style={{ color: '#E2E8F0', marginBottom: 4 }}>{label}</div>
        <div style={{ color: '#A0AEC0' }}>투자 원금: <span style={{ color: '#E2E8F0', fontWeight: 700 }}>{formatCurrency(principal)} 원</span></div>
        <div style={{ color: '#A0AEC0' }}>총 평가액: <span style={{ color: '#E2E8F0', fontWeight: 700 }}>{formatCurrency(total)} 원</span></div>
        <div style={{ color: '#A0AEC0' }}>손익: <span style={{ color: '#E2E8F0', fontWeight: 700 }}>{formatCurrency(profit)} 원</span></div>
        <div style={{ color: '#D69E2E' }}>수익률: <span style={{ color: '#F6E05E', fontWeight: 700 }}>{formatPercent(returnPct)}</span></div>
      </div>
    );
  };
  
  return (
    <div className="bg-gray-800 p-6 rounded-lg shadow-lg h-96 mb-6" title="포트폴리오의 평가 손익 추이를 보여줍니다.">
      <h2 className="text-xl font-bold text-white mb-4">{title}</h2>
      {chartData.length > 1 ? (
        <ResponsiveContainer width="100%" height="90%">
          <LineChart data={chartData} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
            <CartesianGrid strokeDasharray="3 3" stroke="#4A5568" />
            <XAxis dataKey="date" stroke="#A0AEC0" fontSize={12} />
            <YAxis yAxisId="left" stroke="#A0AEC0" fontSize={12} tickFormatter={formatCurrency} width={80} />
            <YAxis yAxisId="right" orientation="right" stroke="#D69E2E" fontSize={12} tickFormatter={formatPercent} width={60} />
            <Tooltip content={<CustomTooltip />} />
            <Legend wrapperStyle={{fontSize: "12px", bottom: -10}}/>
            <Line yAxisId="left" type="monotone" dataKey="투자 원금" name="투자 원금" stroke="#63B3ED" strokeWidth={3} dot={false} />
            <Line yAxisId="left" type="monotone" dataKey="총 평가액" name="총 평가액" stroke="#48BB78" strokeWidth={3} dot={false} />
            <Line yAxisId="left" type="monotone" dataKey="손익" name="손익" stroke="#FFFFFF" strokeWidth={2} dot={{ r: 3 }} activeDot={{ r: 6 }} />
            <Line yAxisId="right" type="monotone" dataKey="수익률" name="수익률(%)" stroke="#F6E05E" strokeWidth={2} dot={false} />
          </LineChart>
        </ResponsiveContainer>
      ) : (
        <div className="flex items-center justify-center h-full">
          <p className="text-gray-500">손익 추이를 표시하려면 데이터가 2일 이상 필요합니다.</p>
        </div>
      )}
    </div>
  );
};

export default ProfitLossChart;
</file>

<file path="components/SellAssetModal.tsx">
// components/SellAssetModal.tsx
// 수정된 버전: 매도 통화를 자산 통화로 고정

import React, { useState, useEffect } from 'react';
import { Asset, Currency, CURRENCY_SYMBOLS, SellTransaction } from '../types';
import { usePortfolio } from '../contexts/PortfolioContext';

const SellAssetModal: React.FC = () => {
  const { modal, actions, status } = usePortfolio();
  const asset = modal.sellingAsset;
  const isOpen = !!modal.sellingAsset;
  const onClose = actions.closeSellModal;
  const onSell = (assetId: string, sellDate: string, sellPrice: number, sellQuantity: number, currency: Currency) =>
    actions.confirmSell(assetId, sellDate, sellPrice, sellQuantity, currency);
  const isLoading = status.isLoading;
  const [sellDate, setSellDate] = useState<string>(new Date().toISOString().slice(0, 10));
  const [sellPrice, setSellPrice] = useState<string>('');
  const [sellQuantity, setSellQuantity] = useState<string>('');

  useEffect(() => {
    if (asset && isOpen) {
      setSellDate(new Date().toISOString().slice(0, 10));
      // 현재가를 자산 통화 기준으로 표시
      setSellPrice(asset.currentPrice.toString());
      setSellQuantity(asset.quantity.toString());
    }
  }, [asset, isOpen]);

  if (!isOpen || !asset) return null;

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!sellDate || !sellPrice || !sellQuantity) {
      alert('모든 필드를 입력해주세요.');
      return;
    }

    const quantity = parseFloat(sellQuantity);
    const price = parseFloat(sellPrice);

    if (quantity <= 0 || quantity > asset.quantity) {
      alert(`매도 수량은 0보다 크고 보유 수량(${asset.quantity}) 이하여야 합니다.`);
      return;
    }

    if (price <= 0) {
      alert('매도가는 0보다 커야 합니다.');
      return;
    }

    // 자산의 원래 통화로 매도 처리
    onSell(
      asset.id,
      sellDate,
      price,           // 자산 통화 기준 매도가
      quantity,
      asset.currency   // 자산의 통화
    );
  };

  const inputClasses = "w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition";
  const labelClasses = "block text-sm font-medium text-gray-300 mb-1";

  const formatCurrency = (num: number, currency: Currency): string => {
    if (currency === Currency.KRW) {
      return new Intl.NumberFormat('ko-KR', { 
        style: 'currency', 
        currency: 'KRW', 
        maximumFractionDigits: 0 
      }).format(num);
    }
    if (currency === Currency.JPY) {
      return `${CURRENCY_SYMBOLS[currency]}${new Intl.NumberFormat('ja-JP', { 
        maximumFractionDigits: 0 
      }).format(num)}`;
    }
    return `${CURRENCY_SYMBOLS[currency]}${new Intl.NumberFormat('en-US', { 
      minimumFractionDigits: 2,
      maximumFractionDigits: 2 
    }).format(num)}`;
  };

  const currencySymbol = CURRENCY_SYMBOLS[asset.currency];
  const currencyLabel = asset.currency;

  // 예상 매도금액 계산
  const estimatedTotal = parseFloat(sellPrice || '0') * parseFloat(sellQuantity || '0');

  return (
    <div 
      className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-50" 
      onClick={onClose} 
      role="dialog" 
      aria-modal="true"
    >
      <div 
        className="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-lg" 
        onClick={(e) => e.stopPropagation()}
      >
        <h2 className="text-2xl font-bold text-white mb-6">
          매도: {asset.customName?.trim() || asset.name}
        </h2>
        
        <form onSubmit={handleSubmit} className="space-y-4">
          {/* 보유 정보 */}
          <div className="bg-gray-700 p-4 rounded-md">
            <div className={labelClasses}>보유정보</div>
            <div className="grid grid-cols-3 gap-4 text-sm">
              <div>
                <div className="text-gray-400">보유 수량</div>
                <div className="text-white font-semibold">
                  {asset.quantity.toLocaleString()}
                </div>
              </div>
              <div>
                <div className="text-gray-400">현재가</div>
                <div className="text-white font-semibold">
                  {formatCurrency(asset.currentPrice, asset.currency)}
                </div>
              </div>
              <div>
                <div className="text-gray-400">평가금액</div>
                <div className="text-white font-semibold">
                  {formatCurrency(asset.currentPrice * asset.quantity, asset.currency)}
                </div>
              </div>
            </div>
          </div>

          {/* 통화 표시 (변경 불가) */}
          <div className="bg-gray-700/50 p-3 rounded-md">
            <div className="flex items-center justify-between">
              <span className="text-sm text-gray-400">매도 통화</span>
              <span className="text-white font-medium flex items-center gap-2">
                {asset.currency === Currency.USD && '🇺🇸'}
                {asset.currency === Currency.JPY && '🇯🇵'}
                {asset.currency === Currency.KRW && '🇰🇷'}
                {currencyLabel}
              </span>
            </div>
            <p className="text-xs text-gray-500 mt-1">
              * 매수 통화와 동일한 통화로만 매도할 수 있습니다.
            </p>
          </div>

          {/* 매도일자 */}
          <div>
            <label htmlFor="sellDate" className={labelClasses}>매도일자</label>
            <input
              id="sellDate"
              type="date"
              value={sellDate}
              onChange={(e) => setSellDate(e.target.value)}
              className={inputClasses}
              required
            />
          </div>

          {/* 매도가 */}
          <div>
            <label htmlFor="sellPrice" className={labelClasses}>
              매도가 ({currencySymbol})
            </label>
            <div className="relative">
              <span className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400">
                {currencySymbol}
              </span>
              <input
                id="sellPrice"
                type="number"
                value={sellPrice}
                onChange={(e) => setSellPrice(e.target.value)}
                className={`${inputClasses} pl-8`}
                required
                min="0"
                step="any"
                placeholder="매도가를 입력하세요"
              />
            </div>
          </div>

          {/* 매도 수량 */}
          <div>
            <label htmlFor="sellQuantity" className={labelClasses}>매도 수량</label>
            <input
              id="sellQuantity"
              type="number"
              value={sellQuantity}
              onChange={(e) => setSellQuantity(e.target.value)}
              className={inputClasses}
              required
              min="1"
              max={asset.quantity}
              step="any"
              placeholder="매도할 수량을 입력하세요"
            />
            <div className="flex justify-between mt-1">
              <button
                type="button"
                onClick={() => setSellQuantity(asset.quantity.toString())}
                className="text-xs text-primary hover:text-primary-light"
              >
                전량 매도
              </button>
              <span className="text-xs text-gray-500">
                최대: {asset.quantity.toLocaleString()}
              </span>
            </div>
          </div>

          {/* 예상 매도금액 */}
          {estimatedTotal > 0 && (
            <div className="bg-gray-900 p-4 rounded-md">
              <div className="flex justify-between items-center">
                <span className="text-gray-400">예상 매도금액</span>
                <span className="text-xl font-bold text-white">
                  {formatCurrency(estimatedTotal, asset.currency)}
                </span>
              </div>
            </div>
          )}

          {/* 버튼 */}
          <div className="pt-4 flex gap-3">
            <button
              type="button"
              onClick={onClose}
              className="flex-1 bg-gray-600 hover:bg-gray-500 text-white font-medium py-2.5 px-4 rounded-md transition duration-300"
            >
              취소
            </button>
            <button
              type="submit"
              disabled={isLoading}
              className="flex-1 bg-danger hover:bg-red-600 text-white font-bold py-2.5 px-4 rounded-md disabled:bg-gray-600 disabled:cursor-not-allowed transition duration-300 flex items-center justify-center"
            >
              {isLoading ? (
                <svg className="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
              ) : '매도 확인'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default SellAssetModal;
</file>

<file path="hooks/usePortfolioData.ts">
import { useState, useEffect, useCallback, useMemo } from 'react';
import { Asset, PortfolioSnapshot, SellRecord, WatchlistItem, ExchangeRates } from '../types';
import { useGoogleDriveSync } from './useGoogleDriveSync';
import { runMigrationIfNeeded } from '../utils/migrateData';
import { mapToNewAssetStructure } from '../utils/portfolioCalculations';

export const usePortfolioData = () => {
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  
  // 데이터 상태
  const [assets, setAssets] = useState<Asset[]>([]);
  const [portfolioHistory, setPortfolioHistory] = useState<PortfolioSnapshot[]>([]);
  const [sellHistory, setSellHistory] = useState<SellRecord[]>([]);
  const [watchlist, setWatchlist] = useState<WatchlistItem[]>([]);
  const [exchangeRates, setExchangeRates] = useState<ExchangeRates>({ USD: 1450, JPY: 9.5 });
  const [hasAutoUpdated, setHasAutoUpdated] = useState<boolean>(false);

  const { isSignedIn, googleUser, isInitializing, handleSignIn, handleSignOut: hookSignOut, loadFromGoogleDrive: hookLoadFromGoogleDrive, autoSave: hookAutoSave } = useGoogleDriveSync({ onError: setError, onSuccessMessage: setSuccessMessage });

  const loadFromGoogleDrive = useCallback(async () => {
    try {
      const loaded = await hookLoadFromGoogleDrive();
      if (loaded) {
        const data = runMigrationIfNeeded(loaded);
        const driveAssets = Array.isArray(data.assets) ? data.assets.map(mapToNewAssetStructure) : [];
        setAssets(driveAssets);
        
        if (Array.isArray(data.portfolioHistory)) setPortfolioHistory(data.portfolioHistory);
        else setPortfolioHistory([]);
        
        if (Array.isArray(data.sellHistory)) setSellHistory(data.sellHistory);
        else setSellHistory([]);
        
        if (Array.isArray(data.watchlist)) setWatchlist(data.watchlist);
        else setWatchlist([]);
        
        if (data.exchangeRates) {
          const rates = data.exchangeRates;
          if (!rates.USD || rates.USD < 100) rates.USD = 1450;
          if (!rates.JPY || rates.JPY < 1) rates.JPY = 9.5;
          setExchangeRates(rates);
        } else {
           setExchangeRates({ USD: 1450, JPY: 9.5 });
        }
        setSuccessMessage('Google Drive에서 포트폴리오를 불러왔습니다.');
        setTimeout(() => setSuccessMessage(null), 3000);
      } else {
        setAssets([]);
        setPortfolioHistory([]);
        setSellHistory([]);
        setWatchlist([]);
        setSuccessMessage('Google Drive에 저장된 포트폴리오가 없습니다. 자산을 추가해주세요.');
        setTimeout(() => setSuccessMessage(null), 3000);
      }
    } catch (error: unknown) {
      console.error('Failed to load from Google Drive:', error);
      const message = error instanceof Error ? error.message : '';
      setError(`Google Drive에서 데이터를 불러오지 못했습니다.${message ? ` (${message})` : ''}`);
      setTimeout(() => setError(null), 3000);
    }
  }, [hookLoadFromGoogleDrive]);

  // 초기 로드 Effect
  useEffect(() => {
    if (isInitializing) return;
    
    // isSignedIn이 true로 변경되었을 때만 로드하도록 의존성 관리
    // loadFromGoogleDrive를 의존성에서 제거하여 무한 루프 방지
    if (isSignedIn) {
      setHasAutoUpdated(false);
      loadFromGoogleDrive();
    } else {
      setAssets([]);
      setPortfolioHistory([]);
      setSellHistory([]);
      setWatchlist([]); // watchlist 초기화 추가
      setHasAutoUpdated(false);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isInitializing, isSignedIn]); // loadFromGoogleDrive 제거

  // 자동 저장 래퍼
  const triggerAutoSave = useCallback((
    newAssets: Asset[], 
    newHistory: PortfolioSnapshot[], 
    newSells: SellRecord[], 
    newWatchlist: WatchlistItem[], 
    newRates: ExchangeRates
  ) => {
    if (isSignedIn) {
      hookAutoSave(newAssets, newHistory, newSells, newWatchlist, newRates);
    }
  }, [isSignedIn, hookAutoSave]);

  const handleSignOut = useCallback(() => {
    hookSignOut();
    setAssets([]);
    setPortfolioHistory([]);
    setSellHistory([]);
    setWatchlist([]);
    setHasAutoUpdated(false);
  }, [hookSignOut]);

  // 데이터 수동 갱신 (파일 업로드 등에서 사용)
  const updateAllData = useCallback((
    newAssets: Asset[],
    newHistory: PortfolioSnapshot[],
    newSells: SellRecord[],
    newWatchlist: WatchlistItem[],
    newRates?: ExchangeRates
  ) => {
    setAssets(newAssets);
    setPortfolioHistory(newHistory);
    setSellHistory(newSells);
    setWatchlist(newWatchlist);
    if (newRates) setExchangeRates(newRates);
    
    // 상태 업데이트 후 자동 저장 트리거
    triggerAutoSave(newAssets, newHistory, newSells, newWatchlist, newRates || exchangeRates);
  }, [triggerAutoSave, exchangeRates]);

  return {
    // 상태
    assets, setAssets,
    portfolioHistory, setPortfolioHistory,
    sellHistory, setSellHistory,
    watchlist, setWatchlist,
    exchangeRates, setExchangeRates,
    isSignedIn, googleUser,
    isInitializing,
    isLoading: isInitializing, // Alias for legacy support
    error, setError,
    successMessage, setSuccessMessage,
    hasAutoUpdated, setHasAutoUpdated,
    
    // 액션
    handleSignIn,
    handleSignOut,
    loadFromGoogleDrive,
    triggerAutoSave,
    updateAllData, // 전체 데이터 교체용
    mapToNewAssetStructure // 외부에서 필요할 경우
  };
};
</file>

<file path="services/upbitService.ts">
// services/upbitService.ts

// Cloud Run 서버 URL (기존 STOCK_API_URL과 동일)
const UPBIT_PROXY_URL = 'https://asset-manager-887842923289.asia-northeast3.run.app/upbit';

export interface UpbitTicker {
  market: string;
  trade_price: number;
  prev_closing_price: number;
  signed_change_price: number;
  signed_change_rate: number;
  high_price?: number;
  low_price?: number;
}
type UpbitTickerResponse = Partial<UpbitTicker> & { error?: unknown };

// 심볼 변환 (BTC -> KRW-BTC)
export const toUpbitPair = (symbol: string): string => {
  const s = (symbol || '').trim().toUpperCase();
  if (!s) return '';
  if (s.startsWith('KRW-') || s.startsWith('BTC-') || s.startsWith('USDT-')) {
    return s;
  }
  return `KRW-${s.replace(/USDT$/, '')}`;
};

// 유효한 마켓 코드인지 확인
const isValidMarket = (market: string): boolean => {
  if (!market || market === 'KRW-' || market === 'BTC-' || market === 'USDT-') {
    return false;
  }
  const match = market.match(/^(KRW|BTC|USDT)-(.+)$/);
  return match !== null && match[2].length > 0;
};

// 배치 조회 (Cloud Run 프록시 사용)
export const fetchUpbitPricesBatch = async (symbols: string[]): Promise<Map<string, UpbitTicker>> => {
  const resultMap = new Map<string, UpbitTicker>();
  
  if (symbols.length === 0) return resultMap;

  // 유효한 심볼만 필터링
  const validSymbols = symbols
    .map(s => (s || '').trim().toUpperCase())
    .filter(s => s.length > 0);

  if (validSymbols.length === 0) {
    console.warn('[Upbit] 유효한 심볼이 없습니다');
    return resultMap;
  }

  console.log('[Upbit] Cloud Run 프록시 호출:', validSymbols);

  try {
    const res = await fetch(UPBIT_PROXY_URL, {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify({ symbols: validSymbols })
    });

    if (!res.ok) {
      const errorText = await res.text().catch(() => '');
      console.error(`[Upbit] 프록시 응답 에러: ${res.status}`, errorText);
      return resultMap;
    }

    const data = await res.json();
    console.log('[Upbit] 프록시 응답:', data);

    // 응답 데이터를 Map으로 변환
    Object.entries(data).forEach(([market, tickerData]: [string, UpbitTickerResponse]) => {
      if (tickerData && typeof tickerData === 'object' && !tickerData.error) {
        const ticker: UpbitTicker = {
          market: tickerData.market || market,
          trade_price: tickerData.trade_price || 0,
          prev_closing_price: tickerData.prev_closing_price || 0,
          signed_change_price: tickerData.signed_change_price || 0,
          signed_change_rate: tickerData.signed_change_rate || 0,
          high_price: tickerData.high_price,
          low_price: tickerData.low_price,
        };
        
        // 마켓 코드로 매핑 (KRW-BTC)
        resultMap.set(market, ticker);
        
        // 심볼로도 매핑 (BTC)
        if (market.startsWith('KRW-')) {
          resultMap.set(market.replace('KRW-', ''), ticker);
        }
        if (market.startsWith('BTC-')) {
          resultMap.set(market.replace('BTC-', ''), ticker);
        }
      }
    });

    console.log(`[Upbit] 조회 성공: ${resultMap.size}개 코인`);
    return resultMap;

  } catch (error) {
    console.error('[Upbit] 프록시 호출 에러:', error);
    return resultMap;
  }
};

// 단일 코인 조회
export const fetchUpbitPrice = async (symbol: string): Promise<UpbitTicker | null> => {
  const result = await fetchUpbitPricesBatch([symbol]);
  const ticker = result.get(symbol.toUpperCase()) || result.get(toUpbitPair(symbol));
  return ticker || null;
};
</file>

<file path="components/layouts/DashboardView.tsx">
import React, { useMemo, useCallback } from 'react';
import { Asset, AssetCategory, Currency, ALLOWED_CATEGORIES } from '../../types';
import StatCard from '../StatCard';
import ExchangeRateInput from '../ExchangeRateInput';
import ProfitLossChart from '../ProfitLossChart';
import AllocationChart from '../AllocationChart';
import CategorySummaryTable from '../CategorySummaryTable';
import TopBottomAssets from '../TopBottomAssets';
import RebalancingTable from '../RebalancingTable';
import { usePortfolio } from '../../contexts/PortfolioContext';

const DashboardView: React.FC = () => {
  const { data, ui, actions, status, derived } = usePortfolio();
  const assets = data.assets;
  const portfolioHistory = data.portfolioHistory;
  const exchangeRates = data.exchangeRates;
  const dashboardFilterCategory = ui.dashboardFilterCategory;
  const setDashboardFilterCategory = actions.setDashboardFilterCategory;
  const alertCount = derived.alertCount;
  const onAlertClick = () => {
    actions.setActiveTab('portfolio');
    actions.setFilterAlerts(true);
  };
  const onRatesChange = actions.setExchangeRates;
  const showExchangeRateWarning = status.showExchangeRateWarning;

  const getValueInKRW = useCallback((value: number, currency: Currency): number => {
    if (currency === Currency.KRW) return value;
    const rate = exchangeRates[currency] || 0;
    return value * rate;
  }, [exchangeRates]);

  const totalValue = useMemo(() => {
    return assets.reduce((acc, asset) => {
      const v = asset.currentPrice * asset.quantity;
      return acc + getValueInKRW(v, asset.currency);
    }, 0);
  }, [assets, getValueInKRW]);

  const categoryOptions = useMemo(() => {
    const extras = Array.from(new Set(assets.map(asset => asset.category))).filter(
      (cat) => !ALLOWED_CATEGORIES.includes(cat)
    );
    return [...ALLOWED_CATEGORIES, ...extras];
  }, [assets]);

  const dashboardFilteredAssets = useMemo(() => {
      if (dashboardFilterCategory === 'ALL') {
          return assets;
      }
      return assets.filter(asset => asset.category === dashboardFilterCategory);
  }, [assets, dashboardFilterCategory]);

  const dashboardTotalValue = useMemo(() => {
      return dashboardFilteredAssets.reduce((acc, asset) => {
        const v = asset.currentPrice * asset.quantity;
        return acc + getValueInKRW(v, asset.currency);
      }, 0);
  }, [dashboardFilteredAssets, getValueInKRW]);

  const dashboardTotalPurchaseValue = useMemo(() => {
      return dashboardFilteredAssets.reduce((acc, asset) => {
        const v = asset.purchasePrice * asset.quantity;
        return acc + getValueInKRW(v, asset.currency);
      }, 0);
  }, [dashboardFilteredAssets, getValueInKRW]);

  const dashboardTotalGainLoss = dashboardTotalValue - dashboardTotalPurchaseValue;
  const dashboardTotalReturn = dashboardTotalPurchaseValue === 0 ? 0 : (dashboardTotalGainLoss / dashboardTotalPurchaseValue) * 100;

  const soldAssetsStats = useMemo(() => {
    let totalSoldAmount = 0;
    let totalSoldPurchaseValue = 0;
    let totalSoldProfit = 0;
    let soldCount = 0;

    assets.forEach(asset => {
      if (asset.sellTransactions && asset.sellTransactions.length > 0) {
        asset.sellTransactions.forEach(transaction => {
          totalSoldAmount += transaction.sellPrice * transaction.sellQuantity;
          soldCount += 1;
          
          let purchaseValueForSold: number;
          if (asset.currency === Currency.KRW) {
            purchaseValueForSold = asset.purchasePrice * transaction.sellQuantity;
          } else if (asset.purchaseExchangeRate) {
            purchaseValueForSold = asset.purchasePrice * asset.purchaseExchangeRate * transaction.sellQuantity;
          } else if (asset.priceOriginal > 0) {
            const exchangeRate = asset.currentPrice / asset.priceOriginal;
            purchaseValueForSold = asset.purchasePrice * exchangeRate * transaction.sellQuantity;
          } else {
            purchaseValueForSold = asset.purchasePrice * transaction.sellQuantity;
          }
          totalSoldPurchaseValue += purchaseValueForSold;
        });
      }
    });

    totalSoldProfit = totalSoldAmount - totalSoldPurchaseValue;
    const soldReturn = totalSoldPurchaseValue === 0 ? 0 : (totalSoldProfit / totalSoldPurchaseValue) * 100;

    return {
      totalSoldAmount,
      totalSoldPurchaseValue,
      totalSoldProfit,
      soldReturn,
      soldCount,
    };
  }, [assets]);

  const profitLossChartTitle = useMemo(() => (
      dashboardFilterCategory === 'ALL'
      ? '손익 추이 분석'
      : `${dashboardFilterCategory} 손익 추이 분석`
  ), [dashboardFilterCategory]);

  const formatCurrencyKRW = (value: number) => {
    return value.toLocaleString('ko-KR', { 
        style: 'currency', 
        currency: 'KRW', 
        maximumFractionDigits: 0 
    });
  };

  return (
    <div className="space-y-6">
      <div className="bg-gray-800 p-4 rounded-lg shadow-lg flex items-center justify-between flex-wrap gap-4">
          <div className="flex items-center gap-4" title="대시보드에 표시될 자산의 종류를 선택합니다.">
              <label htmlFor="dashboard-filter" className="text-sm font-medium text-gray-300">
                  자산 구분 필터:
              </label>
              <div className="relative">
                  <select
                      id="dashboard-filter"
                      value={dashboardFilterCategory}
                      onChange={(e) => setDashboardFilterCategory(e.target.value as AssetCategory | 'ALL')}
                      className="bg-gray-700 border border-gray-600 rounded-md py-2 pl-3 pr-8 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent appearance-none"
                  >
                      <option value="ALL">전체 포트폴리오</option>
                      {categoryOptions.map((cat) => (
                          <option key={cat} value={cat}>{cat}</option>
                      ))}
                  </select>
                  <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-400">
                      <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                  </div>
              </div>
          </div>
          <ExchangeRateInput 
            rates={exchangeRates} 
            onRatesChange={onRatesChange} 
            showWarning={showExchangeRateWarning} 
          />
          <StatCard 
              title="매도 알림 발생" 
              value={`${alertCount}개`}
              tooltip="설정된 하락률 기준을 초과한 자산의 수입니다. 클릭하여 필터링된 목록을 확인하세요."
              onClick={onAlertClick}
              isAlert={alertCount > 0}
              size="small"
          />
      </div>
       <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6 mb-6">
        <StatCard title="총 자산 (원화)" value={formatCurrencyKRW(dashboardTotalValue)} tooltip="선택된 자산의 현재 평가금액 총합입니다." />
        <StatCard title="투자 원금" value={formatCurrencyKRW(dashboardTotalPurchaseValue)} tooltip="선택된 자산의 총 매수금액 합계입니다." />
        <StatCard title="총 손익 (원화)" value={formatCurrencyKRW(dashboardTotalGainLoss)} isProfit={dashboardTotalGainLoss >= 0} tooltip="총 평가금액에서 총 매수금액을 뺀 금액입니다."/>
        <StatCard title="총 수익률" value={`${dashboardTotalReturn.toFixed(2)}%`} isProfit={dashboardTotalReturn >= 0} tooltip="총 손익을 총 매수금액으로 나눈 백분율입니다."/>
      </div>
      {soldAssetsStats.soldCount > 0 && (
        <div className="bg-gray-800 p-6 rounded-lg shadow-lg mb-6">
          <h3 className="text-xl font-bold text-white mb-4">매도 통계</h3>
          <div className="grid grid-cols-2 sm:grid-cols-4 gap-4">
            <StatCard title="매도 횟수" value={soldAssetsStats.soldCount.toString()} tooltip="총 매도 거래 횟수입니다." size="small" />
            <StatCard title="매도 금액" value={formatCurrencyKRW(soldAssetsStats.totalSoldAmount)} tooltip="매도된 종목의 총 매도금액입니다." size="small" />
            <StatCard title="매도 수익" value={formatCurrencyKRW(soldAssetsStats.totalSoldProfit)} isProfit={soldAssetsStats.totalSoldProfit >= 0} tooltip="매도금액에서 매수금액을 뺀 수익입니다." size="small" />
            <StatCard title="매도 수익률" value={`${soldAssetsStats.soldReturn.toFixed(2)}%`} isProfit={soldAssetsStats.soldReturn >= 0} tooltip="매도 수익을 매수금액으로 나눈 백분율입니다." size="small" />
          </div>
        </div>
      )}
      <ProfitLossChart history={portfolioHistory} assetsToDisplay={dashboardFilteredAssets} title={profitLossChartTitle} />
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <div className="lg:col-span-1">
          <AllocationChart assets={assets} exchangeRates={exchangeRates} />
        </div>
        <div className="lg:col-span-1">
           <CategorySummaryTable 
            assets={assets} 
            totalPortfolioValue={totalValue} 
            exchangeRates={exchangeRates} 
           />
        </div>
      </div>
      <RebalancingTable assets={assets} exchangeRates={exchangeRates} />
      <TopBottomAssets assets={assets} />
    </div>
  );
};

export default DashboardView;
</file>

<file path="components/portfolio-table/usePortfolioData.ts">
import { useMemo, useState } from 'react';
import { Asset, ExchangeRates, ALLOWED_CATEGORIES, AssetCategory } from '../../types';
import { Currency } from '../../types';
import { getValueInKRW } from './utils';
import { EnrichedAsset, SortKey, SortDirection } from './types';

interface UsePortfolioDataProps {
  assets: Asset[];
  exchangeRates: ExchangeRates;
  filterAlerts: boolean;
  sellAlertDropRate: number;
  showFailedOnly: boolean;
  failedIds?: Set<string>;
}

export const usePortfolioData = ({
  assets,
  exchangeRates,
  filterAlerts,
  sellAlertDropRate,
  showFailedOnly,
  failedIds
}: UsePortfolioDataProps) => {
  const [sortConfig, setSortConfig] = useState<{ key: SortKey; direction: SortDirection } | null>(null);

  const totalValueKRW = useMemo(() => {
    return assets.reduce((sum, asset) => {
      const valueInOriginalCurrency = asset.currentPrice * asset.quantity;
      return sum + getValueInKRW(valueInOriginalCurrency, asset.currency, exchangeRates);
    }, 0);
  }, [assets, exchangeRates]);

  const categoryOptions = useMemo(() => {
    const extras = Array.from(new Set(assets.map(asset => asset.category))).filter(
      (cat) => !ALLOWED_CATEGORIES.includes(cat) && cat !== AssetCategory.FOREIGN_STOCK
    );
    return [...ALLOWED_CATEGORIES, ...extras];
  }, [assets]);

  const enrichedAndSortedAssets = useMemo(() => {
    let enriched: EnrichedAsset[] = assets.map(asset => {
      // 1. isKRWExchange: Check if exchange is Upbit or Bithumb
      const isKRWExchange = asset.exchange === 'Upbit' || asset.exchange === 'Bithumb';

      // 2. Calculate Current Price in KRW
      let currentPriceKRW: number;
      if (isKRWExchange) {
        // If Upbit/Bithumb, API returns KRW even if asset is set to USD
        currentPriceKRW = asset.currentPrice;
      } else {
        currentPriceKRW = getValueInKRW(asset.currentPrice, asset.currency, exchangeRates);
      }

      const currentValueKRW = currentPriceKRW * asset.quantity;
      const purchasePriceKRW = getValueInKRW(asset.purchasePrice, asset.currency, exchangeRates);
      const purchaseValueKRW = purchasePriceKRW * asset.quantity;
      const profitLossKRW = currentValueKRW - purchaseValueKRW;

      // Calculate Return Percentage using KRW values to ensure consistency
      const returnPercentage = purchaseValueKRW === 0 ? 0 : (profitLossKRW / purchaseValueKRW) * 100;

      // Raw values (kept for reference, though mixed currencies may exist)
      const currentValue = asset.currentPrice * asset.quantity;
      const purchaseValue = asset.purchasePrice * asset.quantity;
      const profitLoss = currentValue - purchaseValue;

      // 3. Calculate Yesterday Price in KRW
      const yesterdayPrice = asset.yesterdayPrice || 0;
      let yesterdayPriceKRW: number;

      if (isKRWExchange) {
        if (asset.currency === Currency.USD) {
          // Fix data mismatch: yesterdayPrice is in USD, convert to KRW
          yesterdayPriceKRW = yesterdayPrice * (exchangeRates.USD || 1);
        } else {
          // Currency is KRW, use as is
          yesterdayPriceKRW = yesterdayPrice;
        }
      } else {
        yesterdayPriceKRW = getValueInKRW(yesterdayPrice, asset.currency, exchangeRates);
      }

      // 4. Calculate Yesterday Change (Daily Return)
      const yesterdayChange = yesterdayPriceKRW > 0 
        ? ((currentPriceKRW - yesterdayPriceKRW) / yesterdayPriceKRW) * 100 
        : 0;
        
      const diffFromYesterday = yesterdayPriceKRW > 0 
        ? currentPriceKRW - yesterdayPriceKRW 
        : 0;

      const allocation = totalValueKRW === 0 ? 0 : (currentValueKRW / totalValueKRW) * 100;
      const dropFromHigh = asset.highestPrice === 0 ? 0 : ((asset.currentPrice - asset.highestPrice) / asset.highestPrice) * 100;
      const diffFromHigh = asset.currentPrice - asset.highestPrice;
      
      return {
        ...asset,
        metrics: {
          purchasePrice: asset.purchasePrice,
          currentPrice: asset.currentPrice,
          currentPriceKRW,
          purchasePriceKRW,
          purchaseValue, currentValue, purchaseValueKRW, currentValueKRW,
          returnPercentage, allocation, dropFromHigh, profitLoss, profitLossKRW,
          diffFromHigh, yesterdayChange, diffFromYesterday,
        }
      };
    });

    if (filterAlerts) {
      enriched = enriched.filter(asset => {
        const alertRate = asset.sellAlertDropRate ?? sellAlertDropRate;
        return asset.metrics.dropFromHigh <= -alertRate;
      });
    }

    if (showFailedOnly && failedIds && failedIds.size > 0) {
      enriched = enriched.filter(asset => failedIds.has(asset.id));
    }

    if (sortConfig !== null) {
      enriched.sort((a, b) => {
        const { key, direction } = sortConfig;
        let aValue: number | string, bValue: number | string;

        if (key === 'name') {
          aValue = (a.customName?.toLowerCase() || a.name.toLowerCase());
          bValue = (b.customName?.toLowerCase() || b.name.toLowerCase());
        } else if (key === 'purchaseDate') {
          aValue = a.purchaseDate; bValue = b.purchaseDate;
        } else if (key === 'quantity') {
          aValue = a.quantity; bValue = b.quantity;
        } else if (key === 'currentPrice') {
          aValue = a.metrics.currentPriceKRW;
          bValue = b.metrics.currentPriceKRW;
        } else if (key === 'purchasePrice') {
          aValue = a.metrics.purchasePriceKRW;
          bValue = b.metrics.purchasePriceKRW;
        } else if (key === 'currentValue') {
           aValue = a.metrics.currentValueKRW;
           bValue = b.metrics.currentValueKRW;
        } else if (key === 'purchaseValue') {
           aValue = a.metrics.purchaseValueKRW;
           bValue = b.metrics.purchaseValueKRW;
        } else {
          aValue = a.metrics[key as keyof typeof a.metrics];
          bValue = b.metrics[key as keyof typeof b.metrics];
        }

        if (aValue < bValue) return direction === 'ascending' ? -1 : 1;
        if (aValue > bValue) return direction === 'ascending' ? 1 : -1;
        return 0;
      });
    }

    return enriched;
  }, [assets, sortConfig, totalValueKRW, exchangeRates, filterAlerts, sellAlertDropRate, showFailedOnly, failedIds]);

  const requestSort = (key: SortKey) => {
    let direction: SortDirection = 'ascending';
    if (sortConfig && sortConfig.key === key && sortConfig.direction === 'ascending') {
      direction = 'descending';
    }
    setSortConfig({ key, direction });
  };
  
  const toggleReturnSort = () => {
    const s = sortConfig;
    if (!s || (s.key !== 'returnPercentage' && s.key !== 'profitLossKRW')) {
      setSortConfig({ key: 'returnPercentage', direction: 'descending' });
      return;
    }
    if (s.key === 'returnPercentage' && s.direction === 'descending') {
      setSortConfig({ key: 'returnPercentage', direction: 'ascending' });
      return;
    }
    if (s.key === 'returnPercentage' && s.direction === 'ascending') {
      setSortConfig({ key: 'profitLossKRW', direction: 'descending' });
      return;
    }
    if (s.key === 'profitLossKRW' && s.direction === 'descending') {
      setSortConfig({ key: 'profitLossKRW', direction: 'ascending' });
      return;
    }
    setSortConfig(null);
  };

  return {
    enrichedAndSortedAssets,
    sortConfig,
    requestSort,
    toggleReturnSort,
    categoryOptions,
    totalValueKRW
  };
};
</file>

<file path="components/WatchlistPage.tsx">
import React, { useMemo, useState, useEffect } from 'react';
import Toggle from './common/Toggle';
import { Filter, Trash2 } from 'lucide-react';
import { AssetCategory, Currency, CURRENCY_SYMBOLS, ALLOWED_CATEGORIES, WatchlistItem, inferCategoryFromExchange, normalizeExchange, SymbolSearchResult } from '../types';
import { searchSymbols } from '../services/geminiService';

interface WatchlistPageProps {
  watchlist: WatchlistItem[];
  onAdd: (item: Omit<WatchlistItem, 'id' | 'currentPrice' | 'priceOriginal' | 'currency' | 'yesterdayPrice' | 'highestPrice' | 'lastSignalAt' | 'lastSignalType'>) => void;
  onUpdate: (item: WatchlistItem) => void;
  onDelete: (id: string) => void;
  onToggleMonitoring: (id: string, enabled: boolean) => void;
  onRefreshAll: () => void;
  isLoading: boolean;
  onBulkDelete?: (ids: string[]) => void;
}

const WatchlistPage: React.FC<WatchlistPageProps> = ({ watchlist, onAdd, onUpdate, onDelete, onToggleMonitoring, onRefreshAll, isLoading, onBulkDelete }) => {
  const [filterCategory, setFilterCategory] = useState<AssetCategory | 'ALL'>('ALL');
  const [search, setSearch] = useState('');
  const [monitoringOnly, setMonitoringOnly] = useState(false);
  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());
  const [openFilterOptions, setOpenFilterOptions] = useState<boolean>(false);

  const [form, setForm] = useState<{ ticker: string; exchange: string; name: string; category: AssetCategory; buyZoneMin?: string; buyZoneMax?: string; dropFromHighThreshold?: string; notes?: string }>({
    ticker: '',
    exchange: 'KRX (코스피/코스닥)',
    name: '',
    category: AssetCategory.KOREAN_STOCK,
  });
  const [symbolQuery, setSymbolQuery] = useState('');
  const [symbolResults, setSymbolResults] = useState<SymbolSearchResult[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [isFocused, setIsFocused] = useState(false);

  const DEFAULT_SYMBOLS: SymbolSearchResult[] = [
    { ticker: '005930', name: '삼성전자', exchange: 'KRX (코스피/코스닥)' },
    { ticker: '005380', name: '현대자동차', exchange: 'KRX (코스피/코스닥)' },
    { ticker: '035420', name: 'NAVER', exchange: 'KRX (코스피/코스닥)' },
    { ticker: '035720', name: '카카오', exchange: 'KRX (코스피/코스닥)' },
    { ticker: 'AAPL', name: 'Apple Inc.', exchange: 'NASDAQ' },
    { ticker: 'TSLA', name: 'Tesla, Inc.', exchange: 'NASDAQ' },
    { ticker: 'GOOGL', name: 'Alphabet Inc.', exchange: 'NASDAQ' },
    { ticker: 'MSFT', name: 'Microsoft Corporation', exchange: 'NASDAQ' },
    { ticker: 'BTC', name: '비트코인', exchange: '주요 거래소 (종합)' },
    { ticker: 'ETH', name: '이더리움', exchange: '주요 거래소 (종합)' },
  ];

  const categoryOptions = useMemo(() => {
    const extras = Array.from(new Set(watchlist.map(w => w.category))).filter(cat => !ALLOWED_CATEGORIES.includes(cat));
    return [...ALLOWED_CATEGORIES, ...extras];
  }, [watchlist]);

  const filtered = useMemo(() => {
    return watchlist
      .filter(w => (filterCategory === 'ALL' ? true : w.category === filterCategory))
      .filter(w => (monitoringOnly ? w.monitoringEnabled : true))
      .filter(w => {
        if (!search) return true;
        const s = search.toLowerCase();
        return w.name.toLowerCase().includes(s) || w.ticker.toLowerCase().includes(s) || (w.notes || '').toLowerCase().includes(s);
      })
      .map(w => ({
        ...w,
        dropFromHigh: w.highestPrice && w.currentPrice ? ((w.currentPrice - w.highestPrice) / w.highestPrice) * 100 : 0,
        yesterdayChange: w.yesterdayPrice && w.currentPrice ? ((w.currentPrice - w.yesterdayPrice) / w.yesterdayPrice) * 100 : 0,
        inBuyZone: w.buyZoneMin !== undefined && w.buyZoneMax !== undefined && w.currentPrice !== undefined
          ? w.currentPrice >= w.buyZoneMin && w.currentPrice <= w.buyZoneMax
          : false,
      }));
  }, [watchlist, filterCategory, monitoringOnly, search]);

  useEffect(() => {
    if (symbolQuery.length < 2) {
      setSymbolResults([]);
      return;
    }
    const handler = setTimeout(async () => {
      setIsSearching(true);
      try {
        const results = await searchSymbols(symbolQuery);
        if (Array.isArray(results) && results.length > 0) {
          setSymbolResults(results);
        } else {
          const q = symbolQuery.toLowerCase();
          const local = DEFAULT_SYMBOLS.filter(r => r.name.toLowerCase().includes(q) || r.ticker.toLowerCase().includes(q)).slice(0, 10);
          setSymbolResults(local);
        }
      } catch {
        const q = symbolQuery.toLowerCase();
        const local = DEFAULT_SYMBOLS.filter(r => r.name.toLowerCase().includes(q) || r.ticker.toLowerCase().includes(q)).slice(0, 10);
        setSymbolResults(local);
      } finally {
        setIsSearching(false);
      }
    }, 300);
    return () => { clearTimeout(handler); };
  }, [symbolQuery]);

  useEffect(() => {
    setSelectedIds(prev => {
      const next = new Set<string>();
      filtered.forEach(w => {
        if (prev.has(w.id)) next.add(w.id);
      });
      return next;
    });
  }, [filtered]);

  const formatKRW = (num: number) => new Intl.NumberFormat('ko-KR', { style: 'currency', currency: 'KRW', maximumFractionDigits: 0 }).format(num);
  const formatOriginalCurrency = (num: number, currency: Currency) => `${CURRENCY_SYMBOLS[currency]}${new Intl.NumberFormat('en-US', { maximumFractionDigits: 2 }).format(num)}`;
  const getChangeColor = (value: number) => (value > 0 ? 'text-success' : value < 0 ? 'text-danger' : 'text-gray-400');
  const allSelected = filtered.length > 0 && filtered.every(w => selectedIds.has(w.id));
  const isEditMode = selectedIds.size === 1;

  useEffect(() => {
    if (!isEditMode) return;
    const selectedId = Array.from(selectedIds)[0];
    const selected = watchlist.find(w => w.id === selectedId);
    if (!selected) return;
    setForm({
      ticker: selected.ticker,
      exchange: selected.exchange,
      name: selected.name,
      category: selected.category,
      buyZoneMin: selected.buyZoneMin !== undefined ? String(selected.buyZoneMin) : undefined,
      buyZoneMax: selected.buyZoneMax !== undefined ? String(selected.buyZoneMax) : undefined,
      dropFromHighThreshold: selected.dropFromHighThreshold !== undefined ? String(selected.dropFromHighThreshold) : undefined,
      notes: selected.notes,
    });
    setSymbolQuery(selected.name);
  }, [isEditMode, selectedIds, watchlist]);

  return (
    <div className="space-y-6">
      <div className="bg-gray-800 p-4 rounded-lg shadow-lg flex items-center justify-between gap-4">
        <div className="flex items-center gap-4">
          <div className="relative">
            <input type="text" value={search} onChange={e => setSearch(e.target.value)} placeholder="이름/티커/메모 검색" className="bg-gray-700 border border-gray-600 rounded-md py-2 pl-10 pr-10 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary w-64" />
            <svg className="absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
          </div>
        </div>
        <div className="flex items-center gap-2">
          <button onClick={() => {
            if (filtered.length === 0) return;
            const ids = filtered.map(w => w.id);
            const next = new Set<string>(selectedIds);
            const selectAll = !(filtered.every(w => selectedIds.has(w.id)));
            if (selectAll) ids.forEach(id => next.add(id)); else ids.forEach(id => next.delete(id));
            setSelectedIds(next);
          }} className="border border-gray-600 text-gray-300 hover:bg-gray-700 hover:text-white font-medium py-2 px-3 rounded-md transition duration-300">
            {allSelected ? '전체 해제' : '전체 선택'}
          </button>
          <button onClick={() => {
            const ids = Array.from(selectedIds);
            if (ids.length === 0) return;
            if (onBulkDelete) onBulkDelete(ids); else ids.forEach(id => onDelete(id));
            setSelectedIds(new Set());
          }} disabled={selectedIds.size === 0} className="border border-gray-600 text-red-400 hover:bg-gray-700 font-medium py-2 px-4 rounded-md transition duration-300 disabled:text-gray-500 disabled:border-gray-700 disabled:cursor-not-allowed">
            선택 삭제
          </button>
          <button onClick={onRefreshAll} disabled={isLoading} className="bg-primary hover:bg-primary-dark text-white font-medium py-2 px-4 rounded-md transition duration-300 flex items-center disabled:bg-gray-600 disabled:cursor-not-allowed">
          {isLoading ? (
            <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
          ) : null}
          <span>{isLoading ? '업데이트 중...' : '가격 새로고침'}</span>
          </button>
          <div className="relative">
            <button
              onClick={() => setOpenFilterOptions(prev => !prev)}
              className="border border-gray-600 text-gray-300 hover:bg-gray-700 hover:text-white font-medium py-2 px-3 rounded-md transition duration-300 flex items-center gap-2"
              title="필터"
            >
              <Filter className="h-4 w-4" />
              <span className="hidden sm:inline">필터</span>
            </button>
            {openFilterOptions && (
              <div className="absolute right-0 mt-2 w-72 bg-gray-800 border border-gray-700 rounded-md shadow-lg z-20 p-3">
                <div className="space-y-3">
                  <div>
                    <div className="text-xs text-gray-400 mb-1">카테고리</div>
                    <div className="relative">
                      <select value={filterCategory} onChange={e => setFilterCategory(e.target.value as AssetCategory | 'ALL')} className="bg-gray-700 border border-gray-600 rounded-md py-2 pl-3 pr-8 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary appearance-none w-full">
                        <option value="ALL">전체</option>
                        {categoryOptions.map(cat => (
                          <option key={cat} value={cat}>{cat}</option>
                        ))}
                      </select>
                      <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-400">
                        <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                      </div>
                    </div>
                  </div>
                  <Toggle
                    label="모니터링 ON만"
                    checked={monitoringOnly}
                    onChange={(next) => setMonitoringOnly(next)}
                  />
                </div>
              </div>
            )}
          </div>
        </div>
      </div>

      <div className="bg-gray-800 p-4 rounded-lg shadow-lg">
        <h3 className="text-lg font-semibold text-white mb-3">{isEditMode ? '종목 수정' : '종목 추가'}</h3>
        <div className="mb-3">
          <div className="relative">
            <input 
              id="watchlist-symbol-search" 
              type="text" 
              value={symbolQuery} 
              onChange={(e) => setSymbolQuery(e.target.value)} 
              onFocus={() => setIsFocused(true)}
              onBlur={() => setTimeout(() => setIsFocused(false), 150)}
              placeholder="티커/종목 검색"
              className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm w-full"
              autoComplete="off"
            />
            {isSearching && (
              <div className="absolute top-2 right-3">
                <svg className="animate-spin h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
              </div>
            )}
            {isFocused && symbolResults.length > 0 && (
              <ul className="absolute z-10 w-full bg-gray-700 border border-gray-600 rounded-md mt-1 max-h-60 overflow-y-auto shadow-lg">
                {symbolResults.map((result) => (
                  <li 
                    key={`${result.ticker}-${result.exchange}`} 
                    onMouseDown={() => {
                      const ex = normalizeExchange(result.exchange);
                      const cat = inferCategoryFromExchange(ex);
                      setForm(prev => ({ ...prev, ticker: result.ticker, exchange: ex, name: result.name, category: cat }));
                      setSymbolQuery(`${result.name}`);
                      setSymbolResults([]);
                    }} 
                    className="px-3 py-2 cursor-pointer hover:bg-primary-dark transition-colors"
                  >
                    <div className="font-bold text-white">{result.name} ({result.ticker})</div>
                    <div className="text-sm text-gray-400">{result.exchange}</div>
                  </li>
                ))}
              </ul>
            )}
          </div>
        </div>
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3">
          <input className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm" placeholder="티커" value={form.ticker} onChange={e => setForm({ ...form, ticker: e.target.value })} />
          <input className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm" placeholder="거래소" value={form.exchange} onChange={e => setForm({ ...form, exchange: e.target.value })} />
          <input className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm" placeholder="이름" value={form.name} onChange={e => setForm({ ...form, name: e.target.value })} />
          <div className="relative">
            <select value={form.category} onChange={e => setForm({ ...form, category: e.target.value as AssetCategory })} className="bg-gray-700 border border-gray-600 rounded-md py-2 pl-3 pr-8 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary appearance-none w-full">
              {ALLOWED_CATEGORIES.map(cat => <option key={cat} value={cat}>{cat}</option>)}
            </select>
            <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-400">
              <svg className="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
            </div>
          </div>
          <input className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm" placeholder="매수존 하한(KRW)" value={form.buyZoneMin || ''} onChange={e => setForm({ ...form, buyZoneMin: e.target.value })} />
          <input className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm" placeholder="매수존 상한(KRW)" value={form.buyZoneMax || ''} onChange={e => setForm({ ...form, buyZoneMax: e.target.value })} />
          <input className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm" placeholder="최고가대비 하락%" value={form.dropFromHighThreshold || ''} onChange={e => setForm({ ...form, dropFromHighThreshold: e.target.value })} />
          <input className="bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm" placeholder="메모" value={form.notes || ''} onChange={e => setForm({ ...form, notes: e.target.value })} />
          <div className="sm:col-span-2 lg:col-span-4">
            <button
              onClick={() => {
                if (!form.ticker || !form.exchange || !form.name) return;
                if (selectedIds.size === 1) {
                  const selectedId = Array.from(selectedIds)[0];
                  const original = watchlist.find(w => w.id === selectedId);
                  if (!original) return;
                  const updated: WatchlistItem = {
                    ...original,
                    ticker: form.ticker,
                    exchange: form.exchange,
                    name: form.name,
                    category: form.category,
                    notes: form.notes,
                    buyZoneMin: form.buyZoneMin ? parseFloat(form.buyZoneMin) : undefined,
                    buyZoneMax: form.buyZoneMax ? parseFloat(form.buyZoneMax) : undefined,
                    dropFromHighThreshold: form.dropFromHighThreshold ? parseFloat(form.dropFromHighThreshold) : undefined,
                  };
                  onUpdate(updated);
                } else {
                  onAdd({
                    ticker: form.ticker,
                    exchange: form.exchange,
                    name: form.name,
                    category: form.category,
                    monitoringEnabled: true,
                    notes: form.notes,
                    buyZoneMin: form.buyZoneMin ? parseFloat(form.buyZoneMin) : undefined,
                    buyZoneMax: form.buyZoneMax ? parseFloat(form.buyZoneMax) : undefined,
                    dropFromHighThreshold: form.dropFromHighThreshold ? parseFloat(form.dropFromHighThreshold) : undefined,
                  });
                }
                setForm({ ticker: '', exchange: 'KRX (코스피/코스닥)', name: '', category: AssetCategory.KOREAN_STOCK });
                setSymbolQuery('');
                setSelectedIds(new Set());
              }}
              className="bg-primary hover:bg-primary-dark text-white font-medium py-2 px-4 rounded-md transition duration-300"
            >
              {selectedIds.size === 1 ? '수정' : '추가'}
            </button>
          </div>
        </div>
      </div>

      <div className="w-full px-0 sm:px-0">
        <table className="w-full text-sm text-left text-gray-400 table-auto">
          <thead className="text-xs text-gray-300 uppercase bg-gray-700 select-none sticky top-0 z-10">
            <tr>
              <th className="px-4 py-3 text-center">
                <input type="checkbox" checked={allSelected} onChange={() => {
                  const ids = filtered.map(w => w.id);
                  const next = new Set<string>(selectedIds);
                  const selectAll = !(filtered.every(w => selectedIds.has(w.id)));
                  if (selectAll) ids.forEach(id => next.add(id)); else ids.forEach(id => next.delete(id));
                  setSelectedIds(next);
                }} />
              </th>
              <th className="px-4 py-3">종목명</th>
              <th className="px-4 py-3 text-right">현재가</th>
              <th className="px-4 py-3 text-right">어제대비</th>
              <th className="px-4 py-3 text-right">최고가대비</th>
              <th className="px-4 py-3 text-center">매수존</th>
              <th className="px-4 py-3 text-center">신호</th>
              <th className="px-4 py-3 text-center">모니터링</th>
              <th className="px-4 py-3">메모</th>
              <th className="px-4 py-3 text-center">삭제</th>
            </tr>
          </thead>
          <tbody>
            {filtered.length > 0 ? filtered.map(w => {
              const isNonKRW = w.currency !== undefined && w.currency !== Currency.KRW;
              const signalBuyZone = w.inBuyZone;
              const signalDrop = w.dropFromHighThreshold !== undefined && (w.dropFromHigh || 0) <= -(w.dropFromHighThreshold || 0);
              const signalDailyDrop = (w.yesterdayChange || 0) < -2;
              const hasSignal = signalBuyZone || signalDrop || signalDailyDrop;
              return (
                <tr key={w.id} className={`border-b border-gray-700`}>
                  <td className="px-4 py-3 text-center">
                    <input type="checkbox" checked={selectedIds.has(w.id)} onChange={(e) => {
                      const next = new Set<string>(selectedIds);
                      if (e.target.checked) next.add(w.id); else next.delete(w.id);
                      setSelectedIds(next);
                    }} />
                  </td>
                  <td className="px-4 py-3">
                    <div className="flex flex-col">
                      <div className="font-bold text-white">{w.name}</div>
                      <div className="text-xs text-gray-500">{w.ticker} | {w.exchange} | {w.category}</div>
                    </div>
                  </td>
                  <td className="px-4 py-3 text-right">
                    {w.currentPrice !== undefined ? formatKRW(w.currentPrice) : '-'}
                    {isNonKRW && w.priceOriginal !== undefined && w.currency !== undefined && (
                      <div className="text-xs text-gray-500">{formatOriginalCurrency(w.priceOriginal, w.currency)}</div>
                    )}
                  </td>
                  <td className={`px-4 py-3 text-right ${getChangeColor(w.yesterdayChange || 0)}`}>{w.yesterdayChange !== undefined ? `${(w.yesterdayChange || 0).toFixed(2)}%` : '-'}</td>
                  <td className={`px-4 py-3 text-right ${getChangeColor(w.dropFromHigh || 0)}`}>{w.dropFromHigh !== undefined ? `${(w.dropFromHigh || 0).toFixed(2)}%` : '-'}</td>
                  <td className="px-4 py-3 text-center">
                    {w.buyZoneMin !== undefined && w.buyZoneMax !== undefined ? (
                      <span className="text-gray-200">{formatKRW(w.buyZoneMin)} ~ {formatKRW(w.buyZoneMax)}</span>
                    ) : '-'}
                  </td>
                  <td className="px-4 py-3 text-center">
                    {hasSignal ? (
                      <div className="flex justify-center gap-2">
                        {signalBuyZone && <span className="px-2 py-1 rounded bg-success/20 text-success text-xs">매수존</span>}
                        {signalDrop && <span className="px-2 py-1 rounded bg-blue-500/20 text-blue-400 text-xs">최고가대비</span>}
                        {signalDailyDrop && <span className="px-2 py-1 rounded bg-danger/20 text-danger text-xs">일중하락</span>}
                      </div>
                    ) : <span className="text-gray-500">-</span>}
                  </td>
                  <td className="px-4 py-3 text-center">
                    <label className="inline-flex items-center cursor-pointer">
                      <input type="checkbox" className="sr-only" checked={w.monitoringEnabled} onChange={() => onToggleMonitoring(w.id, !w.monitoringEnabled)} />
                      <span className={`w-10 h-6 ${w.monitoringEnabled ? 'bg-green-600' : 'bg-gray-600'} rounded-full relative inline-block`}>
                        <span className={`absolute left-1 top-1 w-4 h-4 rounded-full ${w.monitoringEnabled ? 'bg-green-500 translate-x-full' : 'bg-white'} transition-transform duration-300`}></span>
                      </span>
                    </label>
                  </td>
                  <td className="px-4 py-3">
                    <input
                      value={w.notes || ''}
                      onChange={e => onUpdate({ ...w, notes: e.target.value })}
                      className="w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white text-sm"
                      placeholder="메모"
                    />
                  </td>
                  <td className="px-4 py-3 text-center">
                    <button onClick={() => onDelete(w.id)} className="p-2 text-red-400 hover:text-red-300" title="삭제">
                      <Trash2 className="h-5 w-5" />
                    </button>
                  </td>
                </tr>
              );
            }) : (
              <tr>
                <td colSpan={10} className="text-center py-8 text-gray-500">관심 종목을 추가해주세요.</td>
              </tr>
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
};

export default WatchlistPage;
</file>

<file path="hooks/useMarketData.ts">
import { useCallback, useState } from 'react';
import { Asset, AssetCategory, Currency, ExchangeRates, PortfolioSnapshot, SellRecord, WatchlistItem } from '../types';
import { fetchBatchAssetPrices as fetchBatchAssetPricesNew, fetchAssetData as fetchAssetDataNew, fetchExchangeRate, fetchExchangeRateJPY } from '../services/priceService';
import { fetchCurrentExchangeRate } from '../services/geminiService';
import { fetchUpbitPricesBatch } from '../services/upbitService';

interface UseMarketDataProps {
  assets: Asset[];
  setAssets: React.Dispatch<React.SetStateAction<Asset[]>>;
  watchlist: WatchlistItem[];
  setWatchlist: React.Dispatch<React.SetStateAction<WatchlistItem[]>>;
  exchangeRates: ExchangeRates;
  setExchangeRates: React.Dispatch<React.SetStateAction<ExchangeRates>>;
  portfolioHistory: PortfolioSnapshot[];
  sellHistory: SellRecord[];
  triggerAutoSave: (assets: Asset[], history: PortfolioSnapshot[], sells: SellRecord[], watchlist: WatchlistItem[], rates: ExchangeRates) => void;
  setError: (msg: string | null) => void;
  setSuccessMessage: (msg: string | null) => void;
}

// category 인자 제거
const shouldUseUpbitAPI = (exchange: string): boolean => {
  const normalized = (exchange || '').toLowerCase().trim();
  
  // 업비트 API를 타야 하는 거래소 목록을 명시적으로 정의
  // '주요 거래소 (종합)'은 앱에서 암호화폐 기본 거래소로 사용하는 명칭임
  const upbitExchanges = ['upbit', 'bithumb', '주요 거래소 (종합)'];

  // 해당 거래소 이름이 포함되어 있거나 일치하는지 확인
  return upbitExchanges.some(ex => normalized.includes(ex));
};

export const useMarketData = ({
  assets,
  setAssets,
  watchlist,
  setWatchlist,
  exchangeRates,
  setExchangeRates,
  portfolioHistory,
  sellHistory,
  triggerAutoSave,
  setError,
  setSuccessMessage
}: UseMarketDataProps) => {
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [failedAssetIds, setFailedAssetIds] = useState<Set<string>>(new Set());

  // 환율 변경 핸들러
  const handleExchangeRatesChange = useCallback((newRates: ExchangeRates) => {
    setExchangeRates(newRates);
    triggerAutoSave(assets, portfolioHistory, sellHistory, watchlist, newRates);
  }, [assets, portfolioHistory, sellHistory, watchlist, triggerAutoSave, setExchangeRates]);

  // 전체 시세 갱신
  const handleRefreshAllPrices = useCallback(async (isAutoUpdate = false, isScheduled = false) => {
    if (assets.length === 0) return;
    
    setIsLoading(true);
    setError(null);
    setFailedAssetIds(new Set());
    
    if (isAutoUpdate || isScheduled) {
        setSuccessMessage('최신 종가 정보를 불러오는 중입니다...');
    } else {
        setSuccessMessage(null);
    }

    // 1. 환율 선 업데이트
    try {
        const [usdRate, jpyRate] = await Promise.all([
            fetchExchangeRate(),
            fetchExchangeRateJPY()
        ]);
        setExchangeRates(prev => ({
            ...prev,
            USD: usdRate > 1000 ? usdRate : prev.USD,
            JPY: jpyRate > 5 ? jpyRate : prev.JPY
        }));
    } catch (e) {
        console.warn("환율 업데이트 실패, 기존 값 사용", e);
    }

    // 2. 자산 분류 (현금 / 업비트 / 일반)
    const cashAssets = assets.filter(a => a.category === AssetCategory.CASH);
    const upbitAssets = assets.filter(a => 
      a.category !== AssetCategory.CASH && shouldUseUpbitAPI(a.exchange)
    );
    const generalAssets = assets.filter(a => 
      a.category !== AssetCategory.CASH && !shouldUseUpbitAPI(a.exchange)
    );

    console.log('[useMarketData] 자산 분류:', {
      cash: cashAssets.length,
      upbit: upbitAssets.map(a => a.ticker),
      general: generalAssets.map(a => a.ticker)
    });

    // 3. 현금 자산 업데이트 로직
    const cashPromises = cashAssets.map(asset => 
      (asset.currency === Currency.USD 
        ? fetchExchangeRate() 
        : asset.currency === Currency.JPY 
          ? fetchExchangeRateJPY() 
          : fetchCurrentExchangeRate(asset.currency, Currency.KRW)
      ).then(rate => ({
        id: asset.id,
        name: `현금 (${asset.currency})`,
        priceKRW: rate * asset.priceOriginal,
        priceOriginal: asset.priceOriginal,
        currency: asset.currency,
        pricePreviousClose: rate * asset.priceOriginal,
      }))
    );

    // 4. 일반 자산 업데이트 로직 (Cloud Run 서버)
    const assetsToFetch = generalAssets.map(a => ({
      ticker: a.ticker,
      exchange: a.exchange,
      id: a.id,
      category: a.category,
      currency: a.currency,
    }));

    // 5. 업비트 자산 업데이트 로직 (업비트 직접 호출)
    const upbitSymbols = upbitAssets.map(a => a.ticker);

    try {
      console.log('[useMarketData] 업비트 조회 심볼:', upbitSymbols);
      console.log('[useMarketData] Cloud Run 조회:', assetsToFetch.map(a => a.ticker));

      const [cashResults, batchPriceMap, upbitPriceMap] = await Promise.all([
        Promise.allSettled(cashPromises),
        assetsToFetch.length > 0 ? fetchBatchAssetPricesNew(assetsToFetch) : Promise.resolve(new Map()),
        upbitSymbols.length > 0 ? fetchUpbitPricesBatch(upbitSymbols) : Promise.resolve(new Map())
      ]);

      console.log('[useMarketData] 업비트 응답:', upbitPriceMap);

      const failedTickers: string[] = [];
      const failedIds: string[] = [];

      const updatedAssets = assets.map((asset) => {
        // 현금 처리
        if (asset.category === AssetCategory.CASH) {
          const cashIdx = cashAssets.findIndex(ca => ca.id === asset.id);
          const result = cashResults[cashIdx];
          
          if (result && result.status === 'fulfilled') {
            const data = result.value;
            return {
              ...asset,
              yesterdayPrice: data.pricePreviousClose,
              currentPrice: data.priceKRW,
              priceOriginal: data.priceOriginal,
              currency: data.currency as Currency,
              highestPrice: Math.max(asset.highestPrice, data.priceOriginal),
            };
          }
          failedTickers.push(asset.ticker);
          failedIds.push(asset.id);
          return asset;
        }

        // 업비트 자산 처리 (업비트 API 직접 호출 결과 사용)
        if (shouldUseUpbitAPI(asset.exchange)) {
          const tickerUpper = asset.ticker.toUpperCase();
          const upbitData = upbitPriceMap.get(tickerUpper) || 
                           upbitPriceMap.get(`KRW-${tickerUpper}`);
          
          if (upbitData) {
            const newCurrentPrice = upbitData.trade_price;
            const newYesterdayPrice = upbitData.prev_closing_price;
            
            console.log(`[Upbit] ${asset.ticker}: 현재가=${newCurrentPrice?.toLocaleString()}, 전일종가=${newYesterdayPrice?.toLocaleString()}`);
            
            return {
              ...asset,
              yesterdayPrice: newYesterdayPrice,
              currentPrice: newCurrentPrice,
              priceOriginal: newCurrentPrice, // 업비트는 KRW 기준
              currency: Currency.KRW, // 업비트는 항상 KRW
              highestPrice: Math.max(asset.highestPrice, newCurrentPrice),
            };
          }
          
          console.warn(`[Upbit] ${asset.ticker}: 가격 데이터 없음`);
          failedTickers.push(asset.ticker);
          failedIds.push(asset.id);
          return asset;
        }

        // 일반 자산 처리 (Cloud Run 서버 결과 사용)
        const priceData = batchPriceMap.get(asset.id);
        if (priceData && !priceData.isMocked) {
          const shouldKeepOriginalCurrency = asset.category === AssetCategory.CRYPTOCURRENCY;
          const newCurrency = shouldKeepOriginalCurrency ? asset.currency : (priceData.currency as Currency);
          
          let newCurrentPrice = asset.currency === Currency.KRW 
            ? priceData.priceKRW 
            : priceData.priceOriginal;
          if (asset.category === AssetCategory.CRYPTOCURRENCY && asset.currency === Currency.KRW) {
            const usdRate = exchangeRates.USD || 0;
            if (usdRate > 0) {
              newCurrentPrice = priceData.priceOriginal * usdRate;
            }
          }
          
          // KRW 단위 오류 보정
          let newYesterdayPrice = priceData.pricePreviousClose;
          if (asset.currency === Currency.KRW && newYesterdayPrice > 0) {
             const ratio = newCurrentPrice / newYesterdayPrice;
             if (ratio > 50 || ratio < 0.02) {
                 const impliedRate = priceData.priceOriginal > 0 ? (priceData.priceKRW / priceData.priceOriginal) : 1450;
                 if (ratio > 50) {
                    newYesterdayPrice = newYesterdayPrice * impliedRate;
                 }
             }
          }

          return {
            ...asset,
            yesterdayPrice: newYesterdayPrice,
            currentPrice: newCurrentPrice,
            currency: newCurrency,
            highestPrice: Math.max(asset.highestPrice, newCurrentPrice),
          };
        } else {
          failedTickers.push(asset.ticker);
          failedIds.push(asset.id);
          return asset;
        }
      });

      setAssets(updatedAssets);
      setFailedAssetIds(new Set(failedIds));

      const successCount = assets.length - failedIds.length;
      const failedCount = failedIds.length;

      if (failedTickers.length > 0) {
        setError(`실패 종목: ${failedTickers.join(', ')}`);
        setTimeout(() => setError(null), 5000);
      }

      setSuccessMessage(`${successCount}건 성공, ${failedCount}건 실패`);
      setTimeout(() => setSuccessMessage(null), 5000);
      
      triggerAutoSave(updatedAssets, portfolioHistory, sellHistory, watchlist, exchangeRates);

    } catch (error) {
      console.error('Price refresh failed:', error);
      setError('가격 업데이트 중 오류가 발생했습니다.');
      setTimeout(() => setError(null), 3000);
    }

    setIsLoading(false);
  }, [assets, portfolioHistory, sellHistory, watchlist, exchangeRates, triggerAutoSave, setAssets, setExchangeRates, setError, setSuccessMessage]);

  // 선택 자산 갱신
  const handleRefreshSelectedPrices = useCallback(async (ids: string[]) => {
    if (ids.length === 0) return;
    
    setIsLoading(true);
    setError(null);

    const idSet = new Set(ids);
    const targetAssets = assets.filter(a => idSet.has(a.id));
    
    const cashAssets = targetAssets.filter(a => a.category === AssetCategory.CASH);
    const upbitAssets = targetAssets.filter(a => 
      a.category !== AssetCategory.CASH && shouldUseUpbitAPI(a.exchange)
    );
    const generalAssets = targetAssets.filter(a => 
      a.category !== AssetCategory.CASH && !shouldUseUpbitAPI(a.exchange)
    );
    
    const cashPromises = cashAssets.map(asset => 
      (asset.currency === Currency.USD 
        ? fetchExchangeRate() 
        : asset.currency === Currency.JPY 
          ? fetchExchangeRateJPY() 
          : fetchCurrentExchangeRate(asset.currency, Currency.KRW)
      ).then(rate => ({
        id: asset.id, 
        priceKRW: rate * asset.priceOriginal, 
        priceOriginal: asset.priceOriginal, 
        currency: asset.currency, 
        pricePreviousClose: rate * asset.priceOriginal
      }))
    );

    const itemsToFetch = generalAssets.map(a => ({ 
      ticker: a.ticker, 
      exchange: a.exchange, 
      id: a.id,
      category: a.category,
      currency: a.currency,
    }));

    const upbitSymbols = upbitAssets.map(a => a.ticker);

    try {
      const [cashResults, batchPriceMap, upbitPriceMap] = await Promise.all([
        Promise.allSettled(cashPromises),
        itemsToFetch.length > 0 ? fetchBatchAssetPricesNew(itemsToFetch) : Promise.resolve(new Map()),
        upbitSymbols.length > 0 ? fetchUpbitPricesBatch(upbitSymbols) : Promise.resolve(new Map())
      ]);

      const updatedAssets = assets.map((asset) => {
          if (!idSet.has(asset.id)) return asset;

          if (asset.category === AssetCategory.CASH) {
            const cashIdx = cashAssets.findIndex(ca => ca.id === asset.id);
            const result = cashResults[cashIdx];
            if (result && result.status === 'fulfilled') {
                const data = result.value;
                return { 
                  ...asset, 
                  yesterdayPrice: data.pricePreviousClose, 
                  currentPrice: data.priceKRW, 
                  priceOriginal: data.priceOriginal, 
                  currency: data.currency as Currency, 
                  highestPrice: Math.max(asset.highestPrice, data.priceOriginal) 
                };
            }
            return asset;
          }

          // 업비트 자산 처리
          if (shouldUseUpbitAPI(asset.exchange)) {
            const tickerUpper = asset.ticker.toUpperCase();
            const upbitData = upbitPriceMap.get(tickerUpper) || 
                             upbitPriceMap.get(`KRW-${tickerUpper}`);
            
            if (upbitData) {
              return {
                ...asset,
                yesterdayPrice: upbitData.prev_closing_price,
                currentPrice: upbitData.trade_price,
                priceOriginal: upbitData.trade_price,
                currency: Currency.KRW,
                highestPrice: Math.max(asset.highestPrice, upbitData.trade_price),
              };
            }
            return asset;
          }

          const priceData = batchPriceMap.get(asset.id);
          if (priceData && !priceData.isMocked) {
            const shouldKeepOriginalCurrency = asset.category === AssetCategory.CRYPTOCURRENCY;
            const newCurrency = shouldKeepOriginalCurrency ? asset.currency : (priceData.currency as Currency);
            
            let newCurrentPrice = asset.currency === Currency.KRW ? priceData.priceKRW : priceData.priceOriginal;
            if (asset.category === AssetCategory.CRYPTOCURRENCY && asset.currency === Currency.KRW) {
              const usdRate = exchangeRates.USD || 0;
              if (usdRate > 0) {
                newCurrentPrice = priceData.priceOriginal * usdRate;
              }
            }
            
            let newYesterdayPrice = priceData.pricePreviousClose;
            if (asset.currency === Currency.KRW && newYesterdayPrice > 0) {
                  const ratio = newCurrentPrice / newYesterdayPrice;
                  if (ratio > 50 || ratio < 0.02) {
                      const impliedRate = priceData.priceOriginal > 0 ? (priceData.priceKRW / priceData.priceOriginal) : 1450;
                      if (ratio > 50) newYesterdayPrice = newYesterdayPrice * impliedRate;
                  }
            }

            return { 
              ...asset, 
              yesterdayPrice: newYesterdayPrice, 
              currentPrice: newCurrentPrice, 
              currency: newCurrency, 
              highestPrice: Math.max(asset.highestPrice, newCurrentPrice) 
            };
          }
          return asset;
      });

      setAssets(updatedAssets);
      setSuccessMessage('선택한 자산 업데이트 완료'); 
      setTimeout(() => setSuccessMessage(null), 3000);
      
      triggerAutoSave(updatedAssets, portfolioHistory, sellHistory, watchlist, exchangeRates);
    } catch (error) { 
      console.error('Selected update failed:', error);
      setError('선택한 항목 업데이트 중 오류가 발생했습니다.'); 
      setTimeout(() => setError(null), 3000); 
    } finally {
      setIsLoading(false);
    }
  }, [assets, portfolioHistory, sellHistory, watchlist, exchangeRates, triggerAutoSave, setAssets, setError, setSuccessMessage]);

  // 단일 자산 갱신
  const handleRefreshOnePrice = useCallback(async (assetId: string) => {
    const target = assets.find(a => a.id === assetId);
    if (!target) return;
    setIsLoading(true);
    setError(null);

    try {
      // 업비트 자산인 경우 업비트 API 직접 호출
      if (shouldUseUpbitAPI(target.exchange)) {
        console.log(`[useMarketData] 단일 조회 (업비트): ${target.ticker}`);
        const upbitPriceMap = await fetchUpbitPricesBatch([target.ticker]);
        const tickerUpper = target.ticker.toUpperCase();
        const upbitData = upbitPriceMap.get(tickerUpper) || 
                         upbitPriceMap.get(`KRW-${tickerUpper}`);
        
        if (upbitData) {
          const updated = assets.map(a => a.id === assetId ? {
            ...a,
            yesterdayPrice: upbitData.prev_closing_price,
            currentPrice: upbitData.trade_price,
            priceOriginal: upbitData.trade_price,
            currency: Currency.KRW,
            highestPrice: Math.max(a.highestPrice, upbitData.trade_price),
          } : a);
          setAssets(updated);
          triggerAutoSave(updated, portfolioHistory, sellHistory, watchlist, exchangeRates);
          setSuccessMessage('가격 업데이트 완료');
          setTimeout(() => setSuccessMessage(null), 2000);
        } else {
          throw new Error('업비트 가격 조회 실패');
        }
      } else {
        // 일반 자산은 기존 로직 사용
        console.log(`[useMarketData] 단일 조회 (Cloud Run): ${target.ticker}`);
        const d = await fetchAssetDataNew({ ticker: target.ticker, exchange: target.exchange, category: target.category, currency: target.currency });
        
        const shouldKeepOriginalCurrency = target.category === AssetCategory.CRYPTOCURRENCY;
        const newCurrency = shouldKeepOriginalCurrency ? target.currency : (d.currency as Currency);
        
        let newCurrentPrice = target.currency === Currency.KRW 
          ? d.priceKRW 
          : d.priceOriginal;
        if (target.category === AssetCategory.CRYPTOCURRENCY && target.currency === Currency.KRW) {
          const usdRate = exchangeRates.USD || 0;
          if (usdRate > 0) {
            newCurrentPrice = d.priceOriginal * usdRate;
          }
        }
        
        const updated = assets.map(a => a.id === assetId ? {
          ...a,
          yesterdayPrice: d.pricePreviousClose,
          currentPrice: newCurrentPrice,
          currency: newCurrency,
          highestPrice: Math.max(a.highestPrice, newCurrentPrice),
        } : a);
        setAssets(updated);
        triggerAutoSave(updated, portfolioHistory, sellHistory, watchlist, exchangeRates);
        setSuccessMessage('가격 업데이트 완료');
        setTimeout(() => setSuccessMessage(null), 2000);
      }
    } catch (e) {
      console.error('Single asset refresh failed:', e);
      setError('해당 종목 가격 갱신에 실패했습니다.');
      setTimeout(() => setError(null), 3000);
    } finally {
      setIsLoading(false);
    }
  }, [assets, portfolioHistory, sellHistory, watchlist, exchangeRates, triggerAutoSave, setAssets, setError, setSuccessMessage]);

  // 관심종목 가격 갱신
  const handleRefreshWatchlistPrices = useCallback(async () => {
    if (watchlist.length === 0) return;
    setIsLoading(true);
    setError(null);

    // 업비트 자산과 일반 자산 분리
    const upbitItems = watchlist.filter(item => shouldUseUpbitAPI(item.exchange));
    const generalItems = watchlist.filter(item => !shouldUseUpbitAPI(item.exchange));
    const itemsToFetch = generalItems.map(item => ({
      ticker: item.ticker,
      exchange: item.exchange,
      id: item.id,
      category: item.category,
      currency: item.currency,
    }));

    const upbitSymbols = upbitItems.map(item => item.ticker);

    try {
      const [priceMap, upbitPriceMap] = await Promise.all([
        itemsToFetch.length > 0 ? fetchBatchAssetPricesNew(itemsToFetch) : Promise.resolve(new Map()),
        upbitSymbols.length > 0 ? fetchUpbitPricesBatch(upbitSymbols) : Promise.resolve(new Map())
      ]);

      const updated = watchlist.map((item) => {
        // 업비트 자산 처리
        if (shouldUseUpbitAPI(item.exchange)) {
          const tickerUpper = item.ticker.toUpperCase();
          const upbitData = upbitPriceMap.get(tickerUpper) || 
                           upbitPriceMap.get(`KRW-${tickerUpper}`);
          
          if (upbitData) {
            const highestPrice = item.highestPrice ? Math.max(item.highestPrice, upbitData.trade_price) : upbitData.trade_price;
            return {
              ...item,
              currentPrice: upbitData.trade_price,
              priceOriginal: upbitData.trade_price,
              currency: Currency.KRW,
              yesterdayPrice: upbitData.prev_closing_price,
              highestPrice,
            };
          }
          return item;
        }

        // 일반 자산 처리
        const d = priceMap.get(item.id);
        if (d && !d.isMocked) {
          const newCurrency = item.currency || (d.currency as Currency);
          const newCurrentPrice = item.currency === Currency.KRW 
            ? d.priceKRW 
            : d.priceOriginal;
          const highestPrice = item.highestPrice ? Math.max(item.highestPrice, newCurrentPrice) : newCurrentPrice;
          return {
            ...item,
            currentPrice: newCurrentPrice,
            priceOriginal: d.priceOriginal,
            currency: newCurrency,
            yesterdayPrice: d.pricePreviousClose,
            highestPrice,
          };
        }
        return item;
      });

      setWatchlist(updated);
      triggerAutoSave(assets, portfolioHistory, sellHistory, updated, exchangeRates);
      setSuccessMessage('관심종목 업데이트 완료');
      setTimeout(() => setSuccessMessage(null), 2000);
    } catch (error) {
      console.error('Watchlist refresh failed:', error);
      setError('관심종목 업데이트 중 오류가 발생했습니다.');
      setTimeout(() => setError(null), 3000);
    } finally {
      setIsLoading(false);
    }
  }, [watchlist, assets, portfolioHistory, sellHistory, exchangeRates, triggerAutoSave, setWatchlist, setError, setSuccessMessage]);

  return {
    isLoading,
    failedAssetIds,
    handleExchangeRatesChange,
    handleRefreshAllPrices,
    handleRefreshSelectedPrices,
    handleRefreshOnePrice,
    handleRefreshWatchlistPrices
  };
};
</file>

<file path="utils/migrateData.ts">
// utils/migrateData.ts
// 기존 DB 데이터를 새 구조로 변환하는 마이그레이션 스크립트

import { Currency, AssetCategory, ExchangeRates, LegacyAssetShape, PortfolioSnapshot, SellRecord, WatchlistItem } from '../types';

/**
 * 마이그레이션 실행
 * 
 * 핵심 변경:
 * 1. 암호화폐: purchasePrice가 원화로 입력된 경우 currency를 KRW로 복구
 * 2. USD/JPY 자산: currentPrice가 원화로 저장된 경우 priceOriginal로 교체
 */
export const runMigrationIfNeeded = (data: { exchangeRates?: ExchangeRates; assets?: LegacyAssetShape[]; portfolioHistory?: PortfolioSnapshot[]; sellHistory?: SellRecord[]; watchlist?: WatchlistItem[] } | null | undefined) => {
  if (!data || typeof data !== 'object') return data;
  
  // 환율 초기화
  if (!data.exchangeRates) {
    data.exchangeRates = { USD: 0, JPY: 0 };
  }
  
  // 자산 마이그레이션
  if (Array.isArray(data.assets)) {
    console.log('[Migration] 데이터 마이그레이션 시작...');
    let fixedCount = 0;
    
    data.assets = data.assets.map((asset: LegacyAssetShape) => {
      const ticker = asset.ticker || '?';
      const category = asset.category || '';
      const currency: string | Currency = asset.currency || 'KRW';
      const purchasePrice = asset.purchasePrice || 0;
      const currentPrice = asset.currentPrice || 0;
      const priceOriginal = asset.priceOriginal || 0;
      
      // ✅ 암호화폐 특별 처리
      if (category === '암호화폐' || category === AssetCategory.CRYPTOCURRENCY) {
        // USD로 설정되어 있지만 purchasePrice가 원화 수준인 경우
        if (currency === 'USD' || currency === Currency.USD) {
          // BTC: purchasePrice가 1억 이상이면 원화
          // ETH: purchasePrice가 100만 이상이면 원화
          // 기타: purchasePrice가 1000 이상이고 currentPrice가 1000 미만이면 원화
          const isKRWPurchase = 
            (purchasePrice > 100000000) ||  // 1억 이상 (BTC급)
            (purchasePrice > 1000000 && currentPrice < 10000) ||  // 100만 이상, 현재가 1만 미만 (ETH급)
            (purchasePrice > 1000 && currentPrice < 1000);  // 1000 이상, 현재가 1000 미만 (일반)
          
          if (isKRWPurchase) {
            console.log(`[Migration] ${ticker}: 암호화폐 KRW 복구`);
            console.log(`  - purchasePrice: ${purchasePrice.toLocaleString()} (KRW)`);
            console.log(`  - currency: USD → KRW`);
            fixedCount++;
            
            return {
              ...asset,
              currency: Currency.KRW,
            };
          }
        }
      }
      
      // ✅ USD/JPY 자산: currentPrice가 원화로 저장된 경우 복구
      if (currency === 'USD' || currency === 'JPY' || 
          currency === Currency.USD || currency === Currency.JPY) {
        
        if (priceOriginal > 0 && currentPrice > 0) {
          const ratio = currentPrice / priceOriginal;
          
          // currentPrice가 priceOriginal보다 100배 이상 크면 원화로 저장된 것
          if (ratio > 100) {
            console.log(`[Migration] ${ticker}: 가격 복구 (원화→원래통화)`);
            console.log(`  - currentPrice: ${currentPrice.toLocaleString()} → ${priceOriginal}`);
            fixedCount++;
            
            // 최고가도 복구
            let newHighestPrice = priceOriginal;
            if (asset.highestPrice > 0) {
              newHighestPrice = asset.highestPrice / ratio;
              if (newHighestPrice < priceOriginal) {
                newHighestPrice = priceOriginal;
              }
            }
            
            return {
              ...asset,
              currentPrice: priceOriginal,
              highestPrice: newHighestPrice,
            };
          }
        }
      }
      
      return asset;
    });
    
    console.log(`[Migration] 완료! ${fixedCount}개 자산 수정됨`);
  }
  
  return data;
};
</file>

<file path="components/AddNewAssetModal.tsx">
import React, { useState, useEffect, useCallback } from 'react';
import { Asset, AssetCategory, NewAssetForm, EXCHANGE_MAP, Currency, SymbolSearchResult, ALL_EXCHANGES, inferCategoryFromExchange, ALLOWED_CATEGORIES, normalizeExchange } from '../types';
import { searchSymbols } from '../services/geminiService';
import { usePortfolio } from '../contexts/PortfolioContext';

const AddNewAssetModal: React.FC = () => {
  const { modal, actions, status, data } = usePortfolio();
  const isOpen = modal.addAssetOpen;
  const onClose = actions.closeAddAsset;
  const onAddAsset = actions.addAsset as unknown as (asset: NewAssetForm) => void;
  const isLoading = status.isLoading;
  const assets = data.assets;
  const [ticker, setTicker] = useState('');
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<SymbolSearchResult[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [isFocused, setIsFocused] = useState(false);
  const [duplicateError, setDuplicateError] = useState<string | null>(null);
  
  const [quantity, setQuantity] = useState('');
  const [purchasePrice, setPurchasePrice] = useState('');
  const [purchaseDate, setPurchaseDate] = useState(new Date().toISOString().slice(0, 10));
  const [category, setCategory] = useState<AssetCategory>(AssetCategory.US_STOCK);
  const initialExchange = EXCHANGE_MAP[AssetCategory.US_STOCK]?.[0] || ALL_EXCHANGES[0] || '';
  const [exchange, setExchange] = useState<string>(initialExchange);
  const [currency, setCurrency] = useState<Currency>(Currency.USD);

  const clearForm = useCallback(() => {
    setTicker('');
    setSearchQuery('');
    setQuantity('');
    setPurchasePrice('');
    setSearchResults([]);
    setCategory(AssetCategory.US_STOCK);
    setExchange(initialExchange);
    setPurchaseDate(new Date().toISOString().slice(0, 10));
    setCurrency(Currency.USD);
    setDuplicateError(null);
  }, [initialExchange]);

  useEffect(() => {
    if (!isOpen) {
      clearForm();
    }
  }, [isOpen, clearForm]);


  const handleSearchChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const newQuery = e.target.value;
    setSearchQuery(newQuery);
    if (ticker) {
      setTicker('');
    }
    setDuplicateError(null);
  }, [ticker]);

  useEffect(() => {
    if (searchQuery.length < 2 || searchQuery === ticker) {
      setSearchResults([]);
      return;
    }

    const handler = setTimeout(async () => {
      setIsSearching(true);
      try {
        const results = await searchSymbols(searchQuery);
        setSearchResults(results);
      } catch (error) {
        console.error("Search failed:", error);
        setSearchResults([]);
      } finally {
        setIsSearching(false);
      }
    }, 300);

    return () => { clearTimeout(handler); };
  }, [searchQuery, ticker]);

  const handleSelectSymbol = (result: SymbolSearchResult) => {
     const isDuplicate = assets.some(
      asset => asset.ticker.toUpperCase() === result.ticker.toUpperCase() &&
               normalizeExchange(asset.exchange) === normalizeExchange(result.exchange)
    );

    if (isDuplicate) {
      setDuplicateError('이미 포트폴리오에 존재하는 자산입니다.');
    } else {
      setDuplicateError(null);
    }
    setSearchResults([]);
    const current = (ticker || '').trim();
    let nextTicker = current;
    if (!current) {
      nextTicker = result.ticker;
    } else {
      const ok = window.confirm(`티커를 '${current}'에서 '${result.ticker}'로 변경하시겠습니까?`);
      if (ok) nextTicker = result.ticker;
    }
    setTicker(nextTicker);
    setSearchQuery(result.name);
    setExchange(normalizeExchange(result.exchange));

    // 거래소에서 자산구분 자동 추론
    const inferredCategory = inferCategoryFromExchange(normalizeExchange(result.exchange));
    setCategory(inferredCategory);
    
    setSearchResults([]);
  };

  useEffect(() => {
    if (category === AssetCategory.KOREAN_STOCK) {
      setExchange('KRX (코스피/코스닥)');
    } else if (category === AssetCategory.US_STOCK) {
      setExchange('NASDAQ');
    } else if (category === AssetCategory.CRYPTOCURRENCY) {
      setExchange('주요 거래소 (종합)');
    }
  }, [category]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!ticker) {
      alert('종목 검색을 통해 유효한 자산을 선택해주세요.');
      return;
    }
    if (!quantity || !purchasePrice || !purchaseDate || !exchange || !currency || !category) {
      alert('모든 필드를 입력해주세요.');
      return;
    }
    const isDuplicateSubmit = assets.some(
      asset => asset.ticker.toUpperCase() === ticker.toUpperCase() &&
               normalizeExchange(asset.exchange) === normalizeExchange(exchange)
    );
    if (isDuplicateSubmit) {
      alert('이미 포트폴리오에 존재하는 자산입니다.');
      return;
    }
    onAddAsset({
      ticker,
      quantity: parseFloat(quantity),
      purchasePrice: parseFloat(purchasePrice),
      purchaseDate,
      category,
      exchange,
      currency
    });
  };
  
  const inputClasses = "w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition";
  const labelClasses = "block text-sm font-medium text-gray-300 mb-1";
  const showResults = isFocused && searchResults.length > 0;

  if (!isOpen) return null;

  return (
     <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-50" onClick={onClose} role="dialog" aria-modal="true">
      <div className="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-lg" onClick={(e) => e.stopPropagation()}>
        <div className="flex justify-between items-center mb-6">
            <h2 className="text-2xl font-bold text-white">신규 자산 추가</h2>
            <button onClick={onClose} className="text-gray-400 hover:text-white transition">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
        <form onSubmit={handleSubmit} className="space-y-4">
            <div>
                <label htmlFor="category" className={labelClasses}>자산 구분</label>
                <select 
                  id="category" 
                  value={category} 
                  onChange={(e) => setCategory(e.target.value as AssetCategory)} 
                  className={inputClasses} 
                  title="자산의 구분을 선택하세요. 거래소 선택 시 자동으로 설정되며 수동으로 변경할 수 있습니다."
                >
                  {ALLOWED_CATEGORIES.map((cat) => (
                    <option key={cat} value={cat}>{cat}</option>
                  ))}
                </select>
            </div>
            <div>
                <label className={labelClasses}>거래소/시장</label>
                <input value={exchange} readOnly className="w-full bg-gray-600 border border-gray-500 rounded-md py-2 px-3 text-gray-300 cursor-not-allowed" title="자산구분 또는 종목 검색에 따라 자동으로 결정됩니다." />
            </div>
            
            <div className="relative">
            <label htmlFor="ticker-search" className={labelClasses}>티커 (종목 검색)</label>
            <input 
                id="ticker-search" 
                type="text" 
                value={searchQuery} 
                onChange={handleSearchChange} 
                onFocus={() => setIsFocused(true)}
                onBlur={() => setTimeout(() => setIsFocused(false), 150)} // Delay to allow click on results
                placeholder="예: Apple, 삼성전자"
                className={inputClasses}
                required 
                autoComplete="off"
                title="자산의 이름 또는 티커를 입력하여 검색하세요."
            />
            {duplicateError && <p className="text-danger text-sm mt-1">{duplicateError}</p>}
            {isSearching && (
                <div className="absolute top-9 right-3">
                    <svg className="animate-spin h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8_0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                </div>
            )}
            {showResults && (
                <ul className="absolute z-10 w-full bg-gray-700 border border-gray-600 rounded-md mt-1 max-h-60 overflow-y-auto shadow-lg">
                {searchResults.map((result) => (
                    <li 
                    key={`${result.ticker}-${result.exchange}`} 
                    onMouseDown={() => handleSelectSymbol(result)} 
                    className="px-3 py-2 cursor-pointer hover:bg-primary-dark transition-colors"
                    role="option"
                    aria-selected="false"
                    >
                    <div className="font-bold text-white">{result.name} ({result.ticker})</div>
                    <div className="text-sm text-gray-400">{result.exchange}</div>
                    </li>
                ))}
                </ul>
            )}
            </div>

            <div className="grid grid-cols-3 gap-4">
            <div>
                <label htmlFor="quantity" className={labelClasses}>수량</label>
                <input id="quantity" type="number" value={quantity} onChange={(e) => setQuantity(e.target.value)} placeholder="10" className={inputClasses} required min="0" step="any" title="보유하고 있는 자산의 수량을 입력하세요."/>
            </div>
            <div>
                <label htmlFor="purchasePrice" className={labelClasses}>매수가</label>
                <input id="purchasePrice" type="number" value={purchasePrice} onChange={(e) => setPurchasePrice(e.target.value)} placeholder="150.00" className={inputClasses} required min="0" step="any" title="자산을 매수한 평균 단가를 선택한 통화 기준으로 입력하세요." />
            </div>
            <div>
                <label htmlFor="currency" className={labelClasses}>통화</label>
                <select id="currency" value={currency} onChange={(e) => setCurrency(e.target.value as Currency)} className={inputClasses} title="매수 가격의 통화 단위를 선택하세요.">
                    {Object.values(Currency).map((cur) => (
                    <option key={cur} value={cur}>{cur}</option>
                    ))}
                </select>
            </div>
            </div>
            <div>
            <label htmlFor="purchaseDate" className={labelClasses}>매수/보유 시작일</label>
            <input id="purchaseDate" type="date" value={purchaseDate} onChange={(e) => setPurchaseDate(e.target.value)} className={inputClasses} required title="자산을 매수했거나 보유하기 시작한 날짜를 선택하세요."/>
            </div>
            <div className="pt-4 flex justify-end">
                <button type="submit" disabled={isLoading || !!duplicateError} className="w-full bg-primary hover:bg-primary-dark text-white font-bold py-2.5 px-4 rounded-md disabled:bg-gray-600 disabled:cursor-not-allowed transition duration-300 flex items-center justify-center" title="입력한 정보로 새 자산을 포트폴리오에 추가합니다.">
                {isLoading ? (
                    <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                ) : '자산 추가'}
                </button>
            </div>
        </form>
      </div>
    </div>
  );
};

export default AddNewAssetModal;
</file>

<file path="components/EditAssetModal.tsx">
import React, { useState, useEffect, useMemo } from 'react';
import { Asset, AssetCategory, Currency, ALL_EXCHANGES, inferCategoryFromExchange, ALLOWED_CATEGORIES, normalizeExchange } from '../types';
import { searchSymbols } from '../services/geminiService';
import { usePortfolio } from '../contexts/PortfolioContext';

const EditAssetModal: React.FC = () => {
  const { modal, actions, status } = usePortfolio();
  const asset = modal.editingAsset;
  const isOpen = !!modal.editingAsset;
  const onClose = actions.closeEditModal;
  const onSave = actions.updateAsset;
  const onDelete = actions.deleteAsset;
  const isLoading = status.isLoading;
  const [formData, setFormData] = useState<Asset | null>(null);
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [searchResults, setSearchResults] = useState<{ ticker: string; name: string; exchange: string }[]>([]);
  const [isSearching, setIsSearching] = useState<boolean>(false);
  const categoryOptions = useMemo(() => {
    if (!formData) return ALLOWED_CATEGORIES;
    return ALLOWED_CATEGORIES.includes(formData.category)
      ? ALLOWED_CATEGORIES
      : [formData.category, ...ALLOWED_CATEGORIES];
  }, [formData]);

  useEffect(() => {
    if (asset) {
        setFormData({
            ...asset,
            purchaseDate: new Date(asset.purchaseDate).toISOString().slice(0, 10)
        });
        setSearchQuery('');
        setSearchResults([]);
        setIsSearching(false);
    }
  }, [asset]);

  if (!isOpen || !formData) return null;
  
  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData(prev => {
        if (!prev) return null;

        let newValue: string | number | Currency | AssetCategory | undefined = value;
        if (name === 'quantity' || name === 'purchasePrice') {
            newValue = parseFloat(value) || 0;
        } else if (name === 'sellAlertDropRate') {
            const parsed = value === '' ? undefined : parseFloat(value);
            newValue = typeof parsed === 'number' && !isNaN(parsed) ? parsed : undefined;
        } else if (name === 'currency') {
            newValue = value as Currency;
        } else if (name === 'category') {
            newValue = value as AssetCategory;
        }

        return { ...prev, [name]: newValue };
    });
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (formData) {
      onSave(formData);
    }
  };

  const handleSearchChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const q = e.target.value;
    setSearchQuery(q);
    if (!q || q.length < 2) {
      setSearchResults([]);
      return;
    }
    setIsSearching(true);
    try {
      const results = await searchSymbols(q);
      setSearchResults(results);
    } catch {
      setSearchResults([]);
    } finally {
      setIsSearching(false);
    }
  };

  const applySymbol = (r: { ticker: string; name: string; exchange: string }) => {
    const ex = normalizeExchange(r.exchange);
    const cat = inferCategoryFromExchange(ex);
    setFormData(prev => {
      if (!prev) return null;
      const current = (prev.ticker || '').trim();
      let nextTicker = current;
      const ok = window.confirm(`티커를 '${current || '(비어있음)'}'에서 '${r.ticker}'로 변경하시겠습니까?`);
      if (ok) nextTicker = r.ticker;
      return { ...prev, ticker: nextTicker, name: r.name, exchange: ex, category: cat };
    });
    setSearchQuery('');
    setSearchResults([]);
  };

  const handleDelete = () => {
    if (asset && window.confirm(`'${(asset.customName?.trim() || asset.name)}' 자산을 정말 삭제하시겠습니까?\n이 작업은 되돌릴 수 없습니다.`)) {
      onDelete(asset.id);
    }
  };

  const inputClasses = "w-full bg-gray-700 border border-gray-600 rounded-md py-2 px-3 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition";
  const labelClasses = "block text-sm font-medium text-gray-300 mb-1";

  return (
    <div className="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-50" onClick={onClose} role="dialog" aria-modal="true">
      <div className="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-lg" onClick={(e) => e.stopPropagation()}>
        <h2 className="text-2xl font-bold text-white mb-6">자산 수정: {(asset?.customName?.trim() || asset?.name)}</h2>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="category-edit" className={labelClasses}>자산 구분</label>
            <select id="category-edit" name="category" value={formData.category} onChange={handleChange} className={inputClasses}>
              {categoryOptions.map((cat) => (
                <option key={cat} value={cat}>{cat}</option>
              ))}
            </select>
          </div>
          <div>
            <label htmlFor="customName-edit" className={labelClasses}>표시용 종목명 (사용자 지정)</label>
            <input
              id="customName-edit"
              name="customName"
              type="text"
              value={formData.customName || ''}
              onChange={handleChange}
              className={inputClasses}
              placeholder="비워두면 공식 종목명을 사용합니다"
            />
            <p className="text-xs text-gray-400 mt-1">티커/거래소·가격 계산에는 영향이 없고 화면 표시 및 내보내기에만 적용됩니다.</p>
          </div>
           <div className="grid grid-cols-2 gap-4">
            <div>
              <label className={labelClasses}>거래소/시장</label>
              <input value={formData.exchange} readOnly className="w-full bg-gray-600 border border-gray-500 rounded-md py-2 px-3 text-gray-300 cursor-not-allowed" />
            </div>
            <div>
              <label htmlFor="ticker-edit" className={labelClasses}>티커 (종목코드)</label>
              <input id="ticker-edit" name="ticker" type="text" value={formData.ticker} onChange={handleChange} className={inputClasses} required />
              <div className="mt-2">
                <label htmlFor="ticker-search" className={labelClasses}>티커/종목 검색</label>
                <input id="ticker-search" type="text" value={searchQuery} onChange={handleSearchChange} placeholder="예: BMNR 또는 회사명" className={inputClasses} />
                {isSearching && <p className="text-xs text-gray-400 mt-1">검색 중...</p>}
                {searchResults.length > 0 && (
                  <ul className="mt-1 bg-gray-700 border border-gray-600 rounded-md max-h-40 overflow-y-auto">
                    {searchResults.map((r) => (
                      <li key={`${r.ticker}-${r.exchange}`} className="px-3 py-2 cursor-pointer hover:bg-gray-600" onMouseDown={() => applySymbol(r)}>
                        <div className="text-white font-semibold">{r.name} ({r.ticker})</div>
                        <div className="text-xs text-gray-300">{r.exchange}</div>
                      </li>
                    ))}
                  </ul>
                )}
              </div>
            </div>
          </div>
          <div className="grid grid-cols-3 gap-4">
            <div>
              <label htmlFor="quantity-edit" className={labelClasses}>수량</label>
              <input id="quantity-edit" name="quantity" type="number" value={formData.quantity} onChange={handleChange} className={inputClasses} required min="0" step="any" />
            </div>
            <div>
              <label htmlFor="purchasePrice-edit" className={labelClasses}>매수가</label>
              <input id="purchasePrice-edit" name="purchasePrice" type="number" value={formData.purchasePrice} onChange={handleChange} className={inputClasses} required min="0" step="any" />
            </div>
            <div>
              <label htmlFor="currency-edit" className={labelClasses}>매수 통화</label>
              <select id="currency-edit" name="currency" value={formData.currency} onChange={handleChange} className={inputClasses}>
                  {Object.values(Currency).map((cur) => (
                    <option key={cur} value={cur}>{cur}</option>
                  ))}
              </select>
            </div>
          </div>
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label htmlFor="purchaseDate-edit" className={labelClasses}>매수일</label>
              <input id="purchaseDate-edit" name="purchaseDate" type="date" value={formData.purchaseDate} onChange={handleChange} className={inputClasses} required />
            </div>
            <div>
                <label htmlFor="sellAlertDropRate-edit" className={labelClasses}>
                    개별 매도 알림률 (%)
                </label>
                <input
                    id="sellAlertDropRate-edit"
                    name="sellAlertDropRate"
                    type="number"
                    placeholder="기본값 사용"
                    value={formData.sellAlertDropRate ?? ''}
                    onChange={handleChange}
                    className={inputClasses}
                    min="0"
                    step="1"
                    title="비워두면 전역 설정을 따릅니다."
                />
            </div>
          </div>
          <div>
            <label htmlFor="memo-edit" className={labelClasses}>메모</label>
            <textarea
              id="memo-edit"
              name="memo"
              value={formData.memo || ''}
              onChange={handleChange}
              className={inputClasses}
              rows={3}
              placeholder="종목에 대한 메모를 입력하세요..."
            />
          </div>
          
          <div className="mt-8 flex justify-between items-center pt-4">
            <button
              type="button"
              onClick={handleDelete}
              disabled={isLoading}
              className="bg-danger hover:bg-red-600 text-white font-medium py-2 px-4 rounded-md transition duration-300 disabled:bg-gray-600 disabled:cursor-not-allowed"
            >
              삭제
            </button>
            <div className="flex space-x-4">
              <button type="button" onClick={onClose} className="bg-gray-600 hover:bg-gray-500 text-white font-medium py-2 px-4 rounded-md transition duration-300">
                취소
              </button>
              <button type="submit" disabled={isLoading} className="bg-primary hover:bg-primary-dark text-white font-bold py-2 px-4 rounded-md disabled:bg-gray-600 disabled:cursor-not-allowed transition duration-300 flex items-center justify-center">
                {isLoading ? (
                  <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                ) : '저장'}
              </button>
            </div>
          </div>
        </form>
      </div>
    </div>
  );
};

export default EditAssetModal;
</file>

<file path="types.ts">
export enum AssetCategory {
  KOREAN_STOCK = "한국주식",
  US_STOCK = "미국주식",
  FOREIGN_STOCK = "해외주식",
  OTHER_FOREIGN_STOCK = "기타해외주식",
  KOREAN_BOND = "한국채권",
  US_BOND = "미국채권",
  PHYSICAL_ASSET = "실물자산",
  CRYPTOCURRENCY = "암호화폐",
  CASH = "현금",
}

export enum Currency {
    KRW = "KRW",
    USD = "USD",
    JPY = "JPY",
    CNY = "CNY",
}

export const CURRENCY_SYMBOLS: Record<Currency, string> = {
    [Currency.KRW]: "₩",
    [Currency.USD]: "$",
    [Currency.JPY]: "¥",
    [Currency.CNY]: "¥",
};

export interface ExchangeRates {
  USD: number;
  JPY: number;
}

export const COMMON_EXCHANGES: string[] = [
  "KRX (코스피/코스닥)",
  "KONEX",
  "NASDAQ",
  "NYSE",
  "TSE (도쿄)",
  "SSE (상하이)",
  "HKEX (홍콩)",
  "KRX 금시장",
  "COMEX",
  "NYMEX",
  "주요 거래소 (종합)"
];

export const ALL_EXCHANGES: string[] = [
  "KRX (코스피/코스닥)",
  "KONEX",
  "NASDAQ",
  "NYSE",
  "AMEX",
  "NYSE American",
  "TSE (도쿄)",
  "SSE (상하이)",
  "SZSE (선전)",
  "HKEX (홍콩)",
  "KRX 금시장",
  "COMEX",
  "LBMA",
  "NYMEX",
  "CME",
  "ICE",
  "주요 거래소 (종합)"
];

export const inferCategoryFromExchange = (exchange: string): AssetCategory => {
  if (exchange.includes('KRX') || exchange.includes('KONEX')) {
    return AssetCategory.KOREAN_STOCK;
  } else if (['NASDAQ', 'NYSE', 'AMEX', 'NYSE American'].includes(exchange)) {
    return AssetCategory.US_STOCK;
  } else if (exchange.includes('TSE') || exchange.includes('도쿄')) {
    return AssetCategory.FOREIGN_STOCK;
  } else if (exchange.includes('SSE') || exchange.includes('SZSE') || exchange.includes('HKEX') || exchange.includes('상하이') || exchange.includes('선전') || exchange.includes('홍콩')) {
    return AssetCategory.FOREIGN_STOCK;
  } else if (exchange.includes('국채')) {
    if (exchange.includes('한국') || exchange.includes('대한민국')) {
      return AssetCategory.KOREAN_BOND;
    } else if (exchange.includes('미국')) {
      return AssetCategory.US_BOND;
    }
  } else if (exchange.includes('금') || exchange.includes('COMEX') || exchange.includes('LBMA') || exchange.includes('NYMEX') || exchange.includes('CME') || exchange.includes('ICE')) {
    return AssetCategory.PHYSICAL_ASSET;
  } else if (exchange.includes('거래소 (종합)')) {
    return AssetCategory.CRYPTOCURRENCY;
  }
  return AssetCategory.OTHER_FOREIGN_STOCK;
};

export const EXCHANGE_MAP: Record<string, string[]> = {
    [AssetCategory.KOREAN_STOCK]: ["KRX (코스피/코스닥)", "KONEX"],
    [AssetCategory.US_STOCK]: ["NASDAQ", "NYSE", "AMEX", "NYSE American"],
    [AssetCategory.FOREIGN_STOCK]: ["TSE (도쿄)", "SSE (상하이)", "SZSE (선전)", "HKEX (홍콩)"],
    [AssetCategory.OTHER_FOREIGN_STOCK]: ["TSE (도쿄)", "SSE (상하이)", "SZSE (선전)", "HKEX (홍콩)"],
    [AssetCategory.KOREAN_BOND]: ["대한민국 국채"],
    [AssetCategory.US_BOND]: ["미국 국채"],
    [AssetCategory.PHYSICAL_ASSET]: ["KRX 금시장", "COMEX", "LBMA", "NYMEX", "CME", "ICE"],
    [AssetCategory.CRYPTOCURRENCY]: ["주요 거래소 (종합)"],
    [AssetCategory.CASH]: ["현금"],
};

export const ALLOWED_CATEGORIES: AssetCategory[] = [
  AssetCategory.KOREAN_STOCK,
  AssetCategory.US_STOCK,
  AssetCategory.OTHER_FOREIGN_STOCK,
  AssetCategory.KOREAN_BOND,
  AssetCategory.US_BOND,
  AssetCategory.CRYPTOCURRENCY,
  AssetCategory.PHYSICAL_ASSET,
];

export interface WatchlistItem {
  id: string;
  ticker: string;
  exchange: string;
  name: string;
  category: AssetCategory;
  monitoringEnabled: boolean;
  notes?: string;
  buyZoneMin?: number;
  buyZoneMax?: number;
  dropFromHighThreshold?: number;
  currentPrice?: number;
  priceOriginal?: number;
  currency?: Currency;
  yesterdayPrice?: number;
  highestPrice?: number;
  lastSignalAt?: string;
  lastSignalType?: 'BUY_ZONE' | 'DROP_FROM_HIGH' | 'DAILY_DROP' | null;
}

export interface SellTransaction {
  id: string;
  sellDate: string;
  sellPrice: number;
  sellPriceOriginal?: number;
  sellQuantity: number;
  sellExchangeRate?: number;
  settlementCurrency?: Currency;
  sellPriceSettlement?: number;
}

export interface SellRecord extends SellTransaction {
  assetId: string;
  ticker: string;
  name: string;
  category: AssetCategory;
}

export interface Asset {
  id: string;
  category: AssetCategory;
  ticker: string;
  exchange: string;
  name: string;
  customName?: string;
  quantity: number;
  purchasePrice: number;
  purchaseDate: string;
  currency: Currency;
  purchaseExchangeRate?: number;
  currentPrice: number;
  priceOriginal: number;
  highestPrice: number;
  yesterdayPrice?: number;
  sellAlertDropRate?: number;
  memo?: string;
  sellTransactions?: SellTransaction[];
}

export type NewAssetForm = Omit<Asset, 'id' | 'name' | 'currentPrice' | 'priceOriginal' | 'highestPrice' | 'purchaseExchangeRate'>;

export interface SymbolSearchResult {
  ticker: string;
  name: string;
  exchange: string;
}

export interface BulkUploadResult {
  successCount: number;
  failedCount: number;
  errors: { ticker: string; reason: string }[];
}

export interface AssetSnapshot {
  id: string;
  name: string;
  currentValue: number;
  purchaseValue: number;
  unitPrice?: number; // [추가] 1주당 단가 (원화 환산 기준 권장)
}

export interface PortfolioSnapshot {
  date: string;
  assets: AssetSnapshot[];
}

export const normalizeExchange = (exchange: string): string => {
  const e = exchange.trim();
  if (e.toUpperCase() === 'AMEX' || e.toUpperCase() === 'NYSE MKT') return 'NYSE American';
  if (e.toUpperCase() === 'NYSE AMERICAN') return 'NYSE American';
  return e;
};

export interface AssetDataResult {
  name: string;
  priceOriginal: number;
  priceKRW: number;
  currency: Currency;
  pricePreviousClose: number;
  highestPrice?: number;
  isMocked: boolean;
}

export interface PriceItem {
  ticker?: string;
  symbol?: string;
  name?: string;
  priceOriginal?: number;
  priceKRW?: number;
  price?: number;
  close?: number;
  previousClose?: number;
  prev_close?: number;
  yesterdayPrice?: number;
  currency?: Currency | string;
}

export type PriceAPIArrayResponse = PriceItem[];
export type PriceAPIObjectResponse = Record<string, PriceItem>;
export interface PriceAPIResultResponse {
  results: PriceItem[];
}
export type PriceAPIResponse = PriceAPIArrayResponse | PriceAPIObjectResponse | PriceAPIResultResponse;

export interface LegacyAssetShape {
  id?: string;
  category: AssetCategory | string;
  ticker: string;
  exchange?: string;
  name: string;
  customName?: string;
  quantity: number;
  purchasePrice: number;
  purchaseDate: string;
  currency?: Currency;
  purchaseExchangeRate?: number;
  currentPrice: number;
  priceOriginal?: number;
  highestPrice?: number;
  yesterdayPrice?: number;
  sellAlertDropRate?: number;
  memo?: string;
  region?: string;
}

export interface DriveFileMetadata {
  name: string;
  mimeType: string;
  parents?: string[];
}
</file>

<file path="README.md">
# KIM'S 퀸트자산관리 - 포트폴리오 관리 시스템

## 📋 프로젝트 개요

KIM'S 퀸트자산관리는 계량적 투자 전략을 기반으로 한 종합 자산 관리 시스템입니다. Google Drive 연동을 통해 데이터를 안전하게 저장하고, 실시간 시세 정보를 제공하며, 다양한 자산 종류를 지원하는 포트폴리오 관리 도구입니다.

### 핵심 기능
- **멀티 자산 지원**: 한국주식, 미국주식, 해외주식, 채권, 암호화폐, 실물자산, 현금
- **실시간 시세 업데이트**: 외부 API를 통한 실시간 가격 정보
- **환율 자동 반영**: USD, JPY 등 주요 통화 환율 자동 적용
- **Google Drive 동기화**: 안전한 클라우드 저장소 연동
- **포트폴리오 분석**: 자산 배분, 수익률, 손익 추이 분석
- **매도 알림**: 설정한 하락률 기준 알림 기능
- **관심종목 관리**: 별도의 워치리스트 기능
- **CSV 대량 등록**: 대량의 자산 일괄 등록

## 🏗️ 시스템 아키텍처

### 기술 스택
- **프론트엔드**: React 19.2.0, TypeScript
- **스타일링**: Tailwind CSS
- **빌드 도구**: Vite
- **차트 라이브러리**: Recharts
- **아이콘**: Lucide React
- **배포**: GitHub Pages
- **백엔드**: Google Cloud Run (Python)

### 프로젝트 구조

```
자산-관리-시트/
├── components/                 # React 컴포넌트
│   ├── common/               # 공통 컴포넌트
│   │   └── Toggle.tsx       # 토글 스위치 컴포넌트
│   ├── AddAssetForm.tsx     # 자산 추가 폼
│   ├── AddNewAssetModal.tsx # 새 자산 추가 모달
│   ├── AllocationChart.tsx  # 자산 배분 차트
│   ├── AssetTrendChart.tsx  # 자산 추이 차트
│   ├── BulkUploadModal.tsx  # CSV 대량 업로드 모달
│   ├── CategorySummaryTable.tsx # 카테고리 요약 테이블
│   ├── DataConflictModal.tsx # 데이터 충돌 모달
│   ├── EditAssetModal.tsx   # 자산 수정 모달
│   ├── ExchangeRateInput.tsx # 환율 입력 컴포넌트
│   ├── Header.tsx           # 헤더 컴포넌트
│   ├── layouts/             # 레이아웃 컴포넌트 (탭별 화면)
│   │   ├── DashboardView.tsx    # 대시보드 탭
│   │   ├── PortfolioView.tsx    # 포트폴리오 탭
│   │   ├── AnalyticsView.tsx    # 통계 탭
│   │   └── WatchlistView.tsx    # 관심종목 탭
│   ├── PortfolioAssistant.tsx # 포트폴리오 AI 어시스턴트
│   ├── PortfolioModal.tsx   # 포트폴리오 모달
│   ├── PortfolioTable.tsx   # 포트폴리오 테이블 (메인 Wrapper)
│   ├── portfolio-table/     # 포트폴리오 테이블 내부 컴포넌트
│   │   ├── PortfolioTableRow.tsx # 테이블 행 컴포넌트
│   │   ├── usePortfolioData.ts   # 데이터 로직 훅
│   │   ├── types.ts              # 타입 정의
│   │   └── utils.ts              # 유틸리티 함수
│   ├── ProfitLossChart.tsx  # 손익 추이 차트
│   ├── RegionAllocationChart.tsx # 지역 배분 차트
│   ├── SellAlertControl.tsx # 매도 알림 설정
│   ├── SellAnalyticsPage.tsx # 매도 분석 페이지
│   ├── SellAssetModal.tsx   # 자산 매도 모달
│   ├── StatCard.tsx         # 통계 카드
│   ├── TopBottomAssets.tsx  # 상위/하위 자산
│   └── WatchlistPage.tsx    # 관심종목 페이지
├── hooks/                    # 커스텀 훅
│   ├── usePortfolioData.ts   # 핵심 데이터 및 동기화 관리
│   ├── useMarketData.ts      # 시세 및 환율 관리 (암호화폐 분기 처리 포함)
│   ├── useAssetActions.ts    # 자산 CRUD 및 액션 관리
│   ├── useGoogleDriveSync.ts # Google Drive API 래퍼
│   └── useOnClickOutside.ts  # 외부 클릭 감지 훅
├── services/                 # 외부 서비스 연동
│   ├── geminiService.ts   # Gemini AI 서비스
│   ├── googleDriveService.ts # Google Drive API
│   ├── priceService.ts    # 시세 정보 서비스 (주식/ETF)
│   └── upbitService.ts    # 업비트 API 서비스 (Cloud Run 프록시 경유)
├── utils/                    # 유틸리티 함수
│   └── migrateData.ts     # 데이터 마이그레이션
├── types.ts                # TypeScript 타입 정의
├── App.tsx                 # 메인 애플리케이션
├── index.tsx              # 애플리케이션 진입점
└── initialData.ts         # 초기 데이터
```

## 📊 데이터 흐름 및 의존성

### 핵심 데이터 구조

#### 1. 자산 (Asset) 데이터
```typescript
interface Asset {
  id: string;                    // 고유 식별자
  category: AssetCategory;       // 자산 카테고리
  ticker: string;                // 티커 심볼
  exchange: string;              // 거래소
  name: string;                  // 자산명
  customName?: string;           // 사용자 지정명
  quantity: number;               // 보유 수량
  purchasePrice: number;        // 매수 단가
  purchaseDate: string;         // 매수일
  currency: Currency;           // 통화
  purchaseExchangeRate?: number; // 매수 시 환율
  currentPrice: number;        // 현재가
  priceOriginal: number;       // 원화 이외 통화의 원가
  highestPrice: number;        // 최고가
  yesterdayPrice?: number;     // 전일 종가
  sellAlertDropRate?: number;  // 매도 알림 하락률
  memo?: string;               // 메모
  sellTransactions?: SellTransaction[]; // 매도 이력
}
```

#### 2. 포트폴리오 스냅샷
```typescript
interface PortfolioSnapshot {
  date: string;                 // 날짜
  assets: AssetSnapshot[];     // 자산 스냅샷
}

interface AssetSnapshot {
  id: string;                  // 자산 ID
  name: string;               // 자산명
  currentValue: number;       // 현재가치
  purchaseValue: number;      // 매수가치
  unitPrice?: number;        // 1주당 단가
}
```

### 데이터 흐름도

```
사용자 입력 → 컴포넌트 → 상태 관리 → Google Drive 저장
     ↓
┌─────────────────────────────────────────────────────────────┐
│                    시세 업데이트 흐름                         │
├─────────────────────────────────────────────────────────────┤
│  useMarketData.ts                                           │
│       │                                                     │
│       ├─── 자산 분류 (shouldUseUpbitAPI 함수)                │
│       │         │                                           │
│       │         ├─── Upbit/Bithumb 거래소                   │
│       │         │    또는 한글 거래소명 + 암호화폐 카테고리    │
│       │         │         ↓                                 │
│       │         │    upbitService.ts → Cloud Run /upbit     │
│       │         │         ↓                                 │
│       │         │    업비트 API (KRW 가격)                   │
│       │         │                                           │
│       │         └─── 그 외 (주식, ETF, 해외주식 등)          │
│       │                   ↓                                 │
│       │              priceService.ts → Cloud Run /          │
│       │                   ↓                                 │
│       │              FinanceDataReader                      │
│       │                                                     │
│       └─── 결과 병합 → UI 반영                              │
└─────────────────────────────────────────────────────────────┘
     ↓
포트폴리오 분석 → 차트/통계 → 시각화
```

### 주요 의존성

#### 1. 외부 API 의존성
- **Cloud Run 서버**: `https://asset-manager-887842923289.asia-northeast3.run.app`
  - **`/` (POST)**: 한국주식, 미국주식, 해외주식, ETF 시세 (FinanceDataReader)
  - **`/upbit` (POST)**: 암호화폐 시세 (업비트 API 프록시) ← **신규 추가**
  - 환율 정보 (USD/KRW, JPY/KRW)

#### 2. 시세 조회 분기 로직 (신규)
```typescript
// hooks/useMarketData.ts
const shouldUseUpbitAPI = (exchange: string, category?: AssetCategory): boolean => {
  // 1. exchange가 'Upbit' 또는 'Bithumb'인 경우 → 업비트 API
  // 2. exchange에 한글이 포함되어 있고 category가 암호화폐인 경우 → 업비트 API
  // 3. 그 외 → Cloud Run 기본 엔드포인트 (FinanceDataReader)
};
```

#### 3. Google Drive API
- **인증**: OAuth 2.0
- **스코프**: 
  - `https://www.googleapis.com/auth/drive.file`
  - `https://www.googleapis.com/auth/userinfo.email`
  - `https://www.googleapis.com/auth/userinfo.profile`
  - `openid`

#### 4. 내부 모듈 의존성
```
App.tsx
├── hooks/
│   └── useMarketData.ts ─────┬─── priceService.ts (주식/ETF)
│                             └─── upbitService.ts (암호화폐)
├── services/
│   ├── priceService.ts      (시세 정보 - Cloud Run /)
│   ├── upbitService.ts      (암호화폐 - Cloud Run /upbit) ← 신규 의존성
│   ├── googleDriveService.ts (클라우드 저장)
│   └── geminiService.ts    (AI 분석)
└── components/             (UI 컴포넌트들)
```

## 🎯 주요 컴포넌트 상세

### 1. App.tsx (메인 컴포넌트)
**역할**: 애플리케이션 진입점 및 레이아웃 구성
**책임**:
- 주요 Hooks(`usePortfolioData`, `useMarketData`, `useAssetActions`) 초기화 및 연결
- 탭 네비게이션 상태 관리 및 라우팅
- 전역 모달(설정, 파일 업로드 등) 관리
- 로그인 상태에 따른 화면 분기 처리

### 2. 핵심 Hooks (상태 및 로직 분리)
- **usePortfolioData**: 자산, 히스토리, 환율 등 핵심 데이터 상태 관리 및 Google Drive 동기화 담당
- **useMarketData**: 외부 API를 통한 시세 업데이트, 환율 갱신 로직 담당
  - **암호화폐 분기 처리**: `shouldUseUpbitAPI()` 함수를 통해 업비트 자산과 일반 자산 분리
  - **병렬 조회**: 업비트 API와 일반 시세 API를 동시에 호출하여 성능 최적화
- **useAssetActions**: 자산 추가/수정/삭제, 매도, CSV 업로드 등 사용자 인터랙션 처리

### 3. priceService.ts (주식/ETF 시세 서비스)
**역할**: Cloud Run 서버를 통한 주식/ETF 시세 정보 관리
**책임**:
- 배치 단위 시세 조회 (20개씩 청크 처리)
- 환율 정보 조회
- 재시도 로직 (1회)
- 에러 처리 및 모킹 데이터 제공
**대상 자산**:
- 한국주식 (KRX, KONEX)
- 미국주식 (NASDAQ, NYSE, AMEX)
- 해외주식 (TSE 등)
- ETF, 채권, 실물자산

### 4. upbitService.ts (암호화폐 시세 서비스) ← **신규/수정**
**역할**: Cloud Run 프록시를 통한 업비트 암호화폐 시세 조회
**책임**:
- Cloud Run `/upbit` 엔드포인트 호출 (CORS 우회)
- 심볼 → 마켓 코드 변환 (BTC → KRW-BTC)
- 유효하지 않은 심볼 필터링
- 결과 매핑 (마켓 코드 및 심볼 양방향)
**대상 자산**:
- exchange가 'Upbit' 또는 'Bithumb'인 자산
- exchange에 한글이 포함되고 category가 암호화폐인 자산

### 5. googleDriveService.ts (Google Drive 서비스)
**역할**: 클라우드 저장소 관리
**책임**:
- OAuth 2.0 인증
- 토큰 자동 갱신 (만료 5분 전)
- 파일 저장/불러오기
- 사용자 정보 관리

### 6. PortfolioTable.tsx (포트폴리오 테이블)
**역할**: 자산 목록 표시 및 관리 (Wrapper 컴포넌트)
**구조**:
- `components/portfolio-table/` 디렉토리로 로직 분리
- `usePortfolioData`: 데이터 가공, 정렬, 필터링 로직 담당
**주요 변경사항**:
- **수익률 계산 로직 개선 (Upbit/Bithumb 예외 처리)**: Upbit/Bithumb 자산의 경우, 설정된 통화(`currency`)와 무관하게 API가 반환하는 원화(`KRW`) 가격을 기준으로 수익률을 계산하도록 로직 수정. `currency`가 'USD'로 설정되어 있어도 `currentPrice`는 KRW(API 값), `yesterdayPrice`는 USD(데이터 불일치)인 경우를 감지하여 환율을 자동 적용해 올바른 등락률(`yesterdayChange`)을 계산하고 비정상적인 수익률(예: 147,000%) 표시 문제를 해결함.
- **변동액 표시 개선**: 전일 대비 변동액(`diffFromYesterday`) 또한 KRW 기준으로 계산 및 표시.

### 7. RebalancingTable.tsx (포트폴리오 리밸런싱)
**역할**: 목표 자산 비중 설정 및 리밸런싱 가이드 제공
**기능**:
- **목표 비중 설정**: 자산군별 목표 비중(%) 입력 및 목표 금액 자동 계산
- **리밸런싱 가이드**: 현재 평가액과 목표 금액의 차이를 계산하여 매수/매도 필요 금액 제시
- **상태 관리**: 목표 총 자산 금액 및 비중 설정을 실시간으로 반영하여 시뮬레이션 가능

### 8. DashboardView.tsx (대시보드)
**역할**: 전체 자산 현황 요약 및 환율/필터 제어
**주요 변경사항**:
- **UI 레이아웃 개선**: 자산 필터, 환율 입력, 매도 알림을 상단 한 줄에 배치하여 공간 효율성 최적화
- **ExchangeRateInput 연동**: 외부 스타일 주입(`className`)을 통해 유연한 배치 적용
- **반응형 디자인**: 화면 크기에 따른 자동 줄바꿈(`flex-wrap`) 지원

## ⚙️ 핵심 로직 및 알고리즘

### 1. 시세 업데이트 로직 (수정됨)
```typescript
// hooks/useMarketData.ts

// 1. 자산 분류
const cashAssets = assets.filter(a => a.category === AssetCategory.CASH);
const upbitAssets = assets.filter(a => 
  a.category !== AssetCategory.CASH && shouldUseUpbitAPI(a.exchange, a.category)
);
const generalAssets = assets.filter(a => 
  a.category !== AssetCategory.CASH && !shouldUseUpbitAPI(a.exchange, a.category)
);

// 2. 병렬 조회
const [cashResults, batchPriceMap, upbitPriceMap] = await Promise.all([
  Promise.allSettled(cashPromises),
  fetchBatchAssetPricesNew(assetsToFetch),  // Cloud Run / (주식/ETF)
  fetchUpbitPricesBatch(upbitSymbols)        // Cloud Run /upbit (암호화폐)
]);

// 3. 결과 병합 및 UI 반영
```

### 2. 암호화폐 분기 판단 로직 (신규)
```typescript
// hooks/useMarketData.ts
const shouldUseUpbitAPI = (exchange: string, category?: AssetCategory): boolean => {
  const normalized = (exchange || '').toLowerCase();
  
  // 명확하게 Upbit/Bithumb인 경우
  if (normalized === 'upbit' || normalized === 'bithumb') {
    return true;
  }
  
  // 한글이 포함된 거래소명이고 암호화폐인 경우 (예: '주요 거래소 (종합)')
  const hasKorean = /[ㄱ-ㅎ|ㅏ-ㅣ|가-힣]/.test(exchange);
  if (hasKorean && category === AssetCategory.CRYPTOCURRENCY) {
    return true;
  }
  
  return false;
};
```

### 3. 환율 적용 로직
```typescript
// 대시보드 환율 값 우선 적용
// 기본값: USD: 1450, JPY: 9.5
// 실시간 API 실패 시 기존 값 유지
```

### 4. 자산 카테고리 추론
```typescript
// 거래소 정보를 통한 카테고리 자동 판단
KRX/KONEX → 한국주식
NASDAQ/NYSE → 미국주식
TSE → 해외주식
Upbit/Bithumb → 암호화폐
금 관련 거래소 → 실물자산
```

### 5. 데이터 마이그레이션
```typescript
// 이전 버전 데이터 구조 변환
// region 필드 제거
// category 매핑 (한국어 → enum)
// exchange 기본값 설정
```

## 🖥️ Cloud Run 서버 (백엔드)

### 엔드포인트
| 경로 | 메서드 | 설명 | 요청 형식 |
|------|--------|------|-----------|
| `/` | POST | 주식/ETF 시세 조회 | `{ "tickers": [{"ticker": "005930", "exchange": "KRX"}] }` |
| `/upbit` | POST | 암호화폐 시세 조회 | `{ "symbols": ["BTC", "ETH"] }` |

### 주요 파일
```
cloud-run/
├── main.py           # Cloud Run 엔트리포인트
└── requirements.txt  # Python 의존성
```

### main.py 핵심 기능
```python
# 기존: 주식/ETF 시세 조회 (FinanceDataReader)
def fetch_single_ticker(ticker):
    df = fdr.DataReader(ticker, start=start_date, end=end_date)
    ...

# 신규: 업비트 프록시
def fetch_upbit_prices(markets):
    url = f"https://api.upbit.com/v1/ticker?markets={markets_param}"
    response = requests.get(url)
    ...

@functions_framework.http
def get_stock_prices(request):
    if path == '/upbit' or path == '/upbit/':
        # 업비트 프록시 처리
        ...
    else:
        # 기존 주식 조회 처리
        ...
```

### 배포 명령
```bash
gcloud run deploy asset-manager \
  --source . \
  --region asia-northeast3 \
  --allow-unauthenticated
```

## 🔧 설정 및 환경 변수

### 필수 환경 변수
```env
VITE_GOOGLE_CLIENT_ID=your_google_client_id
```

### Google Cloud Console 설정
1. OAuth 2.0 클라이언트 ID 생성
2. 승인된 리디렉션 URI 설정
3. 필요한 API 활성화:
   - Google Drive API
   - Google OAuth2.0

### 빌드 설정
```typescript
// vite.config.ts
base: '/asset-manager/'  // GitHub Pages 경로
```

## 🚀 배포 및 빌드

### 개발 서버 실행
```bash
npm run dev
```

### 프로덕션 빌드
```bash
npm run build
```

### GitHub Pages 배포
```bash
npm run deploy
```

### Cloud Run 배포
```bash
cd cloud-run
gcloud run deploy asset-manager --source . --region asia-northeast3 --allow-unauthenticated
```

## 📋 주의사항 및 오류 방지 가이드

### 1. 시세 API 관련
- **청크 크기 제한**: 20개씩 요청 (API 제한 사항)
- **암호화폐 분기 처리**: `exchange` 기준으로 업비트 API와 일반 API 분기
  - Upbit/Bithumb 거래소 → Cloud Run `/upbit` 엔드포인트
  - 한글 거래소명 + 암호화폐 카테고리 → Cloud Run `/upbit` 엔드포인트
  - 그 외 → Cloud Run `/` 엔드포인트 (FinanceDataReader)
- **Upbit/Bithumb 예외 처리**: 업비트 API는 항상 KRW 가격을 반환하므로, `currency` 설정과 무관하게 강제로 KRW로 처리
- **CORS 우회**: 클라이언트에서 업비트 직접 호출 불가 → Cloud Run 프록시 필수
- **재시도**: 실패 시 1회 재시도, 1초 대기
- **모킹 데이터**: API 실패 시 기본값 제공 (isMocked: true)

### 2. 환율 처리
- **기본값 설정**: USD 1450, JPY 9.5
- **유효성 검사**: USD > 100, JPY > 1
- **실시간 반영**: 자산 가치 계산 전 환율 우선 업데이트

### 3. Google Drive 동기화
- **자동 저장**: 2초 디바운스 적용
- **토큰 갱신**: 만료 5분 전 자동 갱신
- **오류 처리**: 네트워크 오류 시 재시도 로직

### 4. 데이터 무결성
- **마이그레이션**: 이전 버전 데이터 자동 변환
- **구조 검증**: 필수 필드 존재 여부 확인
- **백업**: Google Drive에 자동 저장

### 5. 성능 최적화
- **useMemo 활용**: 무거운 계산 결과 캐싱
- **청크 처리**: 대량 데이터 분배 처리
- **병렬 조회**: 업비트 API와 일반 API 동시 호출
- **지연 로딩**: 컴포넌트 지연 로딩 적용

## 🔍 디버깅 및 모니터링

### 로그 레벨
- `console.log`: API 요청/응답 데이터
  - `[useMarketData] 자산 분류:` - 자산 분류 결과
  - `[useMarketData] 업비트 조회 심볼:` - 업비트 API로 조회할 심볼
  - `[useMarketData] Cloud Run 조회:` - 일반 API로 조회할 심볼
  - `[Upbit] BTC: 현재가=xxx, 전일종가=xxx` - 업비트 조회 결과
- `console.error`: 오류 상세 정보
- `console.warn`: 경고 메시지

### 에러 처리
- **사용자 친화적 메시지**: 기술적 오류를 이해하기 쉽게 변환
- **자동 복구**: 가능한 경우 자동 복구 시도
- **상태 복원**: 오류 발생 시 이전 상태로 복원
- **부분 성공**: 일부 자산 조회 실패 시 성공한 자산만 업데이트

### 모니터링 포인트
- API 응답 시간
- 환율 업데이트 성공률
- Google Drive 동기화 성공률
- 메모리 사용량
- 업비트 API 호출 성공률

## 📚 확장 가이드

### 새로운 자산 카테고리 추가
1. `AssetCategory` enum에 추가
2. `EXCHANGE_MAP`에 거래소 매핑
3. `inferCategoryFromExchange` 로직 업데이트
4. 관련 컴포넌트 UI 업데이트

### 새로운 거래소 추가
1. `COMMON_EXCHANGES` 또는 `ALL_EXCHANGES`에 추가
2. 카테고리 추론 로직 업데이트
3. 시세 API 지원 확인
4. **암호화폐 거래소인 경우**: `shouldUseUpbitAPI()` 함수에 조건 추가

### 통화 추가
1. `Currency` enum에 추가
2. `CURRENCY_SYMBOLS`에 심볼 추가
3. 환율 API 엔드포인트 확인
4. 환율 입력 UI 업데이트

### 새로운 암호화폐 거래소 추가 (신규)
1. `shouldUseUpbitAPI()` 함수에 거래소명 조건 추가
2. 해당 거래소 API가 업비트와 호환되는지 확인
3. 호환되지 않는 경우 별도 서비스 파일 생성 및 Cloud Run 엔드포인트 추가

## 🧩 개발 참고: 타입 가이드 및 any 금지

- 공용 타입은 모두 [types.ts](file:///c:/Users/beari/Desktop/Dev/asset-manager/types.ts)에 정의하고 전 파일에서 일관되게 사용
- any 사용 금지: 응답/데이터는 명확한 인터페이스로 모델링
  - 시세 응답 아이템: [PriceItem](file:///c:/Users/beari/Desktop/Dev/asset-manager/types.ts#L214-L232)
  - 시세 응답 포맷: [PriceAPIResponse](file:///c:/Users/beari/Desktop/Dev/asset-manager/types.ts#L234-L241)
  - 구버전 데이터: [LegacyAssetShape](file:///c:/Users/beari/Desktop/Dev/asset-manager/types.ts#L243-L270)
  - 드라이브 메타데이터: [DriveFileMetadata](file:///c:/Users/beari/Desktop/Dev/asset-manager/types.ts#L272-L276)
- 통화 타입 일관화: [AssetDataResult.currency](file:///c:/Users/beari/Desktop/Dev/asset-manager/types.ts#L204-L212)는 반드시 [Currency](file:///c:/Users/beari/Desktop/Dev/asset-manager/types.ts#L13-L18)
- 프런트 서비스에서의 적용 예시
  - 일반 시세/환율 처리: [priceService.ts](file:///c:/Users/beari/Desktop/Dev/asset-manager/services/priceService.ts)
  - 업비트 시세 처리: [upbitService.ts](file:///c:/Users/beari/Desktop/Dev/asset-manager/services/upbitService.ts)
  - 데이터 마이그레이션: [migrateData.ts](file:///c:/Users/beari/Desktop/Dev/asset-manager/utils/migrateData.ts)

## 🔗 데이터 소스 및 구현 확인

- 주식/ETF/해외주식
  - 소스: Google Cloud Run 기본 엔드포인트 `/` (Python) + FinanceDataReader
  - 클라이언트: [priceService.ts](file:///c:/Users/beari/Desktop/Dev/asset-manager/services/priceService.ts) 배치 조회/환율 조회 사용
  - 분기/병합: [useMarketData.ts](file:///c:/Users/beari/Desktop/Dev/asset-manager/hooks/useMarketData.ts#L126-L154) 일반 자산을 Cloud Run으로 조회 후 결과 병합
- 암호화폐
  - 소스: Cloud Run `/upbit` 프록시 → 업비트 API(KRW)
  - 클라이언트: [upbitService.ts](file:///c:/Users/beari/Desktop/Dev/asset-manager/services/upbitService.ts#L36-L66)
  - 분기 로직: [shouldUseUpbitAPI](file:///c:/Users/beari/Desktop/Dev/asset-manager/hooks/useMarketData.ts#L26-L41)로 Upbit/Bithumb 또는 한글 거래소+암호화폐 판별
  - 병합/반영: [useMarketData.ts](file:///c:/Users/beari/Desktop/Dev/asset-manager/hooks/useMarketData.ts#L135-L147), [useMarketData.ts](file:///c:/Users/beari/Desktop/Dev/asset-manager/hooks/useMarketData.ts#L175-L201)

---

## 📝 변경 이력

### 2024-XX-XX: 암호화폐 시세 조회 개선
- **문제**: Cloud Run 서버에서 암호화폐 시세 조회 실패 (빈 응답 반환)
- **원인**: FinanceDataReader가 암호화폐를 지원하지 않음
- **해결**:
  1. Cloud Run 서버에 `/upbit` 엔드포인트 추가 (업비트 API 프록시)
  2. `useMarketData.ts`에서 `exchange` 기준 분기 처리
  3. `upbitService.ts`가 Cloud Run 프록시 호출하도록 수정
- **영향받는 파일**:
  - `main.py` (Cloud Run 서버)
  - `hooks/useMarketData.ts`
  - `services/upbitService.ts`
</file>

<file path="services/priceService.ts">
import { AssetCategory, Currency, AssetDataResult, normalizeExchange, PriceAPIResponse, PriceItem } from '../types';

const STOCK_API_URL = 'https://asset-manager-887842923289.asia-northeast3.run.app';
const CHUNK_SIZE = 20;
const CHUNK_DELAY_MS = 500;
const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

function toNumber(v: unknown, fallback = 0): number {
  const n = Number(v);
  return isFinite(n) ? n : fallback;
}

function createMockResult(ticker: string): AssetDataResult {
  return {
    name: ticker,
    priceOriginal: 0,
    priceKRW: 0,
    currency: Currency.KRW,
    pricePreviousClose: 0,
    highestPrice: 0,
    isMocked: true,
  };
}

function extractByTickerKey(data: PriceAPIResponse, key?: string): PriceItem | undefined {
  if (!data) return undefined;
  if ('results' in data && Array.isArray((data as { results: PriceItem[] }).results)) {
    if (!key) return (data as { results: PriceItem[] }).results?.[0];
    const k = String(key).toUpperCase();
    return (data as { results: PriceItem[] }).results.find((x) => String(x?.ticker ?? x?.symbol ?? '').toUpperCase() === k);
  }
  if (Array.isArray(data)) {
    if (!key) return data[0];
    const k = String(key).toUpperCase();
    return data.find((x) => String(x?.ticker ?? x?.symbol ?? '').toUpperCase() === k);
  }
  if (typeof data === 'object') {
    if (!key) {
      const firstKey = Object.keys(data)[0];
      return data[firstKey];
    }
    const k = String(key).toUpperCase();
    const direct = Object.prototype.hasOwnProperty.call(data, k) ? (data as Record<string, PriceItem>)[k] : undefined;
    if (direct) return direct;
    const alt = Object.keys(data).find((kk) => String(kk).toUpperCase() === k);
    return alt ? (data as Record<string, PriceItem>)[alt] : undefined;
  }
  return undefined;
}

async function fetchStocksBatch(payload: Array<{ ticker: string; exchange?: string }>): Promise<PriceAPIResponse> {
  console.log('fetchStocksBatch request', payload);
  const res = await fetch(STOCK_API_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ tickers: payload }),
  });
  if (!res.ok) {
    const text = await res.text().catch(() => '');
    throw new Error(`시세 서버 호출 실패: ${res.status} ${text}`);
  }
  try {
    const json = await res.json();
    console.log('fetchStocksBatch response', json);
    return json;
  } catch {
    const text = await res.text().catch(() => '');
    console.error('fetchStocksBatch parse failed', {
      status: res.status,
      contentType: res.headers.get('Content-Type') ?? res.headers.get('content-type') ?? '',
      preview: typeof text === 'string' ? text.slice(0, 512) : '',
    });
    throw new Error(`시세 서버 응답 처리 실패: ${text}`);
  }
}

export async function fetchExchangeRate(): Promise<number> {
  try {
    const data = await fetchStocksBatch([{ ticker: 'USD/KRW', exchange: 'KRX' }]);
    const obj = extractByTickerKey(data, 'USD/KRW');
    console.log('fetchExchangeRate parsed', obj);
    const rate = toNumber(obj?.priceOriginal ?? obj?.price ?? obj?.close, 0);
    if (rate > 0) return rate;
    throw new Error('환율 데이터가 올바르지 않습니다');
  } catch (e) {
    throw e;
  }
}

export async function fetchExchangeRateJPY(): Promise<number> {
  try {
    const data = await fetchStocksBatch([{ ticker: 'JPY/KRW', exchange: 'KRX' }]);
    const obj = extractByTickerKey(data, 'JPY/KRW');
    console.log('fetchExchangeRateJPY parsed', obj);
    const rate = toNumber(obj?.priceOriginal ?? obj?.price ?? obj?.close, 0);
    if (rate > 0) return rate;
    throw new Error('엔화 환율 데이터가 올바르지 않습니다');
  } catch (e) {
    throw e;
  }
}

export async function fetchBatchAssetPrices(
  assets: { ticker: string; exchange: string; id: string; category?: AssetCategory; currency?: Currency }[],
): Promise<Map<string, AssetDataResult>> {
  const resultMap = new Map<string, AssetDataResult>();
  if (assets.length === 0) return resultMap;

  for (let i = 0; i < assets.length; i += CHUNK_SIZE) {
    const chunk = assets.slice(i, i + CHUNK_SIZE);
    const payload = chunk.map(s => {
      // 카테고리 무관하게 원본 티커 그대로 사용
      // (만약 Yahoo Finance로 코인을 조회하고 싶다면, 사용자가 애초에 'BTC-USD'로 입력해야 함)
      const reqTicker = String(s.ticker).toUpperCase(); 
      return { ticker: reqTicker, exchange: normalizeExchange(s.exchange) };
    });
    console.log('fetchBatchAssetPrices payload', payload);
    try {
      const data = await fetchStocksBatch(payload);
      console.log('fetchBatchAssetPrices raw response', data);
      const items: PriceItem[] = [];
      if ('results' in data && Array.isArray((data as { results: PriceItem[] }).results)) {
        items.push(...(data as { results: PriceItem[] }).results);
      } else if (Array.isArray(data)) {
        items.push(...data);
      } else if (typeof data === 'object' && data) {
        Object.keys(data).forEach(k => {
          const v = data[k];
          if (v && typeof v === 'object') items.push({ ...v, ticker: k });
        });
      }
      items.forEach((item: PriceItem) => {
        const ticker = String(item.ticker ?? item.symbol ?? '').toUpperCase();
        const normalizedTicker = ticker.endsWith('-USD') ? ticker.replace(/-USD$/i, '') : ticker;
        const matched = assets.find(a => a.ticker.toUpperCase() === normalizedTicker);
        if (!matched) return;
        const priceOrig = toNumber(item.priceOriginal ?? item.price ?? item.close, 0);
        const prev = toNumber(item.previousClose ?? item.prev_close ?? item.yesterdayPrice, priceOrig);
        const currencyFromServer = String(item.currency ?? matched.currency ?? Currency.USD);
        const keepOriginalCurrency = matched.category === AssetCategory.CRYPTOCURRENCY;
        const currencyStr = keepOriginalCurrency ? String(matched.currency ?? currencyFromServer) : currencyFromServer;
        const currency: Currency = [Currency.KRW, Currency.USD, Currency.JPY, Currency.CNY].includes(currencyStr as Currency)
          ? (currencyStr as Currency)
          : Currency.KRW;
        const priceKRW = typeof item.priceKRW === 'number'
          ? item.priceKRW
          : (currency === Currency.KRW ? priceOrig : priceOrig);
        const name = String(item.name ?? matched.ticker);
        const isMocked = !(priceOrig > 0);
        const result: AssetDataResult = {
          name,
          priceOriginal: priceOrig,
          priceKRW,
          currency,
          pricePreviousClose: prev,
          highestPrice: (currency === Currency.KRW ? priceKRW : priceOrig) * 1.1,
          isMocked,
        };
        resultMap.set(matched.id, result);
      });
    } catch (e) {
      console.error('API Error Details:', e);
      console.error('Chunk meta', { index: Math.floor(i / CHUNK_SIZE), size: chunk.length });
      await sleep(1000);
      try {
        const data = await fetchStocksBatch(payload);
        console.log('fetchBatchAssetPrices raw response (retry)', data);
        const items: PriceItem[] = [];
        if ('results' in data && Array.isArray((data as { results: PriceItem[] }).results)) {
          items.push(...(data as { results: PriceItem[] }).results);
        } else if (Array.isArray(data)) {
          items.push(...data);
        } else if (typeof data === 'object' && data) {
          Object.keys(data).forEach(k => {
            const v = data[k];
            if (v && typeof v === 'object') items.push({ ...v, ticker: k });
          });
        }
        items.forEach((item: PriceItem) => {
          const ticker = String(item.ticker ?? item.symbol ?? '').toUpperCase();
          const normalizedTicker = ticker.endsWith('-USD') ? ticker.replace(/-USD$/i, '') : ticker;
          const matched = assets.find(a => a.ticker.toUpperCase() === normalizedTicker);
          if (!matched) return;
          const priceOrig = toNumber(item.priceOriginal ?? item.price ?? item.close, 0);
          const prev = toNumber(item.previousClose ?? item.prev_close ?? item.yesterdayPrice, priceOrig);
          const currencyFromServer = String(item.currency ?? matched.currency ?? Currency.USD);
          const keepOriginalCurrency = matched.category === AssetCategory.CRYPTOCURRENCY;
          const currencyStr = keepOriginalCurrency ? String(matched.currency ?? currencyFromServer) : currencyFromServer;
          let currency: Currency = [Currency.KRW, Currency.USD, Currency.JPY, Currency.CNY].includes(currencyStr as Currency)
            ? (currencyStr as Currency)
            : Currency.KRW;

          if (matched.exchange === 'Upbit' || matched.exchange === 'Bithumb') {
            currency = Currency.KRW;
          }

          const priceKRW = typeof item.priceKRW === 'number'
            ? item.priceKRW
            : (currency === Currency.KRW ? priceOrig : priceOrig);
          const name = String(item.name ?? matched.ticker);
          const isMocked = !(priceOrig > 0);
          const result: AssetDataResult = {
            name,
            priceOriginal: priceOrig,
            priceKRW,
            currency,
            pricePreviousClose: prev,
            highestPrice: (currency === Currency.KRW ? priceKRW : priceOrig) * 1.1,
            isMocked,
          };
          resultMap.set(matched.id, result);
        });
      } catch (e2) {
        console.error('API Error Details (retry failed):', e2);
      }
    }
    await sleep(CHUNK_DELAY_MS);
  }

  assets.forEach(s => {
    if (!resultMap.has(s.id)) resultMap.set(s.id, {
      name: s.ticker,
      priceOriginal: 0,
      priceKRW: 0,
      currency: (s.currency ?? Currency.USD),
      pricePreviousClose: 0,
      highestPrice: 0,
      isMocked: true,
    });
  });

  return resultMap;
}

export async function fetchAssetData(asset: { ticker: string; exchange: string; category?: AssetCategory; currency?: Currency }): Promise<AssetDataResult> {
  const normalizedExchange = normalizeExchange(asset.exchange);
  try {
    const isCrypto = asset.category === AssetCategory.CRYPTOCURRENCY;
    const reqTicker = isCrypto ? `${String(asset.ticker).toUpperCase()}-USD` : String(asset.ticker).toUpperCase();
    const data = await fetchStocksBatch([{ ticker: reqTicker, exchange: normalizedExchange }]);
    const obj = extractByTickerKey(data, reqTicker);
    console.log('fetchAssetData parsed', obj);
    const priceOrig = toNumber(obj?.priceOriginal ?? obj?.price ?? obj?.close, 0);
    const prev = toNumber(obj?.previousClose ?? obj?.prev_close ?? obj?.yesterdayPrice, priceOrig);
    const currencyStr = String(obj?.currency ?? asset.currency ?? Currency.USD);
    const currency: Currency = [Currency.KRW, Currency.USD, Currency.JPY, Currency.CNY].includes(currencyStr as Currency)
      ? (currencyStr as Currency)
      : Currency.KRW;
    const priceKRW = typeof obj?.priceKRW === 'number'
      ? obj.priceKRW
      : (currency === Currency.KRW ? priceOrig : priceOrig);
    const name = String(obj?.name ?? asset.ticker);
    return {
      name,
      priceOriginal: priceOrig,
      priceKRW,
      currency,
      pricePreviousClose: prev,
      highestPrice: (currency === Currency.KRW ? priceKRW : priceOrig) * 1.1,
      isMocked: false,
    };
  } catch {
    throw new Error('시세 데이터를 가져오지 못했습니다. 잠시 후 다시 시도해주세요.');
  }
}
</file>

<file path="components/PortfolioTable.tsx">
import React, { useState, useRef, useEffect } from 'react';
import { AssetCategory } from '../types';
import { useOnClickOutside } from '../hooks/useOnClickOutside';
import { PortfolioTableProps, SortKey, SortDirection } from './portfolio-table/types';
import { usePortfolioData } from './portfolio-table/usePortfolioData';
import PortfolioTableRow from './portfolio-table/PortfolioTableRow';

const SortIcon = ({ sortKey, sortConfig }: { sortKey: SortKey, sortConfig: { key: SortKey; direction: SortDirection } | null }) => {
  if (!sortConfig || sortConfig.key !== sortKey) return <span className="opacity-30">↕</span>;
  return sortConfig.direction === 'descending' ? <span>▼</span> : <span>▲</span>;
};

const RefreshIcon: React.FC<{className?: string}> = ({className}) => (
  <svg xmlns="http://www.w3.org/2000/svg" className={`h-5 w-5 ${className}`} fill="none" viewBox="0 0 24 24" stroke="currentColor">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h5M20 20v-5h-5M4 4l1.5 1.5A9 9 0 0120.5 10M20 20l-1.5-1.5A9 9 0 003.5 14" />
  </svg>
);

const PortfolioTable: React.FC<PortfolioTableProps> = ({ 
  assets, 
  history, 
  onRefreshAll, 
  onRefreshSelected, 
  onEdit, 
  onSell, 
  isLoading, 
  sellAlertDropRate, 
  filterCategory, 
  onFilterChange, 
  filterAlerts, 
  searchQuery = '', 
  onSearchChange, 
  failedIds,
  exchangeRates 
}) => {
  const [showHiddenColumns, setShowHiddenColumns] = useState<boolean>(false);
  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());
  const [showFailedOnly, setShowFailedOnly] = useState<boolean>(false);
  const [openMenuId, setOpenMenuId] = useState<string | null>(null);
  const menuRef = useRef<HTMLDivElement | null>(null);
  const prevLoadingRef = useRef<boolean>(false);
  const [lastRunWasFullUpdate, setLastRunWasFullUpdate] = useState<boolean>(false);

  useOnClickOutside(menuRef, () => setOpenMenuId(null), !!openMenuId);

  const {
    enrichedAndSortedAssets,
    sortConfig,
    requestSort,
    toggleReturnSort,
    categoryOptions
  } = usePortfolioData({
    assets,
    exchangeRates,
    filterAlerts,
    sellAlertDropRate,
    showFailedOnly,
    failedIds
  });

  const allSelected = enrichedAndSortedAssets.length > 0 && enrichedAndSortedAssets.every(a => selectedIds.has(a.id));

  const getReturnHeaderLabel = () => {
    if (!sortConfig) return '수익률';
    if (sortConfig.key === 'returnPercentage') return `수익률 ${sortConfig.direction === 'descending' ? '▼' : '▲'}`;
    if (sortConfig.key === 'profitLossKRW') return `평가손익 ${sortConfig.direction === 'descending' ? '▼' : '▲'}`;
    return '수익률';
  };

  useEffect(() => {
    if (!isLoading && prevLoadingRef.current && lastRunWasFullUpdate && failedIds && failedIds.size > 0) {
      const ok = window.confirm('업데이트에 실패한 항목이 있습니다. 실패한 리스트만 보시겠습니까?');
      if (ok) setShowFailedOnly(true);
    }
    prevLoadingRef.current = isLoading;
  }, [isLoading, lastRunWasFullUpdate, failedIds]);

  const thClasses = "px-4 py-3 cursor-pointer hover:bg-gray-600 transition-colors sticky top-0 bg-gray-700 z-10 whitespace-nowrap";
  const thContentClasses = "flex items-center gap-2";

  return (
    <div className="bg-gray-800 rounded-lg shadow-lg">
      {/* 헤더 영역 */}
      <div className="bg-gray-800 px-4 sm:px-6 pt-4 sm:pt-6 pb-4 flex justify-between items-center gap-4 border-b border-gray-700">
        <div className="flex items-center gap-4">
          <h2 className="text-xl font-bold text-white">포트폴리오 현황</h2>
          {onSearchChange && (
            <div className="relative">
              <input
                type="text"
                value={searchQuery}
                onChange={(e) => onSearchChange(e.target.value)}
                placeholder="검색..."
                className="bg-gray-700 border border-gray-600 rounded-md py-2 pl-10 pr-10 text-white text-sm focus:outline-none focus:ring-2 focus:ring-primary w-48 sm:w-64"
              />
              <svg className="absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
              </svg>
              {searchQuery && (
                <button onClick={() => onSearchChange('')} className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-white">
                  <svg className="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
              )}
            </div>
          )}
        </div>
        <div className="flex items-center gap-2">
          {selectedIds.size > 0 && (
            <span className="bg-primary/20 text-primary px-2 py-1 rounded text-xs font-bold hidden sm:inline-block">
              {selectedIds.size}개 선택됨
            </span>
          )}

          <button
            onClick={() => {
              const ids = Array.from(selectedIds);
              if (ids.length > 0) {
                setLastRunWasFullUpdate(false);
                onRefreshSelected ? onRefreshSelected(ids) : onRefreshAll();
              } else {
                if (window.confirm('전체 종목을 업데이트 하시겠습니까?')) {
                  setLastRunWasFullUpdate(true);
                  onRefreshAll();
                }
              }
            }}
            disabled={isLoading}
            className="bg-primary hover:bg-primary-dark text-white font-medium py-2 px-3 sm:px-4 rounded-md transition duration-300 flex items-center disabled:bg-gray-600"
          >
            {isLoading ? (
              <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
            ) : <RefreshIcon className="-ml-1 mr-2 h-4 w-4"/>}
            <span>{isLoading ? '중...' : '업데이트'}</span>
          </button>
          
          <div className="flex items-center gap-2">
            <div className="relative hidden sm:block">
              <select
                value={filterCategory}
                onChange={(e) => onFilterChange(e.target.value as AssetCategory | 'ALL')}
                className="appearance-none bg-gray-700 border border-gray-600 text-white text-sm rounded-md py-2 pl-3 pr-8 focus:outline-none focus:ring-2 focus:ring-primary"
              >
                <option value="ALL">전체 자산</option>
                {categoryOptions.map(cat => (
                  <option key={cat} value={cat}>{cat}</option>
                ))}
              </select>
               <svg className="absolute right-2 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400 pointer-events-none" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
              </svg>
            </div>
            
             <button
              onClick={() => setShowHiddenColumns(!showHiddenColumns)}
              className={`py-2 px-3 rounded-md text-sm font-medium transition whitespace-nowrap ${showHiddenColumns ? 'bg-primary text-white' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'}`}
            >
              {showHiddenColumns ? '간소화' : '더보기'}
            </button>
          </div>
        </div>
      </div>

      {/* 테이블 영역 */}
      <div className="overflow-x-auto overflow-y-auto max-h-[70vh] relative">
        <table className="w-full text-sm">
          <thead className="bg-gray-700 text-gray-300 uppercase text-xs">
            <tr>
              <th scope="col" className="px-4 py-3 text-center sticky top-0 bg-gray-700 z-20">
                <input type="checkbox" checked={allSelected} onChange={(e) => {
                  if (e.target.checked) setSelectedIds(new Set(enrichedAndSortedAssets.map(a => a.id)));
                  else setSelectedIds(new Set());
                }} />
              </th>
              <th scope="col" className={`${thClasses} z-20`} onClick={() => requestSort('name')}>
                <div className={thContentClasses}><span>종목명</span> <SortIcon sortKey='name' sortConfig={sortConfig}/></div>
              </th>
              {showHiddenColumns && <th scope="col" className={`${thClasses} text-right`} onClick={() => requestSort('quantity')}><div className={`${thContentClasses} justify-end`}><span>보유수량</span> <SortIcon sortKey='quantity' sortConfig={sortConfig}/></div></th>}
              {showHiddenColumns && <th scope="col" className={`${thClasses} text-right`} onClick={() => requestSort('purchasePrice')}><div className={`${thContentClasses} justify-end`}><span>매수평균가</span> <SortIcon sortKey='purchasePrice' sortConfig={sortConfig}/></div></th>}
              <th scope="col" className={`${thClasses} text-right`} onClick={() => requestSort('currentPrice')}><div className={`${thContentClasses} justify-end`}><span>현재가</span> <SortIcon sortKey='currentPrice' sortConfig={sortConfig}/></div></th>
              <th scope="col" className={`${thClasses} justify-end`} onClick={toggleReturnSort}><div className={`${thContentClasses} justify-end`}><span>{getReturnHeaderLabel()}</span></div></th>
              <th scope="col" className={`${thClasses} justify-end`} onClick={() => requestSort('purchaseValue')}><div className={`${thContentClasses} justify-end`}><span>투자원금</span> <SortIcon sortKey='purchaseValue' sortConfig={sortConfig}/></div></th>
              <th scope="col" className={`${thClasses} justify-end`} onClick={() => requestSort('currentValue')}><div className={`${thContentClasses} justify-end`}><span>평가총액</span> <SortIcon sortKey='currentValue' sortConfig={sortConfig}/></div></th>
              {showHiddenColumns && <th scope="col" className={`${thClasses} text-center`} onClick={() => requestSort('purchaseDate')}><div className={`${thContentClasses} justify-center`}><span>매수일</span> <SortIcon sortKey='purchaseDate' sortConfig={sortConfig}/></div></th>}
              {showHiddenColumns && <th scope="col" className={`${thClasses} justify-end`} onClick={() => requestSort('allocation')}><div className={`${thContentClasses} justify-end`}><span>비중</span> <SortIcon sortKey='allocation' sortConfig={sortConfig}/></div></th>}
              <th scope="col" className={`${thClasses} justify-end`} onClick={() => requestSort('dropFromHigh')}><div className={`${thContentClasses} justify-end`}><span>최고가 대비</span> <SortIcon sortKey='dropFromHigh' sortConfig={sortConfig}/></div></th>
              <th scope="col" className={`${thClasses} justify-end`} onClick={() => requestSort('yesterdayChange')}><div className={`${thContentClasses} justify-end`}><span>어제대비</span> <SortIcon sortKey='yesterdayChange' sortConfig={sortConfig}/></div></th>
              <th scope="col" className="px-4 py-3 text-center sticky top-0 bg-gray-700 z-20">관리</th>
            </tr>
          </thead>
          <tbody>
            {enrichedAndSortedAssets.length > 0 ? enrichedAndSortedAssets.map(asset => (
              <PortfolioTableRow
                key={asset.id}
                asset={asset}
                history={history}
                selectedIds={selectedIds}
                onSelect={(id, checked) => {
                  const next = new Set(selectedIds);
                  checked ? next.add(id) : next.delete(id);
                  setSelectedIds(next);
                }}
                showHiddenColumns={showHiddenColumns}
                sellAlertDropRate={sellAlertDropRate}
                onEdit={onEdit}
                onSell={onSell}
                filterAlerts={filterAlerts}
              />
            )) : (
              <tr><td colSpan={13} className="text-center py-8 text-gray-500">
                  {filterAlerts ? '알림 기준을 초과한 자산이 없습니다.' : '자산이 없습니다.'}
              </td></tr>
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
};

export default PortfolioTable;
</file>

<file path="App.tsx">
import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { AssetCategory } from './types';
import Header from './components/Header';
import EditAssetModal from './components/EditAssetModal';
import SellAssetModal from './components/SellAssetModal';
import BulkUploadModal from './components/BulkUploadModal';
import AddNewAssetModal from './components/AddNewAssetModal';
import PortfolioAssistant from './components/PortfolioAssistant';

// Hooks
import { PortfolioProvider, usePortfolio } from './contexts/PortfolioContext';

// Layouts
import DashboardView from './components/layouts/DashboardView';
import PortfolioView from './components/layouts/PortfolioView';
import AnalyticsView from './components/layouts/AnalyticsView';
import WatchlistView from './components/layouts/WatchlistView';

type ActiveTab = 'dashboard' | 'portfolio' | 'analytics' | 'watchlist';

const AppContent: React.FC = () => {
  const { data, status, ui, modal, actions, derived } = usePortfolio();
  

  const [updateAvailable, setUpdateAvailable] = useState<boolean>(false);
  const [fileName, setFileName] = useState<string>('portfolio.json');




  // 버전 체크 로직
  useEffect(() => {
    const checkForUpdate = async () => {
      try {
        const res = await fetch('metadata.json', { cache: 'no-store' });
        if (!res.ok) return;
        const lm = res.headers.get('last-modified');
        if (lm) {
          const prev = localStorage.getItem('app.lastModified');
          if (prev && prev !== lm) {
            setUpdateAvailable(true);
          }
          localStorage.setItem('app.lastModified', lm);
        }
      } catch {}
    };
    checkForUpdate();
  }, []);

  

  

  

  


  const TabButton: React.FC<{tabId: ActiveTab; children: React.ReactNode; onClick: () => void}> = ({ tabId, children, onClick }) => {
    const isActive = ui.activeTab === tabId;
    const activeClasses = "border-primary text-primary";
    const inactiveClasses = "border-transparent text-gray-400 hover:text-white hover:border-gray-500";
    return (
        <button
          onClick={onClick}
          className={`py-4 px-1 text-center border-b-2 font-medium text-sm focus:outline-none transition-colors duration-300 ${isActive ? activeClasses : inactiveClasses}`}
        >
          {children}
        </button>
    );
  };

  return (
    <div className="min-h-screen bg-gray-900 font-sans p-4 sm:p-6 lg:p-8">
      <div className="max-w-7xl mx-auto">
        <Header 
          onSave={actions.saveToDrive} 
          onImport={actions.importJsonPrompt}
          onExport={() => actions.exportJson()}
          onExportToCsv={actions.exportCsv}
          onOpenBulkUploadModal={actions.openBulkUpload}
          onOpenAddAssetModal={actions.openAddAsset}
          onSignIn={actions.signIn}
          onSignOut={actions.signOut}
          isSignedIn={status.isSignedIn}
          userEmail={status.userEmail}
        />
        
        {/* Update Notification & Messages */}
        <div className="fixed top-4 left-1/2 -translate-x-1/2 z-50 w-[90%] max-w-xl space-y-3 pointer-events-none">
          {updateAvailable && (
            <div className="bg-blue-600 text-white px-4 py-3 rounded-lg shadow-lg flex justify-between items-center pointer-events-auto" role="alert">
              <span className="block sm:inline">새 버전이 배포되었습니다.</span>
              <div className="flex items-center gap-2">
                <button
                  className="ml-2 bg-white/20 hover:bg-white/30 text-white px-3 py-1 rounded transition"
                  onClick={() => {
                    const baseUrl = window.location.href.split('?')[0];
                    window.location.replace(`${baseUrl}?_ts=${Date.now()}`);
                  }}
                >
                  업데이트 적용
                </button>
                <button
                  className="ml-2 text-white/80 hover:text-white transition"
                  onClick={() => setUpdateAvailable(false)}
                >
                  ✕
                </button>
              </div>
            </div>
          )}
          {status.successMessage && (
            <div className="bg-success/90 text-white px-4 py-3 rounded-lg shadow-lg flex justify-between items-center pointer-events-auto">
              <span className="block sm:inline">{status.successMessage}</span>
              <button className="ml-4 text-white/80 hover:text-white transition" onClick={() => actions.clearSuccessMessage()}>✕</button>
            </div>
          )}
          {status.error && (
            <div className="bg-danger/90 text-white px-4 py-3 rounded-lg shadow-lg flex justify-between items-center pointer-events-auto">
              <span className="block sm:inline">{status.error}</span>
              <button className="ml-4 text-white/80 hover:text-white transition" onClick={() => actions.clearError()}>✕</button>
            </div>
          )}
        </div>

        {status.isSignedIn ? (
          <>
            <div className="border-b border-gray-700">
              <nav className="-mb-px flex space-x-8" aria-label="Tabs">
                <TabButton tabId="dashboard" onClick={() => actions.setActiveTab('dashboard')}>대시보드</TabButton>
                <TabButton tabId="portfolio" onClick={() => actions.setActiveTab('portfolio')}>포트폴리오 상세</TabButton>
                <TabButton tabId="analytics" onClick={() => actions.setActiveTab('analytics')}>수익 통계</TabButton>
                <TabButton tabId="watchlist" onClick={() => actions.setActiveTab('watchlist')}>관심종목</TabButton>
              </nav>
            </div>

            <main className="mt-8">
              {ui.activeTab === 'dashboard' && (
                <DashboardView />
              )}

              {ui.activeTab === 'portfolio' && (
                <PortfolioView />
              )}

              {ui.activeTab === 'analytics' && (
                <AnalyticsView />
              )}
              
              {ui.activeTab === 'watchlist' && (
                <WatchlistView />
              )}
            </main>
            
            <EditAssetModal />
            <SellAssetModal />
            <BulkUploadModal />
            <AddNewAssetModal />

            <button
              onClick={actions.openAssistant}
              className="fixed bottom-8 right-8 bg-primary hover:bg-primary-dark text-white rounded-full p-4 shadow-lg transition-transform transform hover:scale-110 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-primary"
              title="포트폴리오 어시스턴트 열기"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8" viewBox="0 0 24 24" fill="currentColor">
                <path d="M14 12c0 .552-.448 1-1 1s-1-.448-1-1 .448-1 1-1 1 .448 1 1zm-1-3.5c-2.481 0-4.5 2.019-4.5 4.5s2.019 4.5 4.5 4.5 4.5-2.019 4.5-4.5-2.019-4.5-4.5-4.5zm0-3.5c-4.411 0-8 3.589-8 8s3.589 8 8 8 8-3.589 8-8-3.589-8-8-8zm-5.5 8c0-3.033 2.468-5.5 5.5-5.5s5.5 2.467 5.5 5.5-2.468 5.5-5.5 5.5-5.5-2.467-5.5-5.5zm11.5 0c0 .828-.672 1.5-1.5 1.5s-1.5-.672-1.5-1.5.672-1.5 1.5-1.5 1.5.672 1.5 1.5z"/>
              </svg>
            </button>

            <PortfolioAssistant />
          </>
        ) : (
          <div className="mt-12 bg-gray-800 border border-gray-700 rounded-lg p-8 text-center text-gray-200">
            <h2 className="text-2xl font-semibold mb-4">Google Drive 로그인 필요</h2>
            <p className="text-gray-400">
              포트폴리오 데이터는 Google Drive에만 저장됩니다. 상단의 로그인 버튼을 눌러 계정에 연결한 뒤 이용해주세요.
            </p>
          </div>
        )}
      </div>

    </div>
  );
};

const App: React.FC = () => (
  <PortfolioProvider>
    <AppContent />
  </PortfolioProvider>
);

export default App;
</file>

<file path="services/geminiService.ts">
import { GoogleGenAI } from '@google/genai';
import { Asset, Currency, SymbolSearchResult, normalizeExchange, AssetDataResult } from '../types';

// =================================================================
// 1. 설정 및 초기화
// =================================================================
const API_KEY = import.meta.env.VITE_GEMINI_API_KEY;
const ai = API_KEY ? new GoogleGenAI({ apiKey: API_KEY }) : null;

console.log("Gemini Service Status:", API_KEY ? "✅ API Key Loaded" : "❌ No API Key");

// =================================================================
// 2. 캐싱 시스템 (API 호출 횟수 감소)
// =================================================================
interface CacheEntry<T> {
  data: T;
  timestamp: number;
}

const CACHE_TTL = 5 * 60 * 1000; // 5분
const priceCache = new Map<string, CacheEntry<AssetDataResult>>();
const searchCache = new Map<string, CacheEntry<SymbolSearchResult[]>>();
const exchangeRateCache = new Map<string, CacheEntry<number>>();

function getCached<T>(cache: Map<string, CacheEntry<T>>, key: string): T | null {
  const entry = cache.get(key);
  if (entry && Date.now() - entry.timestamp < CACHE_TTL) {
    return entry.data;
  }
  cache.delete(key);
  return null;
}

function setCache<T>(cache: Map<string, CacheEntry<T>>, key: string, data: T): void {
  cache.set(key, { data, timestamp: Date.now() });
}

// =================================================================
// 3. Rate Limiting (API 차단 방지)
// =================================================================
const requestQueue: Array<() => Promise<void>> = [];
let isProcessing = false;
const MIN_REQUEST_INTERVAL = 500; // 0.5초 간격

async function processQueue(): Promise<void> {
  if (isProcessing || requestQueue.length === 0) return;
  
  isProcessing = true;
  while (requestQueue.length > 0) {
    const request = requestQueue.shift();
    if (request) {
      await request();
      await delay(MIN_REQUEST_INTERVAL);
    }
  }
  isProcessing = false;
}

function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// =================================================================
// 4. Gemini API 호출 (SDK 방식 - 안정적)
// =================================================================
async function callGeminiWithSearch(prompt: string): Promise<string> {
  if (!ai) {
    console.error("Gemini AI not initialized");
    return "";
  }

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
      config: {
        tools: [{ googleSearch: {} }],
      }
    });

    const text = response.text?.trim() || "";
    // JSON 블록 정리
    return text.replace(/^```json\s*|```$/g, '').trim();
  } catch (error) {
    console.error("Gemini API Error:", error);
    return "";
  }
}

async function callGeminiBasic(prompt: string): Promise<string> {
  if (!ai) {
    console.error("Gemini AI not initialized");
    return "";
  }

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
    });

    return response.text?.trim() || "";
  } catch (error) {
    console.error("Gemini API Error:", error);
    return "";
  }
}

// =================================================================
// 5. 종목 검색
// =================================================================
export async function searchSymbols(query: string): Promise<SymbolSearchResult[]> {
  const cacheKey = query.toLowerCase();
  const cached = getCached(searchCache, cacheKey);
  if (cached) return cached;

  if (!ai) return [];

  const prompt = `Search for stock or crypto symbols matching "${query}".
Return a JSON array of up to 5 results. Each object in the array must have these exact keys: "ticker", "name" (in Korean), and "exchange" (e.g., "NASDAQ", "KRX (코스피/코스닥)", "주요 거래소 (종합)").

Example for query "samsung":
[
  {
    "ticker": "005930",
    "name": "삼성전자",
    "exchange": "KRX (코스피/코스닥)"
  }
]

Example for query "apple":
[
  {
    "ticker": "AAPL",
    "name": "Apple Inc.",
    "exchange": "NASDAQ"
  }
]

If no results are found, return an empty array [].
Your final output must be only the JSON array, with no other text or markdown formatting.`;

  try {
    const jsonText = await callGeminiWithSearch(prompt);
    const parsed = JSON.parse(jsonText || "[]");
    const isItem = (x: unknown): x is SymbolSearchResult => {
      return !!x && typeof (x as SymbolSearchResult).ticker === 'string' &&
        typeof (x as SymbolSearchResult).name === 'string' &&
        typeof (x as SymbolSearchResult).exchange === 'string';
    };
    const results: SymbolSearchResult[] = Array.isArray(parsed) ? parsed.filter(isItem) : [];
    setCache(searchCache, cacheKey, results);
    return results;
  } catch (error) {
    console.error(`Search failed for "${query}":`, error);
    return [];
  }
}

// =================================================================
// 6. 단일 자산 시세 조회
// =================================================================

export const fetchAssetData = async (
  ticker: string, 
  exchange: string, 
  currencyInput?: Currency
): Promise<AssetDataResult> => {
  const normalizedExchange = normalizeExchange(exchange);
  const cacheKey = `${ticker}-${exchange}`;
  const cached = getCached(priceCache, cacheKey);
  if (cached) {
    console.log(`📦 Cache hit: ${ticker}`);
    return cached;
  }

  if (!ai) {
    return createMockResult(ticker);
  }

  const prompt = `Using Google Search, find the following data for the asset with ticker "${ticker}" listed on the "${normalizedExchange}" exchange.
Use EXACT ticker match ("${ticker}"). If the exchange is NYSE American/AMEX, treat them as synonyms.
Do NOT return data for similarly named tickers:
1. The closing price for the MOST RECENT trading day.
1. The closing price for the MOST RECENT trading day.
2. The closing price for the PREVIOUS trading day (the day before the most recent one).
3. Its official name in Korean.

Return the response ONLY as a JSON object with these keys:
- "name": Official Korean name.
- "priceOriginal": Most recent closing price in native currency.
- "previousClose": Previous trading day's closing price in native currency.
- "currency": ISO 4217 currency code (e.g., USD, KRW, JPY).
- "priceKRW": Most recent closing price converted to Korean Won (KRW).

Example for AAPL (NASDAQ):
{
  "name": "애플",
  "priceOriginal": 215.50,
  "previousClose": 214.00,
  "currency": "USD",
  "priceKRW": 295000
}

Ensure all prices are numbers. Return ONLY the JSON object.`;

  try {
    const jsonText = await callGeminiWithSearch(prompt);
    const data = JSON.parse(jsonText || "{}");

    const priceOriginal = Number(data.priceOriginal) || 0;
    const priceKRW = Number(data.priceKRW) || 0;
    const previousClose = Number(data.previousClose) || priceOriginal;

    if (priceOriginal === 0 && priceKRW === 0) {
      throw new Error('Invalid price data');
    }

    const result: AssetDataResult = {
      name: data.name || ticker,
      priceOriginal,
      priceKRW,
      currency: data.currency || 'KRW',
      pricePreviousClose: previousClose,
      highestPrice: priceKRW * 1.1,
      isMocked: false
    };

    setCache(priceCache, cacheKey, result);
    console.log(`✅ Fetched: ${ticker} = ${priceKRW.toLocaleString()} KRW`);
    return result;
  } catch (error) {
    console.error(`❌ Failed to fetch ${ticker}:`, error);
    return createMockResult(ticker);
  }
};

function createMockResult(ticker: string): AssetDataResult {
  return {
    name: ticker,
    priceOriginal: 0,
    priceKRW: 0,
    currency: Currency.KRW,
    pricePreviousClose: 0,
    highestPrice: 0,
    isMocked: true
  };
}

// =================================================================
// 7. 배치 시세 조회 (핵심 성능 개선!)
// =================================================================
export const fetchBatchAssetPrices = async (
  assets: { ticker: string; exchange: string; id: string }[]
): Promise<Map<string, AssetDataResult>> => {
  const resultMap = new Map<string, AssetDataResult>();
  
  if (assets.length === 0) return resultMap;
  if (!ai) {
    assets.forEach(a => resultMap.set(a.id, createMockResult(a.ticker)));
    return resultMap;
  }

  // 캐시 확인 - 캐시에 있는 것들은 바로 반환
  const uncachedAssets: typeof assets = [];
  for (const asset of assets) {
    const cacheKey = `${asset.ticker}-${asset.exchange}`;
    const cached = getCached(priceCache, cacheKey);
    if (cached) {
      resultMap.set(asset.id, cached);
      console.log(`📦 Cache hit: ${asset.ticker}`);
    } else {
      uncachedAssets.push(asset);
    }
  }

  if (uncachedAssets.length === 0) {
    return resultMap;
  }

  // 배치 크기 제한 (한 번에 최대 10개)
  const BATCH_SIZE = 10;
  const batches: typeof assets[] = [];
  
  for (let i = 0; i < uncachedAssets.length; i += BATCH_SIZE) {
    batches.push(uncachedAssets.slice(i, i + BATCH_SIZE));
  }

  for (const batch of batches) {
    const batchResults = await fetchBatchInternal(batch);
    batchResults.forEach((value, key) => {
      resultMap.set(key, value);
    });
    
    // 배치 간 딜레이
    if (batches.length > 1) {
      await delay(1000);
    }
  }

  return resultMap;
};

interface BatchItem {
  id: string;
  name?: string;
  priceKRW: number;
  priceOriginal?: number;
  previousClose?: number;
  currency?: string;
}

async function fetchBatchInternal(
  assets: { ticker: string; exchange: string; id: string }[]
): Promise<Map<string, AssetDataResult>> {
  const resultMap = new Map<string, AssetDataResult>();

  const assetsListString = assets
    .map(a => `{"ticker": "${a.ticker}", "exchange": "${normalizeExchange(a.exchange)}", "id": "${a.id}"}`)
    .join(',\n');

  const prompt = `I have a list of assets. Using Google Search, find the following for EACH asset:
1. Closing price of the MOST RECENT trading day.
2. Closing price of the PREVIOUS trading day (Previous Close).

Assets List:
[
${assetsListString}
]

Use EXACT ticker matches. If the exchange is NYSE American/AMEX, treat them as synonyms.
Return the response ONLY as a JSON ARRAY of objects. Each object must strictly follow this structure:
{
  "id": "The exact id provided in the input",
  "name": "The official Korean name of the asset",
  "priceOriginal": Number (recent close in native currency),
  "previousClose": Number (previous close in native currency),
  "currency": "ISO 4217 currency code (e.g. USD, KRW, JPY)",
  "priceKRW": Number (recent close converted to Korean Won)
}

Ensure all prices are numbers. Do not miss any assets. Return ONLY the JSON array.`;

  try {
    const jsonText = await callGeminiWithSearch(prompt);
    const data = JSON.parse(jsonText || "[]");

    if (!Array.isArray(data)) {
      throw new Error('Batch API did not return an array.');
    }

    data.forEach((item: BatchItem) => {
      if (item.id && typeof item.priceKRW === 'number') {
        const result: AssetDataResult = {
          name: item.name || '',
          priceKRW: item.priceKRW,
          priceOriginal: item.priceOriginal || item.priceKRW,
          pricePreviousClose: item.previousClose || item.priceOriginal || item.priceKRW,
          currency: (item.currency as Currency) || Currency.KRW,
          highestPrice: item.priceKRW * 1.1,
          isMocked: false
        };
        
        resultMap.set(item.id, result);
        
        // 개별 캐시에도 저장
        const asset = assets.find(a => a.id === item.id);
        if (asset) {
          const cacheKey = `${asset.ticker}-${asset.exchange}`;
          setCache(priceCache, cacheKey, result);
        }
        
        console.log(`✅ Batch fetched: ${item.name || item.id} = ${item.priceKRW?.toLocaleString()} KRW`);
      }
    });

    // 실패한 자산들은 mock 데이터로 채움
    assets.forEach(asset => {
      if (!resultMap.has(asset.id)) {
        console.warn(`⚠️ Missing in batch result: ${asset.ticker}`);
        resultMap.set(asset.id, createMockResult(asset.ticker));
      }
    });

    return resultMap;
  } catch (error) {
    console.error('❌ Batch fetch failed:', error);
    // 전체 실패 시 개별 조회로 폴백
    for (const asset of assets) {
      try {
        const singleResult = await fetchAssetData(asset.ticker, asset.exchange);
        resultMap.set(asset.id, singleResult);
        await delay(500);
      } catch {
        resultMap.set(asset.id, createMockResult(asset.ticker));
      }
    }
    return resultMap;
  }
}

// =================================================================
// 8. 환율 조회
// =================================================================
export const fetchCurrentExchangeRate = async (
  fromCurrency: string, 
  toCurrency: string
): Promise<number> => {
  if (fromCurrency === toCurrency) return 1;

  const cacheKey = `${fromCurrency}-${toCurrency}`;
  const cached = getCached(exchangeRateCache, cacheKey);
  if (cached) return cached;

  if (!ai) return getDefaultExchangeRate(fromCurrency, toCurrency);

  const prompt = `Using Google Search, what was the closing exchange rate for the most recent business day between ${fromCurrency} and ${toCurrency}?
Return the response ONLY as a JSON object with a single key "rate".
The value should be a number representing how many ${toCurrency} one ${fromCurrency} is worth.
For example, for USD to KRW, the response should be:
{
  "rate": 1380.25
}
Do not include any other text, symbols, or explanations. Your final output must be only the JSON object.`;

  try {
    const jsonText = await callGeminiWithSearch(prompt);
    const data = JSON.parse(jsonText || "{}");

    if (typeof data.rate !== 'number') {
      throw new Error('Invalid rate format');
    }

    setCache(exchangeRateCache, cacheKey, data.rate);
    console.log(`💱 Exchange rate ${fromCurrency}→${toCurrency}: ${data.rate}`);
    return data.rate;
  } catch (error) {
    console.error(`Failed to fetch exchange rate ${fromCurrency}→${toCurrency}:`, error);
    return getDefaultExchangeRate(fromCurrency, toCurrency);
  }
};

export const fetchHistoricalExchangeRate = async (
  date: string, 
  fromCurrency: string, 
  toCurrency: string
): Promise<number> => {
  if (fromCurrency === toCurrency) return 1;
  if (!ai) return getDefaultExchangeRate(fromCurrency, toCurrency);

  const prompt = `Using Google Search, what was the exchange rate between ${fromCurrency} and ${toCurrency} at the end of the day on ${date}?
Return the response ONLY as a JSON object with a single key "rate".
The value should be a number representing how many ${toCurrency} one ${fromCurrency} was worth.
For example, for USD to KRW, the response should be:
{
  "rate": 1350.5
}
Do not include any other text, symbols, or explanations. Your final output must be only the JSON object.`;

  try {
    const jsonText = await callGeminiWithSearch(prompt);
    const data = JSON.parse(jsonText || "{}");

    if (typeof data.rate !== 'number') {
      throw new Error('Invalid rate format');
    }

    return data.rate;
  } catch (error) {
    console.error(`Failed to fetch historical exchange rate:`, error);
    return getDefaultExchangeRate(fromCurrency, toCurrency);
  }
};

function getDefaultExchangeRate(from: string, to: string): number {
  // 기본 환율 (폴백용)
  const rates: Record<string, number> = {
    'USD-KRW': 1400,
    'JPY-KRW': 9.5,
    'EUR-KRW': 1500,
    'CNY-KRW': 195,
  };
  return rates[`${from}-${to}`] || 1;
}

// =================================================================
// 9. 포트폴리오 분석 (AI 채팅)
// =================================================================
function formatAssetsForAI(assets: Asset[]): string {
  return assets.map(asset => {
    const value = asset.quantity * asset.currentPrice;
    const displayName = asset.customName ?? asset.name;
    return `- ${displayName} (${asset.ticker}): ${asset.quantity}주, 현재가 ${asset.currentPrice.toLocaleString()}원, 평가액 ${value.toLocaleString()}원, 카테고리: ${asset.category}`;
  }).join('\n');
}

export const askPortfolioQuestion = async (
  assets: Asset[], 
  question: string
): Promise<string> => {
  if (!ai) return "API 키가 설정되지 않았습니다.";

  const simplifiedAssets = assets.map(asset => ({
    name: asset.customName ?? asset.name,
    ticker: asset.ticker,
    exchange: asset.exchange,
    category: asset.category,
    quantity: asset.quantity,
    purchase_price_original: asset.purchasePrice,
    purchase_date: asset.purchaseDate,
    current_price_krw: asset.currentPrice,
    price_original: asset.priceOriginal,
    currency: asset.currency,
    current_value_krw: asset.currentPrice * asset.quantity,
    highest_price_krw: asset.highestPrice,
    yesterday_price_krw: asset.yesterdayPrice ?? null,
  }));

  const portfolioJson = JSON.stringify(simplifiedAssets, null, 2);

  const prompt = `당신은 사용자의 자산 포트폴리오를 분석하고 질문에 답변하는 전문 금융 어시스턴트입니다.
    
다음은 사용자의 현재 포트폴리오 데이터입니다 (JSON 형식). 각 항목에는 현재가와 함께 어제 종가가 포함될 수 있으므로, "어제 대비" 변동을 계산할 때는 \`yesterday_price_krw\`를 사용하세요. 날짜 메타가 없으면 제공된 값만으로 판단하세요:
\`\`\`json
${portfolioJson}
\`\`\`

위 데이터를 기반으로 다음 사용자의 질문에 대해 명확하고 간결하게 답변해주세요. 답변은 한국어로 작성하고, 마크다운 형식을 사용하여 가독성을 높여주세요. 외부 정보는 사용하지 말고, 제공된 포트폴리오 데이터만을 근거로 분석해야 합니다.

사용자 질문: "${question}"`;

  try {
    const response = await callGeminiBasic(prompt);
    return response || "죄송합니다. 답변을 생성할 수 없습니다.";
  } catch (error) {
    console.error('Portfolio question error:', error);
    return "포트폴리오 질문에 대한 답변 생성에 실패했습니다.";
  }
};

// 레거시 호환용
export const analyzePortfolio = askPortfolioQuestion;

// =================================================================
// 10. 캐시 관리 유틸리티
// =================================================================
export function clearPriceCache(): void {
  priceCache.clear();
  console.log("🗑️ Price cache cleared");
}

export function clearAllCaches(): void {
  priceCache.clear();
  searchCache.clear();
  exchangeRateCache.clear();
  console.log("🗑️ All caches cleared");
}

export function getCacheStats(): { prices: number; searches: number; rates: number } {
  return {
    prices: priceCache.size,
    searches: searchCache.size,
    rates: exchangeRateCache.size
  };
}
</file>

</files>
